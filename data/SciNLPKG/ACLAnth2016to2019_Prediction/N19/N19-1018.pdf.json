{"title": [{"text": "Discontinuous Constituency Parsing with a Stack-Free Transition System and a Dynamic Oracle", "labels": [], "entities": [{"text": "Discontinuous Constituency Parsing", "start_pos": 0, "end_pos": 34, "type": "TASK", "confidence": 0.6264787912368774}]}], "abstractContent": [{"text": "We introduce a novel transition system for dis-continuous constituency parsing.", "labels": [], "entities": [{"text": "constituency parsing", "start_pos": 58, "end_pos": 78, "type": "TASK", "confidence": 0.6719533950090408}]}, {"text": "Instead of storing subtrees in a stack-i.e. a data structure with linear-time sequential access-the proposed system uses a set of parsing items, with constant-time random access.", "labels": [], "entities": []}, {"text": "This change makes it possible to construct any discontinu-ous constituency tree in exactly 4n \u2212 2 transitions fora sentence of length n, whereas existing systems need a quadratic number of transitions to derive some structures.", "labels": [], "entities": []}, {"text": "At each parsing step, the parser considers every item in the set to be combined with a focus item and to construct anew constituent in a bottom-up fashion.", "labels": [], "entities": []}, {"text": "The parsing strategy is based on the assumption that most syntactic structures can be parsed incrementally and that the set-the memory of the parser-remains reasonably small on average.", "labels": [], "entities": [{"text": "parsing", "start_pos": 4, "end_pos": 11, "type": "TASK", "confidence": 0.9705345630645752}]}, {"text": "Moreover, we introduce a dynamic oracle for the new transition system, and present the first experiments in discontin-uous constituency parsing using a dynamic oracle.", "labels": [], "entities": [{"text": "discontin-uous constituency parsing", "start_pos": 108, "end_pos": 143, "type": "TASK", "confidence": 0.6024897793928782}]}, {"text": "Our parser obtains state-of-the-art results on three English and German discontinuous treebanks.", "labels": [], "entities": []}], "introductionContent": [{"text": "Discontinuous constituency trees extend standard constituency trees by allowing crossing branches to represent long distance dependencies, such as the wh-extraction in.", "labels": [], "entities": []}, {"text": "Discontinuous constituency trees can be seen as derivations of Linear Context-Free Rewriting Systems (LCFRS,, a class of formal grammars more expressive than context-free grammars, which makes them much harder to parse.", "labels": [], "entities": []}, {"text": "In particular, exact CKY-style LCFRS parsing has an O(n 3f ) time complexity where f is the fan-out of the grammar  A natural alternative to grammar-based chart parsing is transition-based parsing, that usually relies on fast approximate decoding methods such as greedy search or beam search.", "labels": [], "entities": [{"text": "CKY-style LCFRS parsing", "start_pos": 21, "end_pos": 44, "type": "TASK", "confidence": 0.5431856910387675}, {"text": "O(n 3f ) time complexity", "start_pos": 52, "end_pos": 76, "type": "METRIC", "confidence": 0.7122262673718589}, {"text": "grammar-based chart parsing", "start_pos": 141, "end_pos": 168, "type": "TASK", "confidence": 0.7155696352322897}, {"text": "transition-based parsing", "start_pos": 172, "end_pos": 196, "type": "TASK", "confidence": 0.5879204273223877}]}, {"text": "Transitionbased discontinuous parsers construct discontinuous constituents by reordering terminals with the SWAP action, or by using a split stack and the GAP action to combine two non-adjacent constituents).", "labels": [], "entities": []}, {"text": "These proposals represent the memory of the parser (i.e. the tree fragments being constructed) with data structures with linear-time sequential access (either a stack, or a stack coupled with a double-ended queue).", "labels": [], "entities": []}, {"text": "As a result, these systems need to perform at least n actions to construct anew constituent from two subtrees separated by n intervening subtrees.", "labels": [], "entities": []}, {"text": "Our proposal aims at avoiding this cost when constructing discontinuous constituents.", "labels": [], "entities": []}, {"text": "We design a novel transition system in which a discontinuous constituent is constructed in a single step, without the use of reordering actions such as SWAP.", "labels": [], "entities": []}, {"text": "The main innovation is that the memory of the parser is not represented by a stack, Initial configuration (\u2205, null, 0, \u2205) : 0 Goal configuration (\u2205, {0, 1, . .", "labels": [], "entities": []}, {"text": ", n \u2212 1}, n, C) : 4n \u2212 2 Structural actions Input Output Precondition SHIFT (S, sf , i, C) : j \u21d2 (S \u222a {s f }, {i}, i + 1, C) : j + 1 i < n, j is even COMBINE-s (S, sf , i, C) : j \u21d2 (S \u2212 s, sf \u222a s, i, C) : j + 1 s \u2208 S, j is even Labelling actions LABEL-X (S, sf , i, C) : j \u21d2 (S, sf , i, C \u222a {(X, sf )}) : j + 1 j is odd NO-LABEL (S, sf , i, C) : j \u21d2 (S, sf , i, C) : j + 1 i = nor S = \u2205, j is odd  Ina stack-based system like shift-reduceswap (upper part), the parser extracts features from a local region of the configuration (orange part), to predict the next action such as: construct anew tree with label X and children s 0 and s 1 (REDUCE-X).", "labels": [], "entities": [{"text": "NO-LABEL", "start_pos": 320, "end_pos": 328, "type": "METRIC", "confidence": 0.9395198225975037}, {"text": "REDUCE-X", "start_pos": 637, "end_pos": 645, "type": "METRIC", "confidence": 0.8862108588218689}]}, {"text": "In our proposed set-based system (lower part), we consider every item in the set to be combined bottom-up with the focus item sf and score independently each possible transition.", "labels": [], "entities": []}, {"text": "as is usual in shift-reduce systems, but by an unordered random-access set.", "labels": [], "entities": []}, {"text": "The parser considers every constituent in the current memory to construct anew constituent in a bottom-up fashion, and thus instantly models interactions between parsing items that are not adjacent.", "labels": [], "entities": []}, {"text": "As such, we describe a left-to-right parsing model that deviates from the standard stack-buffer setting, a legacy from pushdown automata and classical parsing algorithms for context-free grammars.", "labels": [], "entities": []}, {"text": "Our contributions are summarized as follows: \u2022 We design a novel transition system for discontinuous constituency parsing, based on a memory represented by a set of items, and that derives any tree in exactly 4n \u2212 2 steps fora sentence of length n; \u2022 we introduce the first dynamic oracle for discontinuous constituency parsing; \u2022 we present an empirical evaluation of the transition system and dynamic oracle on two German and one English discontinuous treebanks.", "labels": [], "entities": [{"text": "discontinuous constituency parsing", "start_pos": 87, "end_pos": 121, "type": "TASK", "confidence": 0.6856462955474854}, {"text": "discontinuous constituency parsing", "start_pos": 293, "end_pos": 327, "type": "TASK", "confidence": 0.6076348920663198}]}, {"text": "The code of our parser is released as an opensource project at https://gitlab.com/ mcoavoux/discoparset.", "labels": [], "entities": []}], "datasetContent": [{"text": "We carried out experiments to assess the adequacy of our system and the effect of training with the dynamic oracle.", "labels": [], "entities": []}, {"text": "We present the three discontinuous constituency treebanks that we used (Section 4.1), our experimental protocol (Section 4.2), then we discuss the results (Section 4.3) and the efficiency of the parser (Section 4.4).", "labels": [], "entities": []}, {"text": "We perform experiments on three discontinuous constituency corpora.", "labels": [], "entities": []}, {"text": "The discontinuous Penn Treebank was introduced by who converted the long distance dependencies encoded by indexed traces in the original Penn treebank () to discontinuous constituents.", "labels": [], "entities": [{"text": "Penn Treebank", "start_pos": 18, "end_pos": 31, "type": "DATASET", "confidence": 0.9900457262992859}, {"text": "Penn treebank", "start_pos": 137, "end_pos": 150, "type": "DATASET", "confidence": 0.9851501882076263}]}, {"text": "We used the standard split (sections 2-21 for training, 22 for development and 23 for test).", "labels": [], "entities": []}, {"text": "The Tiger corpus () and the Negra corpus () are both German treebanks natively annotated with discontinuous constituents.", "labels": [], "entities": [{"text": "Tiger corpus", "start_pos": 4, "end_pos": 16, "type": "DATASET", "confidence": 0.9658065438270569}, {"text": "Negra corpus", "start_pos": 28, "end_pos": 40, "type": "DATASET", "confidence": 0.9531099498271942}]}, {"text": "We used the SPMRL split for the Tiger corpus (, and the split of for the Negra corpus.", "labels": [], "entities": [{"text": "SPMRL split", "start_pos": 12, "end_pos": 23, "type": "DATASET", "confidence": 0.7748691439628601}, {"text": "Tiger corpus", "start_pos": 32, "end_pos": 44, "type": "DATASET", "confidence": 0.9894028604030609}, {"text": "Negra corpus", "start_pos": 73, "end_pos": 85, "type": "DATASET", "confidence": 0.9615667760372162}]}], "tableCaptions": [{"text": " Table 3: Results on development corpora. F1 is the Fscore on all constituents, Disc. F1 is an Fscore computed only  on discontinuous constituents, POS is the accuracy on part-of-speech tags. Detailed results (including precision  and recall) are given in Table 7 of Appendix C.", "labels": [], "entities": [{"text": "F1", "start_pos": 42, "end_pos": 44, "type": "METRIC", "confidence": 0.9921742677688599}, {"text": "Fscore", "start_pos": 52, "end_pos": 58, "type": "METRIC", "confidence": 0.9970253109931946}, {"text": "F1", "start_pos": 86, "end_pos": 88, "type": "METRIC", "confidence": 0.9737933278083801}, {"text": "Fscore", "start_pos": 95, "end_pos": 101, "type": "METRIC", "confidence": 0.9961280822753906}, {"text": "POS", "start_pos": 148, "end_pos": 151, "type": "METRIC", "confidence": 0.9936707019805908}, {"text": "accuracy", "start_pos": 159, "end_pos": 167, "type": "METRIC", "confidence": 0.9992407560348511}, {"text": "precision", "start_pos": 220, "end_pos": 229, "type": "METRIC", "confidence": 0.9993533492088318}, {"text": "recall", "start_pos": 235, "end_pos": 241, "type": "METRIC", "confidence": 0.9989547729492188}]}, {"text": " Table 4: Discontinuous parsing results on the test sets.  *  Neural scoring system.  \u2020 Does not discount root symbols  and punctuation.", "labels": [], "entities": []}, {"text": " Table 7: Detailed results. Overall, the positive effect of the dynamic oracle on F-score is explained by its effect on  precision.", "labels": [], "entities": [{"text": "F-score", "start_pos": 82, "end_pos": 89, "type": "METRIC", "confidence": 0.9798018932342529}, {"text": "precision", "start_pos": 121, "end_pos": 130, "type": "METRIC", "confidence": 0.9993807077407837}]}]}