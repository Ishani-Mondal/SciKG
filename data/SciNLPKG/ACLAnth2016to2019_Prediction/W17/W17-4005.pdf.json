{"title": [], "abstractContent": [{"text": "We sketch an approach to encode relations of arbitrary arity as simple languages.", "labels": [], "entities": []}, {"text": "Our main focus will be faithful-ness of the encoding: we prove that with normal finite-state methods, it is impossible to properly encode the full class of rational (i.e. transducer recognizable) relations ; however, there is a simple encoding for the synchronous rational relations.", "labels": [], "entities": []}, {"text": "We present this encoding and show how standard finite-state methods can be used with this encoding, that is, arbitrary operations on relations can be encoded as operations on the code.", "labels": [], "entities": []}, {"text": "Finally we sketch an implementation using an existing library (FOMA).", "labels": [], "entities": [{"text": "FOMA", "start_pos": 63, "end_pos": 67, "type": "METRIC", "confidence": 0.8136633038520813}]}], "introductionContent": [{"text": "There is no need to list the merits and advantages of finite-state methods.", "labels": [], "entities": []}, {"text": "However, there are some drawbacks, which are partly due to intrinsic properties of rational (i.e. transducer recognizable) relations in general, partly due to restrictions in current libraries: 1.", "labels": [], "entities": []}, {"text": "In general, the rational relations are not closed under intersection and complement.", "labels": [], "entities": []}, {"text": "Some libraries offer an approximate version of intersection, but this is not guaranteed to provide accurate results.", "labels": [], "entities": [{"text": "intersection", "start_pos": 47, "end_pos": 59, "type": "TASK", "confidence": 0.9300406575202942}]}, {"text": "2. The question whether given two transducers, the relation recognized by one is a subset of (or equal to) the other is generally undecidable.", "labels": [], "entities": []}, {"text": "3. Standard libraries only support binary relations; we will in fact prove there is noway to faithfully (we will make this precise below) encode rational relations (binary or more than binary) as regular languages by finite-state means.", "labels": [], "entities": []}, {"text": "The goal of this article is to solve all these problems with one step: restrict our attention to synchronous rational relations.", "labels": [], "entities": []}, {"text": "because this class actually forms a Boolean algebra; it follows that 2. is also solved, as this way, it is easy to decide the inclusion/equivalence problem.", "labels": [], "entities": []}, {"text": "We can also solve problem 3., because we can faithfully encode arbitrary n-ary synchronous relations as simple languages.", "labels": [], "entities": []}, {"text": "This encoding preserves recognizability (by finite-state automata) and allows to faithfully encode standard operations on relations via (different) standard operations on the code (we will define and explain this in more detail below).", "labels": [], "entities": []}, {"text": "As the only drawback, we have to renounce to the additional expressive power of rational relations over synchronous relations; but as it was argued in, there might belittle actual need for this in linguistic applications.", "labels": [], "entities": []}, {"text": "While from a theoretical point of view, we think there is little to object to our approach, there are large practical obstacles: firstly, synchronous relations are not as comfortable to specify as rational relations: for the latter, the representation of rational expressions is particularly practical and compelling (it is used i.e. by FOMA/XFST).", "labels": [], "entities": [{"text": "FOMA/XFST", "start_pos": 337, "end_pos": 346, "type": "DATASET", "confidence": 0.8088634808858236}]}, {"text": "We solve this problem hereby defining a subclass of rational expressions which allows us to represent all and only synchronous relations, and we provide a program checking whether an expression is in this class.", "labels": [], "entities": []}, {"text": "Secondly, we do not want to build anew program or library from scratch, but rather stick to existing ones.", "labels": [], "entities": []}, {"text": "Therefore, we implement an interface which allows to define arbitrary n-ary synchronous relations, which are then encoded as languages and can be passed onto FOMA, a standard automaton library (see).", "labels": [], "entities": [{"text": "FOMA", "start_pos": 158, "end_pos": 162, "type": "DATASET", "confidence": 0.9045826196670532}]}, {"text": "We have to add, 41 however, that the implementation is still work in progress.", "labels": [], "entities": []}, {"text": "Hence we show that we can make use of synchronous relations in finite-state processing without really big obstacles, and this solves the three problems we mentioned above.", "labels": [], "entities": []}, {"text": "The paper is structured as follows: next, we layout the motivations we have sketched here more explicitly.", "labels": [], "entities": []}, {"text": "Then we provide the basic definitions of classes of relations and operations on them.", "labels": [], "entities": []}, {"text": "Then we sketch our approach and procedure to solve the problems.", "labels": [], "entities": []}, {"text": "Finally, we discuss the implementation.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": []}