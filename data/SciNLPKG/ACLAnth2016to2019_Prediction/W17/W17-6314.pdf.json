{"title": [{"text": "Arc-Hybrid Non-Projective Dependency Parsing with a Static-Dynamic Oracle", "labels": [], "entities": [{"text": "Arc-Hybrid Non-Projective Dependency Parsing", "start_pos": 0, "end_pos": 44, "type": "TASK", "confidence": 0.4087761342525482}]}], "abstractContent": [{"text": "We extend the arc-hybrid transition system for dependency parsing with a SWAP transition that enables reordering of the words and construction of non-projective trees.", "labels": [], "entities": [{"text": "dependency parsing", "start_pos": 47, "end_pos": 65, "type": "TASK", "confidence": 0.828795999288559}]}, {"text": "Although this extension potentially breaks the arc-decomposability of the transition system, we show that the existing dynamic oracle can be modified and combined with a static oracle for the SWAP transition.", "labels": [], "entities": [{"text": "SWAP transition", "start_pos": 192, "end_pos": 207, "type": "TASK", "confidence": 0.7188355326652527}]}, {"text": "Experiments on five languages with different degrees of non-projectivity show that the new system gives competitive accuracy and is significantly better than a system trained with a purely static oracle.", "labels": [], "entities": [{"text": "accuracy", "start_pos": 116, "end_pos": 124, "type": "METRIC", "confidence": 0.9899195432662964}]}], "introductionContent": [{"text": "Non-projective sentences area notorious problem in dependency parsing.", "labels": [], "entities": [{"text": "dependency parsing", "start_pos": 51, "end_pos": 69, "type": "TASK", "confidence": 0.8288054466247559}]}, {"text": "Traditional algorithms like those developed by) for transition-based parsing only allow the construction of projective trees.", "labels": [], "entities": [{"text": "transition-based parsing", "start_pos": 52, "end_pos": 76, "type": "TASK", "confidence": 0.5274671912193298}]}, {"text": "These algorithms make use of a stack, a buffer and a set of arcs, and parsing consists of performing a sequence of transitions on these structures.", "labels": [], "entities": []}, {"text": "Traditional algorithms have been extended in different ways to allow the construction of non-projective trees.", "labels": [], "entities": []}, {"text": "One method proposed by is based on the idea of word reordering.", "labels": [], "entities": [{"text": "word reordering", "start_pos": 47, "end_pos": 62, "type": "TASK", "confidence": 0.7543483376502991}]}, {"text": "This is achieved by adding a transition that swaps two items in the data structures used, enabling the construction of arbitrary non-projective trees while still only adding arcs between adjacent words (after possible reordering).", "labels": [], "entities": []}, {"text": "This technique was previously used in the arc-standard transition system).", "labels": [], "entities": []}, {"text": "The first contribution of this paper is to show that it can also be combined with the arc-hybrid system proposed by.", "labels": [], "entities": []}, {"text": "Recent advances in dependency parsing have demonstrated the benefit of using dynamic oracles for training dependency parsers.", "labels": [], "entities": [{"text": "dependency parsing", "start_pos": 19, "end_pos": 37, "type": "TASK", "confidence": 0.8630904853343964}]}, {"text": "Traditionally, parsers were trained in a static way and were only exposed to configurations resulting from optimal transitions during training.", "labels": [], "entities": []}, {"text": "Dynamic oracles define optimal transition sequences for any configuration in which the parser maybe.", "labels": [], "entities": []}, {"text": "The use of dynamic oracles enables training with exploration of errors, which mitigates the problem of error propagation at prediction time.", "labels": [], "entities": [{"text": "error propagation", "start_pos": 103, "end_pos": 120, "type": "TASK", "confidence": 0.7201606631278992}]}, {"text": "In order to define a dynamic oracle, we need to be able to compute the cost of any transition in any configuration, where cost is usually defined as minimum Hamming loss with respect to the best tree reachable from that configuration.", "labels": [], "entities": []}, {"text": "showed that this computation is straightforward for transition systems that satisfy the property of arc-decomposability, meaning that a tree is reachable from a configuration if and only if every arc in the tree is reachable in itself.", "labels": [], "entities": []}, {"text": "Based on this result, they defined dynamic oracles for the arc-eager, arc-hybrid () and easy-first () systems.", "labels": [], "entities": []}, {"text": "Transition systems that allow non-projective trees are in general not arc-decomposable and therefore require different methods for constructing dynamic oracles).", "labels": [], "entities": []}, {"text": "The online reordering system of Nivre is furthermore based on the arc-standard system, which is not even arc-decomposable in itself (.", "labels": [], "entities": [{"text": "Nivre", "start_pos": 32, "end_pos": 37, "type": "DATASET", "confidence": 0.821502685546875}]}, {"text": "The second contribution of this paper is to show that we can take advantage of the arcdecomposability of the arc-hybrid transition system and extend the existing dynamic oracle to deal with the added swap transition.", "labels": [], "entities": []}, {"text": "The resulting or-acle is static with respect to the new transition but remains dynamic for all other transitions.", "labels": [], "entities": []}, {"text": "We show experimentally that this static-dynamic oracle gives a significant advantage over the alternative static oracle and results in competitive results for non-projective parsing.", "labels": [], "entities": []}], "datasetContent": [{"text": "We extend the parser we used in de, a greedy transition-based parser that predicts the dependency tree given the raw words of a sentence.", "labels": [], "entities": []}, {"text": "That parser is itself an extension of the parser developed by.", "labels": [], "entities": []}, {"text": "It relies on a BiLSTM to learn informative features of words in context and a feed-forward network for predicting the next parsing transition.", "labels": [], "entities": [{"text": "predicting the next parsing transition", "start_pos": 103, "end_pos": 141, "type": "TASK", "confidence": 0.6889225304126739}]}, {"text": "It learns vector representations of the words as well as characters.", "labels": [], "entities": []}, {"text": "Contrary to parsing tradition, it makes no use of part-of-speech tags.", "labels": [], "entities": []}, {"text": "We released our system as UUparser 2.0, available at https: //github.com/UppsalaNLP/uuparser.", "labels": [], "entities": []}, {"text": "We first compare our system, which uses our static-dynamic oracle, with the same system using a static oracle.", "labels": [], "entities": []}, {"text": "This is to find out if we can benefit from error exploration using our partially dynamic oracle.", "labels": [], "entities": [{"text": "error exploration", "start_pos": 43, "end_pos": 60, "type": "TASK", "confidence": 0.6858470290899277}]}, {"text": "We use the same set of hyperparameters as in that paper in all our experiments.", "labels": [], "entities": []}, {"text": "We additionally compare our method to a different approach to handling non-projectivity, pseudo-projective parsing, as performed in de.", "labels": [], "entities": []}, {"text": "Pseudo-projective parsing was developed by.", "labels": [], "entities": []}, {"text": "Ina pre-processing step, the training data is projectivised: some nodes get reattached to a close parent.", "labels": [], "entities": []}, {"text": "Parsed data are then 'deprojectivised' in a post-processing step.", "labels": [], "entities": []}, {"text": "In order for information about non-projectivity to be recoverable after parsing, when projectivising, arcs are renamed to encode information about the original parent of dependents which get re-attached.", "labels": [], "entities": []}, {"text": "Note that hyperparameters were tweaked for the pseudo-projective system, possibly giving an unfair advantage.", "labels": [], "entities": []}, {"text": "Lastly, we compare to a projective baseline, using a dynamic oracle but no SWAP transition.", "labels": [], "entities": []}, {"text": "6 This is to find out the extent to which dealing with non-projectivity is important.", "labels": [], "entities": []}, {"text": "We selected a sample of 5 treebanks from the Universal Dependencies CoNLL 2017 shared task data ( . We selected languages to have different frequencies of non-projectivity, both at the sentence level and at the level of individual arcs, ranging from a very high frequency (Ancient-Greek) to a low frequency (English), as well as some typological variety.", "labels": [], "entities": [{"text": "Universal Dependencies CoNLL 2017 shared task data", "start_pos": 45, "end_pos": 95, "type": "DATASET", "confidence": 0.8575463891029358}]}, {"text": "Non-projective frequencies were taken from and are included in, which report our results on the development sets (best out of 20 epochs).", "labels": [], "entities": []}, {"text": "Comparing to the static baseline, we can verify that our static-dynamic oracle really preserves the benefits of training with error exploration, with improvements ranging from 0.5 to 3.5 points.", "labels": [], "entities": [{"text": "error exploration", "start_pos": 126, "end_pos": 143, "type": "TASK", "confidence": 0.6715738624334335}]}, {"text": "(All differences here are statistically significant with p<0.01, except for Portuguese, where the difference is statistically significant with p<0.05 according to the McNemar test).", "labels": [], "entities": [{"text": "McNemar test", "start_pos": 167, "end_pos": 179, "type": "DATASET", "confidence": 0.7426919639110565}]}, {"text": "The new system achieves results largely on par with the pseudo-projective parser.", "labels": [], "entities": []}, {"text": "Our method is better by a small margin for 3 out of 5 languages: LAS on dev sets with gold tokenization for our static-dynamic system (S-Dy), the static and projective baselines (Static, Proj) and the pseudo-projective system of de.", "labels": [], "entities": [{"text": "LAS", "start_pos": 65, "end_pos": 68, "type": "METRIC", "confidence": 0.9443073272705078}]}, {"text": "%NP = percentage of nonprojective arcs/sentences. and worse by a large margin for 1.", "labels": [], "entities": [{"text": "NP", "start_pos": 1, "end_pos": 3, "type": "METRIC", "confidence": 0.9886372685432434}]}, {"text": "Overall, these results are encouraging given that our method is simpler and more efficient to train, with no need for pre-or post-processing and no extension of the dependency label set.", "labels": [], "entities": []}, {"text": "Comparing to the projective baseline, we see that strictly projective parsing can be slightly better than both online reordering and pseudoprojective parsing fora language with few non-projective arcs/sentences like English.", "labels": [], "entities": []}, {"text": "For all other languages, we see small (Arabic) to big (Ancient Greek) improvements from dealing with non-projectivity in someway.", "labels": [], "entities": []}], "tableCaptions": [{"text": " Table 1: LAS on dev sets with gold tokeniza- tion for our static-dynamic system (S-Dy), the  static and projective baselines (Static, Proj) and  the pseudo-projective system of de", "labels": [], "entities": [{"text": "LAS", "start_pos": 10, "end_pos": 13, "type": "METRIC", "confidence": 0.7967272400856018}]}]}