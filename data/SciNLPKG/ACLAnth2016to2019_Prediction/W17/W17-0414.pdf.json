{"title": [{"text": "From Universal Dependencies to Abstract Syntax", "labels": [], "entities": []}], "abstractContent": [{"text": "syntax is a tectogrammatical tree representation, which can be shared between languages.", "labels": [], "entities": []}, {"text": "It is used for programming languages in compilers, and has been adapted to natural languages in GF (Gram-matical Framework).", "labels": [], "entities": []}, {"text": "Recent work has shown how GF trees can be converted to UD trees, making it possible to generate parallel synthetic treebanks for those 30 languages that are currently covered by GF.", "labels": [], "entities": []}, {"text": "This paper attempts to invert the mapping: take UD trees from standard tree-banks and reconstruct GF trees from them.", "labels": [], "entities": []}, {"text": "Such a conversion is potentially useful in bootstrapping treebanks by translation.", "labels": [], "entities": []}, {"text": "It can also help GF-based interlingual translation by providing a robust, efficient front end.", "labels": [], "entities": [{"text": "GF-based interlingual translation", "start_pos": 17, "end_pos": 50, "type": "TASK", "confidence": 0.749933511018753}]}, {"text": "However, since UD trees are based on natural (as opposed to generated) data and built manually or by machine learning (as opposed to rules), the conversion is not trivial.", "labels": [], "entities": []}, {"text": "This paper will present a basic algorithm, which is essentially based on inverting the GF to UD conversion.", "labels": [], "entities": []}, {"text": "This method enables covering around 70% of nodes, and the rest can be covered by ap-proximative backup strategies.", "labels": [], "entities": []}, {"text": "Analysing the reasons of the incompleteness reveals structures missing in GF grammars, but also some problems in UD treebanks.", "labels": [], "entities": []}], "introductionContent": [{"text": "GF) is a formalism for multilingual grammars.", "labels": [], "entities": []}, {"text": "Similarly to UD (Universal Dependencies, (), GF uses shared syntactic descriptions for multiple languages.", "labels": [], "entities": []}, {"text": "In GF, this is achieved by using abstract syntax trees, similar to the internal representations used in compilers and to Curry's tectogrammatical formulas.", "labels": [], "entities": []}, {"text": "Given an abstract syntax tree, strings in different languages can be derived mechanically by linearization functions written for that language, similar to pretty-printing rules in compilers and to Curry's phenogrammatical rules.", "labels": [], "entities": []}, {"text": "The linearization functions of GF are by design reversible to parsers, which convert strings to abstract syntax trees.", "labels": [], "entities": []}, {"text": "gives a very brief summary of GF to readers unfamiliar with GF.", "labels": [], "entities": [{"text": "GF", "start_pos": 30, "end_pos": 32, "type": "TASK", "confidence": 0.520942211151123}, {"text": "GF", "start_pos": 60, "end_pos": 62, "type": "DATASET", "confidence": 0.7847604155540466}]}, {"text": "In UD, the shared descriptions are dependency labels and part of speech tags used in dependency trees.", "labels": [], "entities": []}, {"text": "The words in the leaves of UD trees are language-specific, and languages can extend the core tagset and labels to annotate constructions in the language.", "labels": [], "entities": []}, {"text": "The relation between trees and strings is not defined by grammar rules, but by constructing a set of example trees-a treebank.", "labels": [], "entities": []}, {"text": "From a treebank, a parser is typically constructed by machine learning).", "labels": [], "entities": []}, {"text": "There is no mechanical way to translate a UD tree from one language to other languages.", "labels": [], "entities": []}, {"text": "But such a translation can be approximated in different ways to bootstrap treebanks (.", "labels": [], "entities": []}, {"text": "GF's linearization can convert abstract syntax trees to UD trees (.", "labels": [], "entities": []}, {"text": "This conversion can be used for generating multilingual (and parallel) treebanks from a given set of GF trees.", "labels": [], "entities": []}, {"text": "However, to reach the full potential of the GF-UD correspondence, it would also be useful to go to the opposite direction, to convert UD trees to GF trees.", "labels": [], "entities": []}, {"text": "Then one could translate standard UD treebanks to new languages.", "labels": [], "entities": [{"text": "UD treebanks", "start_pos": 34, "end_pos": 46, "type": "DATASET", "confidence": 0.6519468277692795}]}, {"text": "One could also use dependency parsing as a robust frontend to a translator, which uses GF linearization as a grammaticality-preserving backend), or to a logical form generator in the style of), but where GF trees give an accurate intermediate representation in the style of).", "labels": [], "entities": [{"text": "dependency parsing", "start_pos": 19, "end_pos": 37, "type": "TASK", "confidence": 0.7965854108333588}]}, {"text": "shows both of these scenarios, using the term gf2ud for the con-The abstract syntax defines a set of categories, such as CN (Common Noun) and AP (Adjectival Phrase), and a set of functions, such as ModCN (modification of CN with AP): cat CN ; AP fun ModCN : AP -> CN -> CN A concrete syntax defines, for each category, a linearization type, and for each function, a linearization function; these can make use of parameters.", "labels": [], "entities": []}, {"text": "For English, we need a parameter type Number (singular or plural).", "labels": [], "entities": []}, {"text": "We define CN as a table (similar to an inflection table), which produces a string as a function Number.", "labels": [], "entities": []}, {"text": "As AP is not inflected, it is just a string.", "labels": [], "entities": []}, {"text": "Adjectival modification places the AP before the CN, passing the number to the CN head of the construction: Context-free grammars correspond to a special case of GF where Str is the only linearization type.", "labels": [], "entities": []}, {"text": "The use of tables (P=>T) and records ({a : A ; b : B}) makes GF more expressive than context-free grammars.", "labels": [], "entities": []}, {"text": "The distinction between dependent and inherent features, as well as the restriction of tables to finite parameter types, makes GF less expressive than unification grammars.", "labels": [], "entities": []}, {"text": "Formally, GF is equivalent to PMCFG (Parallel Multiple Context-Free Grammars) (, as shown in, and has polynomial parsing complexity.", "labels": [], "entities": []}, {"text": "The power of PMCFG has shown to be what is needed to share an abstract syntax across languages.", "labels": [], "entities": [{"text": "PMCFG", "start_pos": 13, "end_pos": 18, "type": "DATASET", "confidence": 0.7599332928657532}]}, {"text": "In addition to morphological variation and agreement, it permits discontinuous constituents (used heavily e.g. in German) and reduplication (used e.g. in Chinese questions).", "labels": [], "entities": []}, {"text": "The GF Resource Grammar Library uses a shared abstract syntax for currently 32 languages (IndoEuropean, Fenno-Ugric, Semitic and East Asian) written by over 50 contributors.", "labels": [], "entities": [{"text": "GF Resource Grammar Library", "start_pos": 4, "end_pos": 31, "type": "DATASET", "confidence": 0.9428421407938004}]}, {"text": "Software, grammars, and documentation are available in http://www.grammaticalframework.org: GF in a nutshell.", "labels": [], "entities": []}, {"text": "The text works out a simple GF grammar of adjectival modification in English and French, showing how the structure can be shared despite differences in word order and agreement.", "labels": [], "entities": [{"text": "adjectival modification", "start_pos": 42, "end_pos": 65, "type": "TASK", "confidence": 0.7469855844974518}]}, {"text": "version of and ud2gf for the inverse procedure, which is the topic of this paper.", "labels": [], "entities": []}, {"text": "GF was originally designed for multilingual generation in controlled language scenarios, not for wide-coverage parsing.", "labels": [], "entities": [{"text": "wide-coverage parsing", "start_pos": 97, "end_pos": 118, "type": "TASK", "confidence": 0.6108872890472412}]}, {"text": "The GF Resource Grammar Library (Ranta, 2009) thus does not cover everything in all languages, but just a \"semantically complete subset\", in the sense that it provides ways to express all kinds of content, but not necessarily all possible ways to express it.", "labels": [], "entities": [{"text": "GF Resource Grammar Library (Ranta, 2009)", "start_pos": 4, "end_pos": 45, "type": "DATASET", "confidence": 0.9224129650327895}]}, {"text": "It is has therefore been interesting to see how much of the syntax in UD treebanks is actually covered, to assess the completeness of the library.", "labels": [], "entities": [{"text": "UD treebanks", "start_pos": 70, "end_pos": 82, "type": "DATASET", "confidence": 0.9014957845211029}]}, {"text": "In the other direction, some of the difficulties in ud2gf mapping suggest that UD does not always annotate syntax in the most logical way, or in away that is maximally general across languages.", "labels": [], "entities": []}, {"text": "The work reported in this paper is the current status of work in progress.", "labels": [], "entities": []}, {"text": "Therefore the results are not conclusive: in particular, we expect to improve the missing coverage in a straightforward way.", "labels": [], "entities": [{"text": "coverage", "start_pos": 90, "end_pos": 98, "type": "METRIC", "confidence": 0.9340699911117554}]}, {"text": "The most stable part of the work is the annotation algorithm described in Sections 3 an 4.", "labels": [], "entities": []}, {"text": "It is based on a general notation for dependency configurations, which can be applied to any GF grammar and to any dependency annotation schemenot only to the UD scheme.", "labels": [], "entities": []}, {"text": "The code for the algorithm and the annotations used in experiments is available open source.", "labels": [], "entities": []}, {"text": "The structure of the paper is as follows: Section 2 summarizes the existing gf2ud conversion and formulates the problem of inverting it.", "labels": [], "entities": []}, {"text": "Section 3 describes a baseline bottom-up algorithm for translation from UD trees to GF trees.", "labels": [], "entities": []}, {"text": "Section 4 presents some refinements to the basic algorithm.", "labels": [], "entities": []}, {"text": "Section 5 shows a preliminary evaluation with UD treebanks for English, Finnish, and Swedish.", "labels": [], "entities": [{"text": "UD treebanks", "start_pos": 46, "end_pos": 58, "type": "DATASET", "confidence": 0.7306783348321915}]}], "datasetContent": [], "tableCaptions": [{"text": " Table 1: Coverage of nodes in each test set  (L-ud-test.conllu). L* (Swedish*, Finnish*)  is with language-independent configurations only.  #conf's is the number of language-specific config- urations. %cov'd and %int'd are the percentages  of covered and interpreted nodes, respectively.", "labels": [], "entities": []}]}