{"title": [{"text": "Evaluating an Automata Approach to Query Containment", "labels": [], "entities": [{"text": "Query Containment", "start_pos": 35, "end_pos": 52, "type": "TASK", "confidence": 0.7374871373176575}]}], "abstractContent": [{"text": "Given two queries Q super and Q sub , query containment is the problem of determining if Q sub (D) \u2286 Q super (D) for all databases D.", "labels": [], "entities": [{"text": "query containment", "start_pos": 38, "end_pos": 55, "type": "TASK", "confidence": 0.8160882890224457}]}, {"text": "This problem has long been explored, but to our knowledge no one has empirically evaluated a straightforward application of finite state automata to the problem.", "labels": [], "entities": []}, {"text": "We do so here, covering the case of conjunctive queries with limited set conditions.", "labels": [], "entities": []}, {"text": "We evaluate an implementation of our approach against straightforward implementations of both the canon-ical database and theorem proving approaches.", "labels": [], "entities": [{"text": "theorem proving", "start_pos": 122, "end_pos": 137, "type": "TASK", "confidence": 0.8930692672729492}]}, {"text": "Our implementation outper-forms theorem proving on a natural language interface corpus over a photo/video domain.", "labels": [], "entities": []}, {"text": "It also outperforms the canoni-cal database implementation on single relation queries with large set conditions.", "labels": [], "entities": []}], "introductionContent": [{"text": "Given the queries Q super and Q sub , query containment is the problem of determining if Q sub (D) \u2286 Q super (D) for all databases D.", "labels": [], "entities": [{"text": "query containment", "start_pos": 38, "end_pos": 55, "type": "TASK", "confidence": 0.8238453567028046}]}, {"text": "Not only interesting in itself, the problem is of practical importance in query optimization, data integration) and, of note here, in natural language generation, dialogue) and understanding.", "labels": [], "entities": [{"text": "query optimization", "start_pos": 74, "end_pos": 92, "type": "TASK", "confidence": 0.7507169544696808}, {"text": "data integration", "start_pos": 94, "end_pos": 110, "type": "TASK", "confidence": 0.7656468152999878}, {"text": "natural language generation", "start_pos": 134, "end_pos": 161, "type": "TASK", "confidence": 0.6754763722419739}]}, {"text": "Over time, increasingly complex cases of the problem have been solved: relational conjunctive queries; conjunctive queries with arithmetic comparisons over dense domains; negation of subgoals ().", "labels": [], "entities": []}, {"text": "More recent work 1 has looked The problem has also been addressed in semi-structured query languages () and in description logics (.", "labels": [], "entities": []}, {"text": "Still the focus here is on query containment for relational databases.", "labels": [], "entities": [{"text": "query containment", "start_pos": 27, "end_pos": 44, "type": "TASK", "confidence": 0.8294442296028137}]}, {"text": "at the problem for queries with aggregate operators (see the survey).", "labels": [], "entities": []}, {"text": "Remarkably, the decidability of the problem remains open for queries under bag semantics (.", "labels": [], "entities": []}, {"text": "A typical approach to solving query containment is to generate a canonical database D that represents Q sub and then to evaluate Q super.", "labels": [], "entities": [{"text": "solving query containment", "start_pos": 22, "end_pos": 47, "type": "TASK", "confidence": 0.6923471788565317}]}, {"text": "If the answer to Q sub within Dis within Q super (D ), then Q super contains Q sub (see).", "labels": [], "entities": []}, {"text": "Another approach to solve the problem is via theorem proving.", "labels": [], "entities": [{"text": "theorem proving", "start_pos": 45, "end_pos": 60, "type": "TASK", "confidence": 0.9124130606651306}]}, {"text": "Here we present, implement, and empirically evaluate such an approach.", "labels": [], "entities": []}, {"text": "We compare performance against a canonical database and theorem proving implementation over a photo/video querying corpus.", "labels": [], "entities": []}, {"text": "We also conduct several special scalability tests for queries with many predicates over the same relation and queries with large set conditions over a single relation.", "labels": [], "entities": []}], "datasetContent": [{"text": "Our approach (FSA) is implemented in Python and for most of its automata routines it uses PADS, a library of Python Algorithms and Data Structures implemented by David Eppstein of the University of California, Irvine.", "labels": [], "entities": []}, {"text": "Although not described above, we extended FSA to handle limited set conditions.", "labels": [], "entities": [{"text": "FSA", "start_pos": 42, "end_pos": 45, "type": "TASK", "confidence": 0.4493319094181061}]}, {"text": "The current set conditions supported are set conditions on non-joining attributes over relations that appear in only one predicate of a query.", "labels": [], "entities": []}, {"text": "We have also implemented Python versions of the canonical database (CDB) and the theorem proving (TP) approaches.", "labels": [], "entities": [{"text": "theorem proving (TP)", "start_pos": 81, "end_pos": 101, "type": "TASK", "confidence": 0.8128983378410339}]}, {"text": "The database system used in CDB is SQLITE running in main memory; performance deteriorates by several orders of magnitude if the database must be written to disk.", "labels": [], "entities": []}, {"text": "Our CDB implementation is extended to set con-", "labels": [], "entities": []}], "tableCaptions": [{"text": " Table 1: Results over photo/video corpus (ms)", "labels": [], "entities": []}, {"text": " Table 2: Results for special cases (ms)", "labels": [], "entities": []}]}