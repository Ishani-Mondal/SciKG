{"title": [], "abstractContent": [{"text": "This paper presents an end-to-end neural network model, named Neural Generative Question Answering (GENQA), that can generate answers to simple factoid questions, based on the facts in a knowledge-base.", "labels": [], "entities": [{"text": "Neural Generative Question Answering (GENQA)", "start_pos": 62, "end_pos": 106, "type": "TASK", "confidence": 0.7636827741350446}]}, {"text": "More specifically , the model is built on the encoder-decoder framework for sequence-to-sequence learning, while equipped with the ability to enquire the knowledge-base, and is trained on a corpus of question-answer pairs, with their associated triples in the knowledge-base.", "labels": [], "entities": []}, {"text": "Empirical study shows the proposed model can effectively deal with the variations of questions and answers, and generate right and natural answers by referring to the facts in the knowledge-base.", "labels": [], "entities": []}, {"text": "The experiment on question answering demonstrates that the proposed model can outperform an embedding-based QA model as well as a neural dialogue model trained on the same data.", "labels": [], "entities": [{"text": "question answering", "start_pos": 18, "end_pos": 36, "type": "TASK", "confidence": 0.8753548860549927}]}], "introductionContent": [{"text": "Question answering (QA) can be viewed as a special case of single-turn dialogue: QA aims at providing correct answers to the questions in natural language, while dialogue emphasizes on generating relevant and fluent responses to the messages also in natural language (.", "labels": [], "entities": [{"text": "Question answering (QA)", "start_pos": 0, "end_pos": 23, "type": "TASK", "confidence": 0.9305047154426574}]}, {"text": "Recent progress in deep learning has raised the possibility of realizing generation-based QA in a purely neutralized way.", "labels": [], "entities": []}, {"text": "That is, the answer is generated by a neural network (e.g., recurrent neural network, or * The work is done when the first author worked as intern at Noah's Ark Lab, Huawei Technologies.", "labels": [], "entities": []}, {"text": "RNN) based on the question, which is able to handle the flexibility and diversity of language.", "labels": [], "entities": []}, {"text": "More importantly, the model is trained in an end-to-end fashion, and thus there is no need in building the system using linguistic knowledge, e.g., creating a semantic parser.", "labels": [], "entities": []}, {"text": "There is however one serious limitation of this generation-based approach to QA.", "labels": [], "entities": [{"text": "QA", "start_pos": 77, "end_pos": 79, "type": "TASK", "confidence": 0.93992680311203}]}, {"text": "It is practically impossible to store all the knowledge in a neural network to achieve a desired precision and coverage in real world QA.", "labels": [], "entities": [{"text": "precision", "start_pos": 97, "end_pos": 106, "type": "METRIC", "confidence": 0.9987782835960388}, {"text": "coverage", "start_pos": 111, "end_pos": 119, "type": "METRIC", "confidence": 0.9697293639183044}]}, {"text": "This is a fundamental difficulty, rooting deeply in the way in which knowledge is acquired, represented and stored.", "labels": [], "entities": []}, {"text": "The neural network, and more generally the fully distributed way of representation, is good at representing smooth and shared patterns, i.e., modeling the flexibility and diversity of language, but improper for representing discrete and isolated concepts, i.e., depicting the lexicon of language.", "labels": [], "entities": []}, {"text": "On the other hand, the recent success of memorybased neural network models has greatly extended the ways of storing and accessing text information, in both short-term memory (e.g., in () and long-term memory (e.g., in).", "labels": [], "entities": []}, {"text": "It is hence a natural choice to connect a neural model for QA with a neural model of knowledge-base on an external memory, which is also related to the traditional approach of templatebased QA from knowledge-base.", "labels": [], "entities": []}, {"text": "In this paper, we report our exploration in this direction, with a proposed model called Neural Generative Question Answering (GENQA).", "labels": [], "entities": [{"text": "Neural Generative Question Answering (GENQA)", "start_pos": 89, "end_pos": 133, "type": "TASK", "confidence": 0.7200624346733093}]}, {"text": "Learning Task: We formalize generative question answering (GENQA) as a supervised learning task or more specifically a sequence-to-sequence learning task.", "labels": [], "entities": [{"text": "generative question answering (GENQA)", "start_pos": 28, "end_pos": 65, "type": "TASK", "confidence": 0.8579312463601431}]}, {"text": "A GENQA system takes a sequence of words as input question and generates another sequence of words as answer.", "labels": [], "entities": []}, {"text": "In order to provide right answers, the system is connected with a knowledge-base (K-B), which contains facts.", "labels": [], "entities": []}, {"text": "During the process of answering, the system queries the KB, retrieves a set of candidate facts and generates a correct answer to the question using the right fact.", "labels": [], "entities": []}, {"text": "The generated answer may contain two types of \"words\": one is common words for composing the answer (referred to as common word) and the other is specialized words in the KB denoting the answer (referred to as KB-word).", "labels": [], "entities": []}, {"text": "To learn a GENQA model, we assume that each training instance consists of a question-answer pair with the KB-word specified in the answer.", "labels": [], "entities": []}, {"text": "In this paper, we only consider the case of simple factoid question, which means each question-answer pair is associated with a single fact (i.e., one triple) of the KB.", "labels": [], "entities": []}, {"text": "Without loss of generality, we mainly focus on forward relation QA, where the question is on subject and predicate and the answer points to object.", "labels": [], "entities": []}, {"text": "shows the statistics of the knowledge-base and QA-pairs.", "labels": [], "entities": []}, {"text": "We construct the training and test data for GEN-QA by \"grounding\" the QA pairs with the triples in knowledge-base.", "labels": [], "entities": [{"text": "GEN-QA", "start_pos": 44, "end_pos": 50, "type": "DATASET", "confidence": 0.8348453640937805}]}, {"text": "Specifically, for each QA pair, a list of candidate triples with the subject fields appearing in the question, is retrieved by using the Aho-Corasick string searching algorithm.", "labels": [], "entities": []}, {"text": "The triples in the candidate list are then judged by a series of rules for relevance to the QA pair.", "labels": [], "entities": []}, {"text": "The basic requirement for relevance is that the answer contains the object of the triple, which specifies the KB-word in the answer.", "labels": [], "entities": []}, {"text": "Besides, we use additional scoring and filtering rules, attempting to find out the triple that truly matches the QA pair, if there is any.", "labels": [], "entities": []}, {"text": "As the result of processing, 720K instances (tuples of question, answer, triple) are finally obtained with an estimated 80% of instances being truly positive.", "labels": [], "entities": []}, {"text": "The data are publicly available online . In order to test the generalization ability of the GENQA model, the data is randomly partitioned into training dataset and test dataset by using triple as the partition key.", "labels": [], "entities": []}, {"text": "In that way, all the questions in the test data are regarding to the unseen facts (triples) in the training data.", "labels": [], "entities": []}, {"text": "shows some statistics of the datasets.", "labels": [], "entities": []}, {"text": "By comparing the numbers of triples in, we can see that a large portion of facts in the knowledge-base are not present in the training and test data, which demonstrates the necessity for the model to generalize to unseen facts.", "labels": [], "entities": []}, {"text": "we propose an end-to-end neural network model for GENQA, which is illustrated in.", "labels": [], "entities": [{"text": "GENQA", "start_pos": 50, "end_pos": 55, "type": "DATASET", "confidence": 0.852012574672699}]}, {"text": "The GENQA model consists of Interpreter, Enquirer, Answerer, and an external knowledge-base.", "labels": [], "entities": []}, {"text": "Answerer further consists of Attention Model and Generator.", "labels": [], "entities": [{"text": "Answerer", "start_pos": 0, "end_pos": 8, "type": "TASK", "confidence": 0.8393332362174988}]}, {"text": "Basically, Interpreter transforms the natural language question Q into a representation HQ and saves it in the short-term memory.", "labels": [], "entities": []}, {"text": "Enquirer takes HQ as input to interact with the knowledgebase in the long-term memory, retrieves relevant facts (triples) from the knowledge-base, and summarizes the result in a vector r Q . The Answerer feeds on the question representation HQ (through the Attention Model) as well as the vector r Q and generates the answer with Generator.", "labels": [], "entities": []}, {"text": "We elaborate each component hereafter.", "labels": [], "entities": []}, {"text": "Interpreter: Given the question represented as word sequence Q = (x 1 , . .", "labels": [], "entities": []}, {"text": ", x T Q ), Interpreter encodes it to the array of vector representations.", "labels": [], "entities": []}, {"text": "In our implementation, we adopt a bi-directional RN-N as in ( , which processes the sequence in forward and reverse order by using two independent RNNs (here we use gated recurrent unit (GRU) ().", "labels": [], "entities": []}, {"text": "By concatenating the hidden states (denoted as (h 1 , \u00b7 \u00b7 \u00b7 , h T Q )), the embeddings of the words (denoted as (x 1 , \u00b7 \u00b7 \u00b7 , x T Q )), and the original one-hot representations of the words, we obtain an array  of vectors HQ = ( \u02dc h 1 , \u00b7 \u00b7 \u00b7 , \u02dc h T Q ), where\u02dchwhere\u02dc where\u02dch t = [h t ; x t ; x t ].", "labels": [], "entities": []}, {"text": "This array of vectors is saved in the short-term memory, allowing for further processing by Enquirer and Answerer for different purposes.", "labels": [], "entities": []}, {"text": "Enquirer: Enquirer \"fetches\" the relevant facts from the knowledge-base with Q and HQ (as illustrated by).", "labels": [], "entities": [{"text": "Q", "start_pos": 77, "end_pos": 78, "type": "METRIC", "confidence": 0.9362779855728149}, {"text": "HQ", "start_pos": 83, "end_pos": 85, "type": "METRIC", "confidence": 0.8681974411010742}]}, {"text": "Enquirer first performs termlevel matching to retrieve a list of relevant candidate triples, denoted as . K Q is the number of candidate triples, which is usually less than several hundreds in our data.", "labels": [], "entities": [{"text": "Enquirer", "start_pos": 0, "end_pos": 8, "type": "DATASET", "confidence": 0.9188700318336487}, {"text": "termlevel matching", "start_pos": 24, "end_pos": 42, "type": "TASK", "confidence": 0.750241756439209}]}, {"text": "This first round filtering, although fairly simple, is important in making the following step of differentiable operations (e.g., the weighting on the candidate set and the answer generation) and optimization feasible.", "labels": [], "entities": [{"text": "answer generation", "start_pos": 173, "end_pos": 190, "type": "TASK", "confidence": 0.6892170608043671}]}, {"text": "After obtaining T Q , the task reduces to evaluating the relevance of each candidate triple with the question in the embedded space().", "labels": [], "entities": []}, {"text": "More specifically Enquirer calculates the matching scores between the question and the K Q triples.", "labels": [], "entities": [{"text": "Enquirer", "start_pos": 18, "end_pos": 26, "type": "DATASET", "confidence": 0.8352054953575134}]}, {"text": "For question Q, the scores are represented in a K Qdimensional vector r Q where the k th element of r Q is defined as the probability where S(Q, \u03c4 k ) denotes the matching score between question Q and triple \u03c4 k . The probability in r Q will be further taken into the probabilistic model in Answerer for generating a particular answering sentence.", "labels": [], "entities": []}, {"text": "Since r Q is of modest size, after the filtering step, and differentiable with respect to its parameters, it can be effectively optimized by the supervision signal in recovering the original answers through back-propagation.", "labels": [], "entities": []}, {"text": "In this work, we provide two implementations for Enquirer to calculate the matching scores between question and triples.", "labels": [], "entities": [{"text": "Enquirer", "start_pos": 49, "end_pos": 57, "type": "DATASET", "confidence": 0.8769559264183044}]}, {"text": "Bilinear Model: The first implementation simply takes the average of the word embedding vectors in HQ as the representation of the question (with the result denoted as \u00af x Q ) . For each triple \u03c4 in the knowledge-base, it takes the mean of the embeddings of its subject and predicate as the representation of the triple (denoted as u \u03c4 ).", "labels": [], "entities": []}, {"text": "Then we define the matching score as where M is the matrix parameterizing the matching between the question and the triple.", "labels": [], "entities": []}, {"text": "CNN-based Matching Model: The second implementation employs the convolutional neural network (CNN) for modeling the matching score between question and triple, as in ( and.", "labels": [], "entities": []}, {"text": "Specifically, the question is fed to a convolutional layer followed by a maxpooling layer, and summarized as a fixed-length vector, denoted as\u02c6has\u02c6 as\u02c6h Q . Then\u02c6hThen\u02c6 Then\u02c6h Q and u \u03c4 (again as the mean of the embedding of the corresponding subject and predicate) are concatenated as input to a multilayer perceptron (MLP) to produce their matching scor\u00eascor\u00ea For this model the parameters consist of both the C-NN for question representation and the MLP for the final matching decision.", "labels": [], "entities": []}, {"text": "Answerer: Answerer uses an RNN to generate the answer sentence based on the information of question saved in the short-term memory (represented by HQ ) and the relevant knowledge retrieved from the long-term memory (indexed by r Q ), as illustrated in.", "labels": [], "entities": []}, {"text": "The probability of generating the answer sentence Y = (y 1 , y 2 , . .", "labels": [], "entities": []}, {"text": ", y T Y ) is defined as where \u03b8 represents the parameters in the GEN-QA model.", "labels": [], "entities": [{"text": "GEN-QA", "start_pos": 65, "end_pos": 71, "type": "DATASET", "confidence": 0.890559732913971}]}, {"text": "The conditional probability in the RNN model (with hidden state s 1 , \u00b7 \u00b7 \u00b7 , s T Y ) is specified by p(y t |y 1 , . .", "labels": [], "entities": []}, {"text": ", y t\u22121 , HQ , r Q ; \u03b8) = p(y t |y t\u22121 , st , HQ , r Q ; \u03b8).", "labels": [], "entities": []}, {"text": "In generating the t th wordy tin the answer sentence, the probability is given by the following mixture model which sums the contributions from the \"language\" part and the \"knowledge\" part, with the coefficient p(z t |s t ; \u03b8) being realized by a logistic regression model with st as input.", "labels": [], "entities": []}, {"text": "Here the latent variable z t indicates whether the t th word is generated from a common vocabulary (for z t = 0) or a KB vocabulary (z t = 1).", "labels": [], "entities": []}, {"text": "In this work, the KB vocabulary contains all the objects of the candidate triples associated with the particular question.", "labels": [], "entities": []}, {"text": "For any wordy that is only in the KB vocabulary, e.g., \"2.29m\", we have p(y t |y t\u22121 , st , HQ , z t = 0; \u03b8) = 0, while for y that does not appear in KB, e.g., \"and\", we have p(y t |r Q , z t = 1; \u03b8) = 0.", "labels": [], "entities": []}, {"text": "There are some words (e.g., \"Shanghai\") that appear in both common vocabulary and KB vocabulary, for which the probability contains nontrivial contributions of both bodies.", "labels": [], "entities": [{"text": "Shanghai", "start_pos": 29, "end_pos": 37, "type": "DATASET", "confidence": 0.9067538976669312}]}, {"text": "In generating common words, Answerer acts in the same way as the decoder RNN in ( ) with information from HQ selected by the attention model.", "labels": [], "entities": []}, {"text": "Training: The parameters to be learned include the weights in the RNNs for Interpreter and Answerer, parameters in Enquirer, and the wordembeddings which are shared by the Interpreter RN-N and the knowledge-base.", "labels": [], "entities": [{"text": "Enquirer", "start_pos": 115, "end_pos": 123, "type": "DATASET", "confidence": 0.8808972835540771}]}, {"text": "GENQA, although essentially containing a retrieval operation, can be trained in an end-to-end fashion by maximizing the likelihood of observed data, since the mixture form of probability in Answerer provides a unified way to generate words from common vocabulary and (dynamic) KB vocabulary.", "labels": [], "entities": [{"text": "GENQA", "start_pos": 0, "end_pos": 5, "type": "DATASET", "confidence": 0.8215335607528687}]}, {"text": "In practice the model is trained on machines with GPUs by using stochastic gradient-descent with mini-batch.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": [{"text": " Table 2: Statistics of the QA data and the knowledge-base.", "labels": [], "entities": [{"text": "QA data", "start_pos": 28, "end_pos": 35, "type": "DATASET", "confidence": 0.8239901661872864}]}, {"text": " Table 3: Statistics of the training and test dataset for GENQA", "labels": [], "entities": [{"text": "GENQA", "start_pos": 58, "end_pos": 63, "type": "DATASET", "confidence": 0.7896303534507751}]}]}