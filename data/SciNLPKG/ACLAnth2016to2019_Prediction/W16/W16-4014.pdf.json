{"title": [{"text": "Implementation of a Workflow Management System for Non-Expert Users", "labels": [], "entities": [{"text": "Implementation", "start_pos": 0, "end_pos": 14, "type": "TASK", "confidence": 0.9609785676002502}]}], "abstractContent": [{"text": "In the Danish CLARIN-DK infrastructure, chaining language technology (LT) tools into a work-flow is easy even fora non-expert user, because she only needs to specify the input and the desired output of the workflow.", "labels": [], "entities": [{"text": "chaining language technology (LT)", "start_pos": 40, "end_pos": 73, "type": "TASK", "confidence": 0.8127928773562113}]}, {"text": "With this information and the registered input and output profiles of the available tools, the CLARIN-DK workflow management system (WMS) computes combinations of tools that will give the desired result.", "labels": [], "entities": []}, {"text": "This advanced functionality was originally not envisaged, but came within reach by writing the WMS partly in Java and partly in a programming language for symbolic computation, Bracmat.", "labels": [], "entities": []}, {"text": "Handling LT tool profiles, including the computation of workflows, is easier with Bracmat's language constructs for tree pattern matching and tree construction than with the language constructs offered by mainstream programming languages.", "labels": [], "entities": [{"text": "tree pattern matching", "start_pos": 116, "end_pos": 137, "type": "TASK", "confidence": 0.6679024895032247}, {"text": "tree construction", "start_pos": 142, "end_pos": 159, "type": "TASK", "confidence": 0.7564756870269775}]}], "introductionContent": [{"text": "The CLARIN-DK infrastructure 1 has a workflow management system (WMS) that transforms, annotates and analyses the user's input.", "labels": [], "entities": []}, {"text": "The WMS combines tools, deployed as web services, in just such away that output is produced of the type that the user asked for, or it tells the user that such output cannot be made given the input and the available tools.", "labels": [], "entities": []}, {"text": "The user is not required to be acquainted with the tools.", "labels": [], "entities": []}, {"text": "In principle, neither do providers of new tools need to know which tools are registered.", "labels": [], "entities": []}, {"text": "The currently registered tools are language technology (LT) tools (e.g., OCR, lemmatisation, syntactic analysis), but the WMS welcomes any tool that can run without direct user interaction, and new file types can be added if needed.", "labels": [], "entities": [{"text": "syntactic analysis", "start_pos": 93, "end_pos": 111, "type": "TASK", "confidence": 0.7581543624401093}, {"text": "WMS", "start_pos": 122, "end_pos": 125, "type": "DATASET", "confidence": 0.8612125515937805}]}, {"text": "For a description of the architecture and user interface of the WMS, see.", "labels": [], "entities": []}, {"text": "In this paper we lift the veil for the way the WMS is implemented, because we think that the symbolic computation programming language that was used for most of the implementation, Bracmat, can be used in other corners of digital humanities concerned with querying and transforming (semi-)structured data.", "labels": [], "entities": []}, {"text": "Symbolic computation software is primarily for solving mathematical equations, but has nevertheless a wide field of application.", "labels": [], "entities": []}, {"text": "The WMS is one of the examples illustrating this.", "labels": [], "entities": [{"text": "WMS", "start_pos": 4, "end_pos": 7, "type": "DATASET", "confidence": 0.5250562429428101}]}, {"text": "Tool registration, computation of workflows, simplification of the presentation of workflows before being presented to the user: each of these tasks calls for the operations that are the rationale for symbolic computation software.", "labels": [], "entities": [{"text": "Tool registration", "start_pos": 0, "end_pos": 17, "type": "TASK", "confidence": 0.7795442342758179}]}, {"text": "Before designing the WMS, we discussed scenarios for how a user could interact with our WMS.", "labels": [], "entities": []}, {"text": "In one scenario a user would have to assemble a workflow manually.", "labels": [], "entities": []}, {"text": "A 'wizard' would made that task easier by for example not allowing a user to insert a tool that was not compatible with the output from already selected tools earlier in the workflow.", "labels": [], "entities": []}, {"text": "Ina more advanced scenario, the 'hairdresser' scenario, the WMS would combine the tools autonomously, while a user only had to specify the required result.", "labels": [], "entities": []}, {"text": "The hairdresser scenario was a logical next step, since there were already workflow systems that assisted users with assembling workflows of LT tools, for example our institute's simple but successful web-based toolbox.", "labels": [], "entities": []}, {"text": "From the implementation point of view the hairdresser scenario had the advantage that the user interface would be simpler than in the wizard scenario.", "labels": [], "entities": []}, {"text": "All that was needed was an input form to get the specification of the user's goal and a form where the user could choose one of the proposed workflows, if the WMS found more than one solution.", "labels": [], "entities": []}, {"text": "There would be relatively little need for feedback to the user, since the user would not be able to make errors.", "labels": [], "entities": []}, {"text": "Both scenarios would require input and output profile information for each integrated tool, but in the hairdresser scenario this information was required to be complete, so that no workflows could be computed that, when executed, would fail to work because of an undocumented mismatch between tools.", "labels": [], "entities": []}, {"text": "In the wizard scenario the user's expertise could supplement incomplete registered tool information.", "labels": [], "entities": []}, {"text": "We chose to implement the hairdresser scenario.", "labels": [], "entities": []}, {"text": "Java was used for all interactions with other CLARIN-DK modules and Bracmat for the computation and management of the workflows.", "labels": [], "entities": [{"text": "Bracmat", "start_pos": 68, "end_pos": 75, "type": "METRIC", "confidence": 0.807969868183136}]}, {"text": "Eight person months were allotted to the implementation of the first version, which was ready in 2011.", "labels": [], "entities": []}, {"text": "This paper proceeds as follows.", "labels": [], "entities": []}, {"text": "In section 2 we present Bracmat.", "labels": [], "entities": [{"text": "Bracmat", "start_pos": 24, "end_pos": 31, "type": "METRIC", "confidence": 0.8536491394042969}]}, {"text": "In section 3 we discuss why symbolic computation software and especially Bracmat makes it easy to implement an automatic WMS.", "labels": [], "entities": [{"text": "WMS", "start_pos": 121, "end_pos": 124, "type": "TASK", "confidence": 0.9048517346382141}]}, {"text": "In section 4 we explain why an essential feature of symbolic computation, pattern matching (PM), is best done in a programming language that has PM as a language construct.", "labels": [], "entities": [{"text": "pattern matching (PM)", "start_pos": 74, "end_pos": 95, "type": "TASK", "confidence": 0.8155097603797913}]}, {"text": "In section 5 we refer to related work.", "labels": [], "entities": []}, {"text": "In section 6 we tell how to obtain the WMS and Bracmat.", "labels": [], "entities": [{"text": "WMS", "start_pos": 39, "end_pos": 42, "type": "DATASET", "confidence": 0.4998542368412018}, {"text": "Bracmat", "start_pos": 47, "end_pos": 54, "type": "METRIC", "confidence": 0.9778793454170227}]}, {"text": "In section 7 we present the conclusions.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": []}