{"title": [{"text": "Combinatorics vs Grammar: archeology of computational poetry in Tape Mark I", "labels": [], "entities": [{"text": "Tape Mark I", "start_pos": 64, "end_pos": 75, "type": "DATASET", "confidence": 0.8640827933947245}]}], "abstractContent": [{"text": "The paper presents a reconstruction of the automatic poetry generation system realized in Italy in 1961 by Nanni Balestrini to compose the poem Tape Mark I. The major goal of the paper is to provide a critical comparison between the high-level approach that seems to be suggested by the poet, and the low-level combinatorial algorithm that was actually implemented.", "labels": [], "entities": [{"text": "poetry generation", "start_pos": 53, "end_pos": 70, "type": "TASK", "confidence": 0.6829781234264374}]}, {"text": "This comparison allows to assess the relevance of how the available technology constrained and shaped the work of the poet, to reveal some of his aesthetic assumptions, and to discuss some aspects of the relation between human and the machine in the creative process.", "labels": [], "entities": []}], "introductionContent": [{"text": "Systems for automatic poetry generation (APG) introduce specific features when compared to systems for natural language generation (NLG).", "labels": [], "entities": [{"text": "automatic poetry generation (APG)", "start_pos": 12, "end_pos": 45, "type": "TASK", "confidence": 0.7841242700815201}, {"text": "natural language generation (NLG)", "start_pos": 103, "end_pos": 136, "type": "TASK", "confidence": 0.8520893553892771}]}, {"text": "While most of data-to-text NLG systems usually follow a pipeline architecture, a number of different architectures and techniques have been applied in APG.", "labels": [], "entities": [{"text": "APG", "start_pos": 151, "end_pos": 154, "type": "TASK", "confidence": 0.8943769931793213}]}, {"text": "A crucial difference between APG and NLG is the nature of the input, that unavoidably involves its evaluation.", "labels": [], "entities": []}, {"text": "The evaluation of a NLG system can be based on a reference corpus, on human evaluation or on the execution of a given task.", "labels": [], "entities": []}, {"text": "However, all these evaluation strategies rely on the reception/comprehension of the message, that is, on the meaning units contained in the input.", "labels": [], "entities": []}, {"text": "In contrast, in the case of APG, a clear notion of input content is not clearly available, and the evaluation of the output is an opaque task, as it depends on aesthetic (or more largely, cultural), widely variable assumptions.", "labels": [], "entities": []}, {"text": "In this sense, APG are similar to other context-evaluated linguistic phenomena such as metaphors.", "labels": [], "entities": [{"text": "APG", "start_pos": 15, "end_pos": 18, "type": "TASK", "confidence": 0.9001214504241943}]}, {"text": "An example of quantitative evaluation of APG based on human judgments is reported in).", "labels": [], "entities": [{"text": "APG", "start_pos": 41, "end_pos": 44, "type": "TASK", "confidence": 0.9274248480796814}]}, {"text": "By following the classification proposed in, there are two main categories of APG systems: the first category is composed by systems that reuse fragments of text from other poetic texts; the second category is composed by systems that generate a stream of text by using some procedures that exploit word-to-word relations.", "labels": [], "entities": []}, {"text": "APG systems from both these categories may use different kinds of linguistic information since fragments fusion, as well as word-to-word relations, can be based on lexical, morpho-syntactical, semantic, rhetorical or metrical theories.", "labels": [], "entities": []}, {"text": "Indeed, fragments fusion can be modeled as a string-based fusion in relation to some combinatorial procedure or, in alternative, as a more complex grammar-based fusion, in this case accounting for more sophisticated linguistic theories.", "labels": [], "entities": [{"text": "fragments fusion", "start_pos": 8, "end_pos": 24, "type": "TASK", "confidence": 0.7425468862056732}]}, {"text": "Only the detailed analysis of a certain specific APG system, rooted on a reproducible implementation, i.e. algorithms and data structures, can help us to understand the real linguistic creative nature of the poetic generation process involved.", "labels": [], "entities": [{"text": "poetic generation", "start_pos": 208, "end_pos": 225, "type": "TASK", "confidence": 0.7324068695306778}]}, {"text": "Another important component in the analysis of the creative aspects of an APG concerns the non-algorithmic contribution that the poet-programmer may introduce in the final version of the poetic artwork.", "labels": [], "entities": []}, {"text": "Indeed, often the poet-programmer, especially in the earlier years of APG, modifies the output provided by the APG system in order to solve some linguistic issues of the system, or in order to select one among various possible outputs.", "labels": [], "entities": []}, {"text": "The aim of this paper is to perform an experiment in archeology of multimedia (): we first analyze, and then reproduce, the poem Tape Mark I by strictly following the actually implemented algorithm.", "labels": [], "entities": []}, {"text": "Tape Mark I was a pioneering example of APG dating from 1961, implemented in the assembler of an IBM 7070, one of the first commercial fully transistorized computer.", "labels": [], "entities": [{"text": "APG", "start_pos": 40, "end_pos": 43, "type": "TASK", "confidence": 0.936494767665863}]}, {"text": "By reproducing the original algorithm we have been able to understand: (1) the details of the creative process related to the combinatorial fusion of textual fragments; (2) the real contribution given by the human poet to the final version of the artwork.", "labels": [], "entities": []}, {"text": "The rest of the paper is organized as follows: Section 2 historically introduces Tape Mark I; Section 3 and Section 4 report the computational descriptions of the artwork from, respectively, a high-and lowlevel perspective; Section 5 describes a simulation experiment regarding the poem; Section 6 critically considers the relation between the author and the algorithm; Section 7 adds some critical conclusions on the evaluation of the system.", "labels": [], "entities": [{"text": "Tape Mark I", "start_pos": 81, "end_pos": 92, "type": "DATASET", "confidence": 0.830762505531311}]}], "datasetContent": [{"text": "The flowchart in is the conceptual schema of Tape Mark I and formalizes the steps performed both by the human (\"author\") and by the machine.", "labels": [], "entities": []}, {"text": "In step I (\"Generation\"), the algorithm starts from This means that the algorithm follows a brute-force approach, without any notion of valid sequence.", "labels": [], "entities": []}, {"text": "In step II (\"Filtering\"), the computer removes the combinations that do not respect the rules expressed by the high-level algorithm.", "labels": [], "entities": []}, {"text": "Step III is dedicated to the assemblage of valid sequences.", "labels": [], "entities": []}, {"text": "The previously reconstructed methodology, strongly constrained by memory allocation techniques on the IBM 7070 and by AUTOCODER specifications, makes clear that the whole poem cannot be generated in one single run of the program, as the single run outputs a 10-element sequence.", "labels": [], "entities": []}, {"text": "Thus, the poem is an assemblage of various outputs, an operation executed by Balestrini, that selects a number of combinations to be used together to produce the final opera 3 . In step IV (\"Segmentation\"), the author segments the combination in order to respect the chosen metrical constraints, i.e. 6 stanzas of 6 verses; In step V (\"Revision\"), the author adjusts a number of words in order to satisfy morphosyntactic constraints in the final text (e.g. verb-subject and number agreement).", "labels": [], "entities": []}, {"text": "One of the main goals of this paper is to understand the effort of the author, in other words what is the contribution of the poet in the Tape Mark I \"electronic poem\" (as computer-based poetry was called at times).", "labels": [], "entities": [{"text": "Tape Mark I \"electronic poem", "start_pos": 138, "end_pos": 166, "type": "DATASET", "confidence": 0.8268583714962006}]}, {"text": "The most unclear point in the Balestrini's work is step I.", "labels": [], "entities": []}, {"text": "Indeed, this step consists of two subprocesses: I-a) generate one permutation P of the 15 elements among the 15!", "labels": [], "entities": []}, {"text": "possible permutations (1.307.674.368.000); I-b) generate all the possible combinations of 10 elements from P (i.e. without repetitions and permutations): for each P there are where C is the binomial coefficient) possible combinations 4 . The total number of possible outputs of Tape Mark I's step I is huge: P (15) * C(15 : 10) = 3, 926, 946, 127, 104, 000.", "labels": [], "entities": []}, {"text": "However, many of these sequences are identical, since the number of distinct sequences is P (10) * C(15 : 10) = 10, 897, 286, 400.", "labels": [], "entities": []}, {"text": "Finally, the total number of \"valid\" sequences, i.e. sequences respecting the constraints of instructions II and III, that we computed by generation and test, is 65, 284, 636.", "labels": [], "entities": []}, {"text": "One of the goals of the simulation is to understand how often the Tape Mark I was able to produce a valid sequence of fragments in output.", "labels": [], "entities": []}, {"text": "So, we have implemented a program which reproduces the steps I and II of the flowchart in.", "labels": [], "entities": []}, {"text": "The original Tape Mark I program was able to generate the 3003 possible combinations of a single permutation in 660 seconds on the IBM 7070.", "labels": [], "entities": []}, {"text": "We have implemented an optimized version of the same process by using C++: this program runs in 0.01 seconds on a modern laptop (4GB ram, i7 2GHz processor) to generate and test the 3003 possible combinations of a single permutation.", "labels": [], "entities": []}, {"text": "However, also with this fast program, we would need 414 years to test all the possible 15!", "labels": [], "entities": []}, {"text": "So we decided to perform an experiment on ten millions random permutations of the 15 elements: for each permutation, we counted how many of the 3003 combinations were valid, i.e. how many combinations satisfy the constraints expressed in the high-level model.", "labels": [], "entities": []}, {"text": "In this way, we can figure how often the original program produced an output that the poet could modify in the steps III and IV and V of.", "labels": [], "entities": []}, {"text": "We found that statistically half of the times all the 3003 combinations extracted from a permutation do not satisfy the required constraints.", "labels": [], "entities": []}, {"text": "However, we also found that the maximum number of valid combinations from one single permutation was 1126 (see the logarithmic graph in.", "labels": [], "entities": []}, {"text": "So, this simula-tion confirms that in order to produce Tape Mark I the poet needed to run the program several times, adopting a severe trial and test procedure.", "labels": [], "entities": []}, {"text": "shows an excerpt of the raw output of the system once printed on paper . Three outputs of 10 elements are shown, the one on top is annotated to allow the reader to follow the chaining mechanism based on head and tail codes.", "labels": [], "entities": []}], "tableCaptions": []}