{"title": [{"text": "Polarity Computations in Flexible Categorial Grammar", "labels": [], "entities": [{"text": "Flexible Categorial Grammar", "start_pos": 25, "end_pos": 52, "type": "TASK", "confidence": 0.5474228461583456}]}], "abstractContent": [{"text": "This paper shows how to take parse trees in CCG and algorithmically find the polarities of all the constituents.", "labels": [], "entities": []}, {"text": "Our work uses the well-known polarization principle corresponding to function application, and we have extended this with principles for type raising and composition.", "labels": [], "entities": [{"text": "function application", "start_pos": 69, "end_pos": 89, "type": "TASK", "confidence": 0.7622918784618378}, {"text": "type raising", "start_pos": 137, "end_pos": 149, "type": "TASK", "confidence": 0.8876691162586212}]}, {"text": "We provide an algorithm, extending the polarity marking algorithm of van Ben-them.", "labels": [], "entities": [{"text": "polarity marking", "start_pos": 39, "end_pos": 55, "type": "TASK", "confidence": 0.6466187089681625}]}, {"text": "We discuss how our system works in practice, taking input from the C&C parser.", "labels": [], "entities": []}], "introductionContent": [{"text": "The main goal of this work is to take input from text and then to automatically determine the polarity of all the words.", "labels": [], "entities": []}, {"text": "For example, we aim to find the arrows in sentences like Every dog \u2193 scares \u2191 at least two \u2193 cats \u2191 , Every dog \u2193 and no cat \u2193 sleeps = , and Most rabbits = hop \u2191 . The \u2191 notation means that whenever we use the given sentence truthfully, if we replace the marked word w with another word which is \"\u2265 w,\" then the resulting sentence will still be true.", "labels": [], "entities": []}, {"text": "So we have a semantic inference.", "labels": [], "entities": []}, {"text": "The \u2193 notation means the same thing, except that when we substitute using a word \u2264 w, we again preserve truth.", "labels": [], "entities": []}, {"text": "Finally, the = notation means that we have neither property in general; in a valid semantic inference statement, we can only replace the word with itself rather than with something larger or smaller.", "labels": [], "entities": []}, {"text": "For example, if we had a collection of background facts like cats \u2264 animals, beagles \u2264 dogs, scares \u2264 startles, and one \u2264 two, then our \u2191 and \u2193 notations on Every dog \u2193 scares \u2191 at least two \u2193 cats \u2191 would allow us to conclude Every beagle startles at least one animal.", "labels": [], "entities": []}, {"text": "The goal of the paper is to provide a computational system to determine the notations \u2191, \u2193, = on input text to the best extent possible, either using hand-created parses, or output from a popular and freely available CCG parser C&C.", "labels": [], "entities": [{"text": "CCG parser C&C", "start_pos": 217, "end_pos": 231, "type": "DATASET", "confidence": 0.7647602796554566}]}, {"text": "Using our polarity tool, we get a very easy first step on automatic inference done with little or no representation.", "labels": [], "entities": []}, {"text": "We discuss potential applications to textual inference.", "labels": [], "entities": [{"text": "textual inference", "start_pos": 37, "end_pos": 54, "type": "TASK", "confidence": 0.7610805928707123}]}, {"text": "Theory We extend polarity determination for categorial grammar (CG) (see;).", "labels": [], "entities": [{"text": "polarity determination", "start_pos": 17, "end_pos": 39, "type": "TASK", "confidence": 0.6921719461679459}, {"text": "categorial grammar (CG)", "start_pos": 44, "end_pos": 67, "type": "TASK", "confidence": 0.6855859875679016}]}, {"text": "These papers only consider the Ajdukiewicz/Bar-Hillel (AB) flavor of CG, where the rules are restricted to application rules (>) and (<).", "labels": [], "entities": [{"text": "AB", "start_pos": 55, "end_pos": 57, "type": "METRIC", "confidence": 0.6016293168067932}]}, {"text": "There is a consensus that application rules alone are too restrictive to give wide-coverage grammars.", "labels": [], "entities": []}, {"text": "We thus extend this work to the full set of flexible combinators used in CCG.", "labels": [], "entities": []}, {"text": "We prove that our system is sound, in a precise sense.", "labels": [], "entities": []}, {"text": "Further, we show how to incorporate boolean reasoning ( to get a more complete system.", "labels": [], "entities": []}, {"text": "A working system We have implemented our algorithm in Python.", "labels": [], "entities": []}, {"text": "This implementation handles sentences from the C&C parser.", "labels": [], "entities": []}, {"text": "This is a non-trivial step on top of the theoretical advance because the parses delivered by the C&C parser deviate in several respects from the semantically-oriented input that one would like for this kind of work.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": []}