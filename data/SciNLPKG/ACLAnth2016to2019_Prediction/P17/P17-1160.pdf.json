{"title": [{"text": "Generic Axiomatization of Families of Noncrossing Graphs in Dependency Parsing", "labels": [], "entities": [{"text": "Parsing", "start_pos": 71, "end_pos": 78, "type": "TASK", "confidence": 0.6761322617530823}]}], "abstractContent": [{"text": "We present a simple encoding for unla-beled noncrossing graphs and show how its latent counterpart helps us to represent several families of directed and undi-rected graphs used in syntactic and semantic parsing of natural language as context-free languages.", "labels": [], "entities": [{"text": "syntactic and semantic parsing of natural language", "start_pos": 181, "end_pos": 231, "type": "TASK", "confidence": 0.755856488432203}]}, {"text": "The families are separated purely on the basis of forbidden patterns in latent encoding, eliminating the need to differentiate the families of non-crossing graphs in inference algorithms: one algorithm works for all when the search space can be controlled in parser input.", "labels": [], "entities": []}], "introductionContent": [{"text": "Dependency parsing has received wide attention in recent years, as accurate and efficient dependency parsers have appeared that are applicable to many languages.", "labels": [], "entities": [{"text": "Dependency parsing", "start_pos": 0, "end_pos": 18, "type": "TASK", "confidence": 0.9182758927345276}]}, {"text": "Traditionally, dependency parsers have produced syntactic analyses in tree form, including exact inference algorithms that search for maximum projective trees and maximum spanning trees) in weighted digraphs, as well as greedy and beamsearch approaches that forgo exact search for extra efficiency (.", "labels": [], "entities": [{"text": "dependency parsers", "start_pos": 15, "end_pos": 33, "type": "TASK", "confidence": 0.7755407691001892}]}, {"text": "Recently, there has been growing interest in providing a richer analysis of natural language by going beyond trees.", "labels": [], "entities": []}, {"text": "In semantic dependency parsing, the desired syntactic representations can have indegree greater than 1 (re-entrancy), suggesting the search for maximum acyclic subgraphs).", "labels": [], "entities": [{"text": "semantic dependency parsing", "start_pos": 3, "end_pos": 30, "type": "TASK", "confidence": 0.638459324836731}]}, {"text": "As this inference task is intractable), noncrossing digraphs have been studied instead, e.g. by who provide a O(n 3 ) parser for maximum noncrossing acyclic subgraphs.", "labels": [], "entities": []}, {"text": "Yli-Jyr\u00e4 (2005) studied how to axiomatize dependency trees as a special case of noncrossing digraphs.", "labels": [], "entities": []}, {"text": "This gave rise to anew homomorphic representation of context-free languages that proves the classical Chomsky and Sch\u00fctzenberger theorem using a quite different internal language.", "labels": [], "entities": []}, {"text": "In this language, the brackets indicate arcs in a dependency tree in away that is reminiscent to encoding schemes used earlier by and.", "labels": [], "entities": []}, {"text": "Cubic-time parsing algorithms that are incidentally or intentionally applicable to this kind of homomorphic representations have been considered, e.g., by,.", "labels": [], "entities": []}, {"text": "Extending these insights to arbitrary noncrossing digraphs, or to relevant families of them, is far from obvious.", "labels": [], "entities": []}, {"text": "In this paper, we develop (1) a linear encoding supporting general noncrossing digraphs, and show that the encoded noncrossing digraphs form a context-free language.", "labels": [], "entities": []}, {"text": "We then give it (3) two homomorphic, nonderivative representations and use the latent local features of the latter to characterize various families of digraphs.", "labels": [], "entities": []}, {"text": "Apart from the obvious relevance to the theory of context-free languages, this contribution has the practical potential to enable (4) generic contextfree parsers that produce different families of noncrossing graphs with the same set of inference rules while the search space in each case is restricted with lexical features and the grammar.", "labels": [], "entities": []}, {"text": "Outline After some background on graphs and parsing as inference (Section 2), we use an ontology of digraphs to illustrate natural families of noncrossing digraphs in Section 3.", "labels": [], "entities": []}, {"text": "We then develop, in Section 4, the first latent contextfree representation for the set of noncrossing digraphs, then extended in Section 5 with additional latent states supporting our finite-state axiomatization of digraph properties, and allowing us to Dependency Parsing The complete digraph G S (V, A) of a sentence S = x 1 ...x n consists of vertices V = {1, ..., n} and all possible arcs A = V \u00d7 V \u2212 {(i, i)}.", "labels": [], "entities": [{"text": "Dependency Parsing", "start_pos": 254, "end_pos": 272, "type": "TASK", "confidence": 0.8631444275379181}]}, {"text": "The vertex i \u2208 V corresponds to the word xi and the arc i \u2192 j \u2208 A corresponds to a possible dependency between the words xi and x j . The task of dependency parsing is to find a constrained subgraph G S (V, A ) of the complete digraph G S of the sentence.", "labels": [], "entities": [{"text": "dependency parsing", "start_pos": 146, "end_pos": 164, "type": "TASK", "confidence": 0.7472382187843323}]}, {"text": "The standard solution is a rooted directed tree called a dependency tree or a dag called a dependency graph.", "labels": [], "entities": []}, {"text": "Constrained Inference In arc-factored parsing, each possible arc i \u2192 j is equipped with a positive weight w i j , usually computed as a weighted sum w i j = w \u00b7 \u03a6(S, i \u2192 j) where w is a weight vector and \u03a6(x, i \u2192 j) a feature vector extracted from the sentence x, considering the dependency relation from word xi to word x j . Parsing then consists in finding an arc subset A \u2286 A that gives us a constrained subgraph (V, A ) \u2208 Constrained(V, A) of the complete digraph (V, A) with maximum sum of arc weights: The complexity of this inference task depends on the constraints imposed on the subgraph.", "labels": [], "entities": [{"text": "Parsing", "start_pos": 327, "end_pos": 334, "type": "TASK", "confidence": 0.9733702540397644}]}, {"text": "Under no constraints, we simply set A = A.", "labels": [], "entities": []}, {"text": "Inference over dags is intractable).", "labels": [], "entities": []}, {"text": "Efficient solutions are known for projective trees, various classes of mildly nonprojective trees, unrestricted spanning trees (), and both unrestricted and weakly connected noncrossing dags (.", "labels": [], "entities": []}, {"text": "Parsimony Semantic parsers must be able to produce more than projective trees because the share of projective trees is pretty low (under 3%) in semantic graph banks (.", "labels": [], "entities": []}, {"text": "However, if we know that the parses have some restrictions, it is better to use them to restrict the search space as much as possible.", "labels": [], "entities": []}, {"text": "There are two strategies for reducing the search space.", "labels": [], "entities": []}, {"text": "One is to develop a specialized inference algorithm fora particular natural language or family of dags, such as weakly connected graphs (.", "labels": [], "entities": []}, {"text": "The other strategy is to control the local complexity of digraphs through lexical categories ( or equivalent mechanisms.", "labels": [], "entities": []}, {"text": "This strategy produces a more sensitive model of the language, but requires a principled insight on how the complexity of digraphs can be characterized.", "labels": [], "entities": []}], "datasetContent": [{"text": "The current experiments were designed (1) to help in developing the components of Reg lat and the constraint languages of axiomatic properties, (2) to validate the representation, the constraint languages and their unambiguity, (3) to learn about the ontology and (4) to sample the integer sequences associated with the cardinality of each family in the ontology.", "labels": [], "entities": [{"text": "Reg lat", "start_pos": 82, "end_pos": 89, "type": "DATASET", "confidence": 0.9255058765411377}]}], "tableCaptions": [{"text": " Table 2: Characterizations for some noncrossing families of digraphs and graphs", "labels": [], "entities": []}]}