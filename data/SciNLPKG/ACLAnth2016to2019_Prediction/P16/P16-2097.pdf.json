{"title": [{"text": "Using Sequence Similarity Networks to Identify Partial Cognates in Multilingual Wordlists", "labels": [], "entities": [{"text": "Sequence Similarity", "start_pos": 6, "end_pos": 25, "type": "TASK", "confidence": 0.8043522238731384}, {"text": "Identify Partial Cognates in Multilingual Wordlists", "start_pos": 38, "end_pos": 89, "type": "TASK", "confidence": 0.8110587298870087}]}], "abstractContent": [{"text": "Increasing amounts of digital data in historical linguistics necessitate the development of automatic methods for the detection of cognate words across languages.", "labels": [], "entities": []}, {"text": "Recently developed methods work well on language families with moderate time depths, but they are not capable of identifying cognate morphemes in words which are only partially related.", "labels": [], "entities": []}, {"text": "Partial cog-nacy, however, is a frequently recurring phenomenon, especially in language families with productive derivational morphology.", "labels": [], "entities": []}, {"text": "This paper presents a pilot approach for partial cognate detection in which networks are used to represent similarities between word parts and cognate morphemes are identified with help of state-of-the-art algorithms for network partitioning.", "labels": [], "entities": [{"text": "partial cognate detection", "start_pos": 41, "end_pos": 66, "type": "TASK", "confidence": 0.6921818256378174}]}, {"text": "The approach is tested on a newly created benchmark dataset with data from three sub-branches of Sino-Tibetan and yields very promising results, outperforming all algorithms which are not sensible to partial cognacy.", "labels": [], "entities": []}], "introductionContent": [{"text": "Ina very general notion, cognacy is similar to the concept of homology in biology (, denoting a relation between words which share a common history).", "labels": [], "entities": []}, {"text": "In classical linguistics, borrowings are often excluded from this notion.", "labels": [], "entities": []}, {"text": "Quantitative approaches additionally distinguish cognates which have retained, and cognates which have shifted their meaning).", "labels": [], "entities": []}, {"text": "Further aspects of cognacy are rarely distinguished, although they are obvious and common.", "labels": [], "entities": []}, {"text": "Words which go back to the same ancestor form can for example have been morphologically modified, such as French soleil which does not go directly back to Latin s\u014d\u00ecsun' but to s\u014dliculus`smalls\u014dliculus`small sun' which is itself a derivation of s\u014dl  Another problem are words which have been created from two or more morphemes via processes of compounding.", "labels": [], "entities": []}, {"text": "While these cases are rather rare in the core vocabulary of IndoEuropean languages, they are very frequent in South-East Asian language families like SinoTibetan or Austro-Asiatic.", "labels": [], "entities": []}, {"text": "In 200 basic words across 23 Chinese dialects, for example, almost 50% of the nouns and more than 30% of all words consist of two or more morphemes (see the Sup. Material for details).", "labels": [], "entities": [{"text": "Sup. Material", "start_pos": 157, "end_pos": 170, "type": "DATASET", "confidence": 0.7107055634260178}]}, {"text": "The presence of words consisting of more than one morpheme challenges the notion that words can either be cognate or not.", "labels": [], "entities": []}, {"text": "It poses problems for phylogenetic approaches which require binary presence-absence matrices as input and model language evolution as cognate gain and cognate loss).", "labels": [], "entities": []}, {"text": "This is illustrated in where words for`moonfor`moon' in four Chinese dialects) are compared, with cognate elements being given the same color.", "labels": [], "entities": []}, {"text": "If we assign cognacy strictly, only matching those words which are identical in all their elements, we would have to label all words as being not cognate.", "labels": [], "entities": []}, {"text": "If we assign cognacy loosely (Satterthwaite-Phillips 2011), labeling all words as cognate when only they share a common morpheme, we would have to label all words as cognate.", "labels": [], "entities": []}, {"text": "No matter how we code in phylogenetic analyses, as long as we use binary states, we will loose information.", "labels": [], "entities": []}, {"text": "Partial cognacy is also a problem for current cognate detection algorithms which compare words in their entirety (List 2014b,.", "labels": [], "entities": []}, {"text": "Given the frequency of compound words in South-East Asian languages, it is not surprising that the algorithms perform much worse on diverse South-East Asian language families, than they perform on other language families where compounding is less frequent.", "labels": [], "entities": []}, {"text": "This paper presents anew algorithm for cognate detection which does not identify cognate words but instead searches for cognate elements in words.", "labels": [], "entities": [{"text": "cognate detection", "start_pos": 39, "end_pos": 56, "type": "TASK", "confidence": 0.7730355262756348}]}, {"text": "The algorithm takes multilingual word lists as input and outputs statements regarding the cognacy of morphemes, just as the ones shown in the last column of, where identical numerical IDs are given for all morphemes identified as cognate.", "labels": [], "entities": []}], "datasetContent": [{"text": "All methods, be it classical or partial cognate detection, require a user-defined threshold.", "labels": [], "entities": []}, {"text": "Since our gold standard data was too small to split it into training and tests sets, we carried out an exhaustive comparison of all methods on different thresholds varying between 0.05 and 0.95 in steps of 0.05.", "labels": [], "entities": []}, {"text": "B-cubed scores were chosen as an evaluation measure for cognate detection (Bagga and Baldwin 1998), since they have been shown to yield sensible results.", "labels": [], "entities": [{"text": "cognate detection", "start_pos": 56, "end_pos": 73, "type": "TASK", "confidence": 0.7385893017053604}]}, {"text": "With SCA and LexStat, two classical methods for cognate detection were tested List (2014b), and their underlying models for phonetic similarity (see Sec.", "labels": [], "entities": [{"text": "LexStat", "start_pos": 13, "end_pos": 20, "type": "DATASET", "confidence": 0.9800880551338196}, {"text": "cognate detection", "start_pos": 48, "end_pos": 65, "type": "TASK", "confidence": 0.7605308294296265}]}, {"text": "3.1) were used as basis for the partial cognate detection algorithm.", "labels": [], "entities": [{"text": "partial cognate detection", "start_pos": 32, "end_pos": 57, "type": "TASK", "confidence": 0.6459113955497742}]}, {"text": "All in all, this yielded four different methods: LexStat, LexStatPartial, SCA, and SCA-Partial.", "labels": [], "entities": [{"text": "LexStat", "start_pos": 49, "end_pos": 56, "type": "DATASET", "confidence": 0.8354812860488892}, {"text": "LexStatPartial", "start_pos": 58, "end_pos": 72, "type": "DATASET", "confidence": 0.8477017283439636}]}, {"text": "Since our new algorithms yield partial cognates, while LexStat and SCA yield``yield``complete\" cognates, it is not possible to compare them directly.", "labels": [], "entities": [{"text": "LexStat", "start_pos": 55, "end_pos": 62, "type": "DATASET", "confidence": 0.9594101309776306}]}, {"text": "In order to allow fora direct comparison, partial cognate sets were converted int\u00f2`complete\" cognate sets using the above-mentioned strict coding approach proposed by Ben Hamed and: only those words in which all morphemes are cognate were assigned to the cognate same set.", "labels": [], "entities": []}, {"text": "With a total of three different clustering algorithms (UPGMA, Markov Clustering, and Infomap), we thus carried out twelve tests on complete cognacy (three for each of our four approaches), and six additional tests on pure partial cognate detection, in which we compared the suitability of SCA and LexStat as string similarity measures.: General performance of the algorithms on all datasets.", "labels": [], "entities": [{"text": "pure partial cognate detection", "start_pos": 217, "end_pos": 247, "type": "TASK", "confidence": 0.8175169974565506}, {"text": "LexStat", "start_pos": 297, "end_pos": 304, "type": "DATASET", "confidence": 0.9446150064468384}]}, {"text": "The table shows for each of the 18 different methods the threshold (T) for which the best B-Cubed F-Score was determined, as well as the B-Cubed precision (P), recall (R), and F-score (FS).", "labels": [], "entities": [{"text": "F-Score", "start_pos": 98, "end_pos": 105, "type": "METRIC", "confidence": 0.5643007159233093}, {"text": "B-Cubed precision (P)", "start_pos": 137, "end_pos": 158, "type": "METRIC", "confidence": 0.8436762690544128}, {"text": "recall (R)", "start_pos": 160, "end_pos": 170, "type": "METRIC", "confidence": 0.9609016329050064}, {"text": "F-score (FS)", "start_pos": 176, "end_pos": 188, "type": "METRIC", "confidence": 0.9649171531200409}]}, {"text": "The best result in each block is shaded in gray.", "labels": [], "entities": []}], "tableCaptions": [{"text": " Table 1: Partial cognacy in Chinese dialects.", "labels": [], "entities": [{"text": "Partial cognacy in Chinese dialects", "start_pos": 10, "end_pos": 45, "type": "TASK", "confidence": 0.8169625639915467}]}, {"text": " Table 2: Partial cognate detection gold standard", "labels": [], "entities": []}, {"text": " Table 3: General performance of the algorithms  on all datasets. The table shows for each of the 18  different methods the threshold (T) for which the  best B-Cubed F-Score was determined, as well as  the B-Cubed precision (P), recall (R), and F-score  (FS). The best result in each block is shaded in  gray.", "labels": [], "entities": [{"text": "B-Cubed precision (P)", "start_pos": 206, "end_pos": 227, "type": "METRIC", "confidence": 0.8242662191390991}, {"text": "recall (R)", "start_pos": 229, "end_pos": 239, "type": "METRIC", "confidence": 0.9554528146982193}, {"text": "F-score  (FS)", "start_pos": 245, "end_pos": 258, "type": "METRIC", "confidence": 0.9641318321228027}]}]}