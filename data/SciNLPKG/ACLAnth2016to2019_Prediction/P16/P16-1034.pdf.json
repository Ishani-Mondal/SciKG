{"title": [{"text": "Dependency Parsing with Bounded Block Degree and Well-nestedness via Lagrangian Relaxation and Branch-and-Bound", "labels": [], "entities": [{"text": "Dependency Parsing", "start_pos": 0, "end_pos": 18, "type": "TASK", "confidence": 0.7320640385150909}, {"text": "Bounded Block Degree", "start_pos": 24, "end_pos": 44, "type": "METRIC", "confidence": 0.8067212502161661}]}], "abstractContent": [{"text": "We present a novel dependency parsing method which enforces two structural properties on dependency trees: bounded block degree and well-nestedness.", "labels": [], "entities": [{"text": "dependency parsing", "start_pos": 19, "end_pos": 37, "type": "TASK", "confidence": 0.8097928166389465}]}, {"text": "These properties are useful to better represent the set of admissible dependency structures in treebanks and connect dependency parsing to context-sensitive grammatical formalisms.", "labels": [], "entities": [{"text": "dependency parsing", "start_pos": 117, "end_pos": 135, "type": "TASK", "confidence": 0.7672019302845001}]}, {"text": "We cast this problem as an Integer Linear Program that we solve with La-grangian Relaxation from which we derive a heuristic and an exact method based on a Branch-and-Bound search.", "labels": [], "entities": [{"text": "Relaxation", "start_pos": 81, "end_pos": 91, "type": "METRIC", "confidence": 0.90378338098526}]}, {"text": "Experimentally , we see that these methods are efficient and competitive compared to a base-line unconstrained parser, while enforcing structural properties in all cases.", "labels": [], "entities": []}], "introductionContent": [{"text": "We address the problem of enforcing two structural properties on dependency trees, namely bounded block degree and well-nestedness, without sacrificing algorithmic efficiency.", "labels": [], "entities": []}, {"text": "Intuitively, bounded block degree constraints force each subtree to have a yield decomposable into a limited number of blocks of contiguous words, while well-nestedness asserts that every two distinct subtrees must not interleave: either the yield of one subtree is entirely inside some gap of the other or they are completely separated.", "labels": [], "entities": []}, {"text": "These two types of constraints generalize the notion of projectivity: projective trees actually have a block degree bounded to one and are well-nested.", "labels": [], "entities": []}, {"text": "Our first motivation is the fact that most dependency trees in NLP treebanks are well-nested and have a low block degree which depends on the language and the linguistic representation, as shown in).", "labels": [], "entities": []}, {"text": "Unfortunately, although polynomial algorithms exist for this class of trees (), they are not efficient enough to be of practical use in applications requiring syntactic structures.", "labels": [], "entities": []}, {"text": "In addition, if either property is dropped, but not the other, then the underlying decision problem becomes harder.", "labels": [], "entities": []}, {"text": "That is why practical parsing algorithms are either completely unconstrained) or enforce strict projectivity ( . This work is, to the best of our knowledge, the first attempt to build a discriminative dependency parser that enforces well-nestedness and/or bounded block degree and to use it on treebank data.", "labels": [], "entities": []}, {"text": "We base our method on the following observation: a non-projective dependency parser, thus not requiring neither well-nestedness nor bounded block degree, returns dependency trees satisfying these constraints in the vast majority of sentences.", "labels": [], "entities": []}, {"text": "This would tend to indicate that the heavy machinery involved to parse with these constraints is only needed in very few cases.", "labels": [], "entities": [{"text": "parse", "start_pos": 65, "end_pos": 70, "type": "TASK", "confidence": 0.9801476001739502}]}, {"text": "We consider arc-factored dependency parsing with well-nestedness and bounded block degree constraints.", "labels": [], "entities": [{"text": "arc-factored dependency parsing", "start_pos": 12, "end_pos": 43, "type": "TASK", "confidence": 0.6363131801287333}]}, {"text": "We formulate this problem as an Integer Linear Program (ILP) and apply Lagrangian Relaxation where the dualized constraints are those associated with bounded block degree and well-nestedness.", "labels": [], "entities": []}, {"text": "The Lagrangian dual objective then reduces to a maximum spanning arborescence and can be solved very efficiently.", "labels": [], "entities": []}, {"text": "This provides an efficient heuristic for our problem.", "labels": [], "entities": []}, {"text": "An exact method can be derived by embedding this Lagrangian Relaxation in a Branch-and-Bound procedure to solve the problem with an optimality certificate.", "labels": [], "entities": []}, {"text": "Despite the exponential worst-time complexity of the Branch-and-Bound procedure, it is tractable in practice.", "labels": [], "entities": []}, {"text": "Our formulation can enforce both types of constraints or only one of them without changing the resolution method.", "labels": [], "entities": []}, {"text": "As stated in (, well-nested dependency trees with 2-bounded block degree are structurally equivalent to derivations in Lexicalized Tree Adjoining Grammars (LTAGs).", "labels": [], "entities": []}, {"text": "While LTAGs can be parsed in polynomial time, developing an efficient parser for these grammars remains an open problem) and we believe that this work could be a useful step in that direction.", "labels": [], "entities": []}, {"text": "Related work is reviewed in Section 2.", "labels": [], "entities": []}, {"text": "We define arc-factored dependency parsing with block degree and well-nestedness constraints in Section 3.", "labels": [], "entities": [{"text": "arc-factored dependency parsing", "start_pos": 10, "end_pos": 41, "type": "TASK", "confidence": 0.6072905659675598}]}, {"text": "We derive an ILP formulation of this problem in Section 4 and then present our method based on Lagrangian Relaxation in Section 5 and Branch-and-Bound in Section 6.", "labels": [], "entities": []}, {"text": "Section 7 contains experimental results on several languages.", "labels": [], "entities": []}], "datasetContent": [{"text": "We ran a series of experiments to test our method in the case of unlabelled dependency parsing.", "labels": [], "entities": [{"text": "dependency parsing", "start_pos": 76, "end_pos": 94, "type": "TASK", "confidence": 0.6680955141782761}]}, {"text": "Our prototype has been developped in Python with some parts in Cython and C++.", "labels": [], "entities": []}, {"text": "We use the MSA implementation available in the LEMON library.", "labels": [], "entities": [{"text": "LEMON library", "start_pos": 47, "end_pos": 60, "type": "DATASET", "confidence": 0.8285530507564545}]}, {"text": "We ran experiments on 5 different corpora: English: Dependencies were extracted from the WSJ part of the Penn Treebank (PTB) with additional NP bracketings ( with the LTH converter 9 (default options).", "labels": [], "entities": [{"text": "WSJ part of the Penn Treebank (PTB)", "start_pos": 89, "end_pos": 124, "type": "DATASET", "confidence": 0.9334632092052035}]}, {"text": "Sections 02-21 are used for training, 22 for development and 23 for testing.", "labels": [], "entities": []}, {"text": "POS tags were predicted by the Stanford tagger 10 trained with 10-jackkniffing.", "labels": [], "entities": [{"text": "POS tags", "start_pos": 0, "end_pos": 8, "type": "TASK", "confidence": 0.6275379359722137}]}, {"text": "German: We used dependencies from the SPMRL dataset (, with predicted POS tags and the official split.", "labels": [], "entities": [{"text": "SPMRL dataset", "start_pos": 38, "end_pos": 51, "type": "DATASET", "confidence": 0.9069302678108215}]}, {"text": "We removed sentences of length greater than 100 in the test set.", "labels": [], "entities": []}, {"text": "Dutch, Spanish and Portuguese: We used the Universal Dependency Treebank 1.2 (Van der Beek et al.,) with gold POS tags and the official split.", "labels": [], "entities": [{"text": "Universal Dependency Treebank 1.2", "start_pos": 43, "end_pos": 76, "type": "DATASET", "confidence": 0.9140515476465225}]}, {"text": "We removed sentences of length greater than 100 in the test sets.", "labels": [], "entities": []}, {"text": "Those datasets contain different structure distributions as shown in.", "labels": [], "entities": []}, {"text": "Fortunately, our method allows us to easily change the bounded degree constraint or toggle the well-nestedness one.", "labels": [], "entities": []}, {"text": "For each language, we decided to use the most constrained combination of bounded block degree constraints and well-nestedness which covers over 99% of the data.", "labels": [], "entities": []}, {"text": "Therefore, we chose to enforce 2-BBD and well-nestedness for English and Spanish, 3-BBD and well-nestedness for Dutch and Portuguese and 3-BBD only for German.", "labels": [], "entities": []}], "tableCaptions": [{"text": " Table 1: Distribution of dependency tree characteristics in datasets.", "labels": [], "entities": []}, {"text": " Table 2: Timings for strategies (see Section 7.2) on test for solu- tions which do not satisfy constraints after running MSA. We give  (in seconds) average time, standard deviation, median time, time  to parse up to the 3rd quartile and total time.", "labels": [], "entities": [{"text": "Timings", "start_pos": 10, "end_pos": 17, "type": "METRIC", "confidence": 0.9692033529281616}, {"text": "standard", "start_pos": 163, "end_pos": 171, "type": "METRIC", "confidence": 0.9723482728004456}]}, {"text": " Table 3: UAS, percentage of valid structure and decoding time for test data. Time is relative to MSA decoding. The percentage  of valid structure is always 100% except for MSA decoding.", "labels": [], "entities": [{"text": "UAS", "start_pos": 10, "end_pos": 13, "type": "DATASET", "confidence": 0.490516722202301}, {"text": "Time", "start_pos": 78, "end_pos": 82, "type": "METRIC", "confidence": 0.965356171131134}]}, {"text": " Table 4: UAS, percentage of valid dependency trees (VDT) and relative time (RT) obtained by Turboparser for different score  functions on test sets. For each language we give the percentage of valid dependency structures in the data, according to the  constraints postulated in Section 7.1.", "labels": [], "entities": [{"text": "UAS", "start_pos": 10, "end_pos": 13, "type": "DATASET", "confidence": 0.568977415561676}, {"text": "valid dependency trees (VDT)", "start_pos": 29, "end_pos": 57, "type": "METRIC", "confidence": 0.6000392884016037}, {"text": "relative time (RT)", "start_pos": 62, "end_pos": 80, "type": "METRIC", "confidence": 0.9516445755958557}]}]}