{"title": [{"text": "Parsing Weighted Order-Preserving Hyperedge Replacement Grammars", "labels": [], "entities": [{"text": "Parsing Weighted Order-Preserving Hyperedge Replacement Grammars", "start_pos": 0, "end_pos": 64, "type": "TASK", "confidence": 0.8230988184611002}]}], "abstractContent": [{"text": "We introduce a weighted extension of the recently proposed notion of order-preserving hyperedge-replacement grammars and prove that the weight of a graph according to such a weighted graph grammar can be computed uniformly in quadratic time (under assumptions made precise in the paper).", "labels": [], "entities": []}], "introductionContent": [{"text": "The hyperedge-replacement grammar (HRG) is a well-studied formalism for describing graph languages; see, e.g.,.", "labels": [], "entities": []}, {"text": "As argued by,, and it is also a promising candidate for modelling semantic representations of natural language such as Abstract Meaning Representation (AMR, see).", "labels": [], "entities": [{"text": "Abstract Meaning Representation (AMR", "start_pos": 119, "end_pos": 155, "type": "TASK", "confidence": 0.6929687559604645}]}, {"text": "However, HRGs overshoot the mark in that parsing with respect to them is computationally too expensive.", "labels": [], "entities": []}, {"text": "Further, HRGs can express intricate structural properties whose complexity is far beyond what seems to be required to describe practically relevant languages of semantic graphs such as AMR.", "labels": [], "entities": []}, {"text": "For example, as argued by it suffices if the path languages of such graph languages are regular languages.", "labels": [], "entities": []}, {"text": "In contrast, HRGs easily give rise to even non-context-free path languages.", "labels": [], "entities": []}, {"text": "Thus, from both perspectives less powerful special cases should besought if this helps to cut down on parsing complexity.", "labels": [], "entities": [{"text": "parsing complexity", "start_pos": 102, "end_pos": 120, "type": "TASK", "confidence": 0.8748471438884735}]}, {"text": "Recently, such a restriction, called order preservation, was proposed and studied in.", "labels": [], "entities": [{"text": "order preservation", "start_pos": 37, "end_pos": 55, "type": "TASK", "confidence": 0.7582629024982452}]}, {"text": "The present article builds upon the orderpreserving HRGs (OPHGs) of, where it was shown that parsing for OPHGs is efficient, requiring polynomial time even in the uniform case i.e. when the grammar is considered to be part of the input.", "labels": [], "entities": []}, {"text": "Here, we define a weighted version of OPHGs, and extend the results of to show that when the weights are taken from a commutative semiring, we can efficiently compute the weight assigned by an OPHG to any input graph.", "labels": [], "entities": []}, {"text": "This is an important feature since applications such as semantic modelling require ways to quantify the well-formedness of a generated graph.", "labels": [], "entities": [{"text": "semantic modelling", "start_pos": 56, "end_pos": 74, "type": "TASK", "confidence": 0.8230782449245453}]}, {"text": "While providing a notion of grammars with weights may appear to be a simple task as one only has to assign weights to the rules, doing so in a meaningful way for unrestricted HRGs is actually not simple at all.", "labels": [], "entities": []}, {"text": "The reason is that the weights of different derivation trees generating the same graph should be summed up to obtain the weight of the graph.", "labels": [], "entities": []}, {"text": "However, if a right-hand side of a rule has nontrivial automorphisms that interchange two or more nonterminal hyperedges, one gets spuriously distinct derivation trees that should intuitively be considered identical.", "labels": [], "entities": []}, {"text": "At the very least, this complicates uniform parsing as it requires to preprocess the rules to detect the automorphisms of their righthand sides, a task for which no polynomial solution is known.", "labels": [], "entities": [{"text": "uniform parsing", "start_pos": 36, "end_pos": 51, "type": "TASK", "confidence": 0.5940207242965698}]}, {"text": "In OPHGs, only the right-hand sides of so-called duplication rules have nontrivial automorphisms, and those do not require preprocessing.", "labels": [], "entities": []}, {"text": "These rules correspond to associative and commutative operations, which we propose to take special care of in the computation of weights by using a type of reduced derivation trees introduced for the same purpose by; see also.", "labels": [], "entities": []}, {"text": "In these derivation trees, some nodes have a set of children, while others have them ordered in a list.", "labels": [], "entities": []}, {"text": "After this, we show how weights can efficiently be computed, and prove the correctness of the algorithm.", "labels": [], "entities": []}, {"text": "Another type of restricted HRGs for semantic modelling was proposed by, together with a parsing algorithm and a detailed complexity analysis.", "labels": [], "entities": [{"text": "semantic modelling", "start_pos": 36, "end_pos": 54, "type": "TASK", "confidence": 0.9177536964416504}]}, {"text": "The complexity is, however, exponential even in the non-uniform case.", "labels": [], "entities": []}, {"text": "In particular, it is exponential in the maximum degree of nodes in the input graph.", "labels": [], "entities": []}, {"text": "The same holds for the parsing algorithm for regular graph grammars presented by.", "labels": [], "entities": []}, {"text": "We also mention that another technique for efficient HRG parsing was resently developed by).", "labels": [], "entities": [{"text": "HRG parsing", "start_pos": 53, "end_pos": 64, "type": "TASK", "confidence": 0.8731882572174072}]}], "datasetContent": [], "tableCaptions": []}