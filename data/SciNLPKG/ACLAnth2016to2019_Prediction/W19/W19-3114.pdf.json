{"title": [{"text": "Latin script keyboards for South Asian languages with finite-state normalization", "labels": [], "entities": []}], "abstractContent": [{"text": "The use of the Latin script for text entry of South Asian languages is common, even though there is no standard orthogra-phy for these languages in the script.", "labels": [], "entities": [{"text": "text entry", "start_pos": 32, "end_pos": 42, "type": "TASK", "confidence": 0.6754427999258041}]}, {"text": "We explore several compact finite-state archi-tectures that permit variable spellings of words during mobile text entry.", "labels": [], "entities": []}, {"text": "We find that approaches making use of transliter-ation transducers provide large accuracy improvements over baselines, but that simpler approaches involving a compact representation of many attested alternatives yields much of the accuracy gain.", "labels": [], "entities": [{"text": "accuracy", "start_pos": 81, "end_pos": 89, "type": "METRIC", "confidence": 0.9977115392684937}, {"text": "accuracy", "start_pos": 231, "end_pos": 239, "type": "METRIC", "confidence": 0.9992541670799255}]}, {"text": "This is particularly important when operating under constraints on model size (e.g., on inexpensive mobile devices with limited storage and memory for keyboard models), and on speed of inference, since people typing on mobile keyboards expect no perceptual delay in keyboard responsiveness.", "labels": [], "entities": [{"text": "speed", "start_pos": 176, "end_pos": 181, "type": "METRIC", "confidence": 0.9599988460540771}]}], "introductionContent": [{"text": "Many of the world's writing systems present challenges for machine readable text entry compared with alphabetic writing systems (such as the Latin script used for the English in this paper).", "labels": [], "entities": [{"text": "machine readable text entry", "start_pos": 59, "end_pos": 86, "type": "TASK", "confidence": 0.6336784139275551}]}, {"text": "For example, a very large character set, such as that used for Chinese, can be impractical to represent on a keyboard requiring direct selection of characters; hence specialized encoding methods are generally used based on smaller symbol sets.", "labels": [], "entities": []}, {"text": "For example, the well-known pinyin system for text entry of Chinese relies on Latin alphabetic codes to input Chinese characters.", "labels": [], "entities": [{"text": "text entry of Chinese", "start_pos": 46, "end_pos": 67, "type": "TASK", "confidence": 0.7974819168448448}]}, {"text": "South Asian languages, such as Tamil and Hindi, also use writing systems that, while lacking the thousands of characters as in Chinese, are nonetheless challenging for direct typing (particularly on mobile devices), and hence are frequently entered using the Latin alphabet.", "labels": [], "entities": []}, {"text": "In those languages, however, unlike Chinese, there is no single system that is used for romanization, rather individuals typically provide a rough phonetic transcription of the words in the Latin script.", "labels": [], "entities": []}, {"text": "The use of pinyin for Chinese is generally part of a system for converting the text into the native script, and this can also be achieved for keyboards in South Asian languages (.", "labels": [], "entities": []}, {"text": "However, for these languages, many individuals prefer to simply leave the text in the Latin script rather than converting to the native script.", "labels": [], "entities": []}, {"text": "To provide full mobile keyboard functionality in such a scenario -including, e.g., word prediction and completion, and automatic correction of so-called fat finger errors in typing -language model support must be provided.", "labels": [], "entities": [{"text": "word prediction and completion", "start_pos": 83, "end_pos": 113, "type": "TASK", "confidence": 0.7590755820274353}]}, {"text": "Yet in the absence of a standard orthography, encoding word-to-word dependencies becomes more complicated, since there maybe many possible versions of any given word.", "labels": [], "entities": [{"text": "encoding word-to-word dependencies", "start_pos": 46, "end_pos": 80, "type": "TASK", "confidence": 0.8031595945358276}]}, {"text": "In this paper, we examine a few practical alternatives to address the lack of a conventionalized Latin script orthography for use in a finite-state keyboard decoder.", "labels": [], "entities": []}, {"text": "We use several different transducers that normalize input romanizations to either a native script word form or a \"canonical\" Latin script form 1 in order to combine with a word-based language model.", "labels": [], "entities": []}, {"text": "To produce Latin script after this normalization, we must produce text from the input tape of these transducers.", "labels": [], "entities": []}, {"text": "We also present an alternative method involving a compact representation of a large supplementary lexicon that covers highly likely romanizations of invocabulary words.", "labels": [], "entities": []}, {"text": "All of these methods provide accuracy improvements over the baseline (fixed vocabulary) method.", "labels": [], "entities": [{"text": "accuracy", "start_pos": 29, "end_pos": 37, "type": "METRIC", "confidence": 0.9986988306045532}]}, {"text": "In the next section, we give some background on the problem before outlining our new methods.", "labels": [], "entities": []}, {"text": "We then present experimental results of keyboard entry simulation for Hindi, in which we demonstrate over 50% relative reduction in error rate 2 over existing baselines.", "labels": [], "entities": [{"text": "keyboard entry", "start_pos": 40, "end_pos": 54, "type": "TASK", "confidence": 0.6964535415172577}, {"text": "error rate", "start_pos": 132, "end_pos": 142, "type": "METRIC", "confidence": 0.8984241783618927}]}], "datasetContent": [{"text": "To evaluate our methods, we simulate touch points of a tapping keyboard as follows.", "labels": [], "entities": []}, {"text": "For each symbol in the (Latin script) input strings, we sample a touch point from Gaussian distributions in two dimensions, with mean value at the center of the key.", "labels": [], "entities": []}, {"text": "To establish how much noise is introduced by this method, we evaluate the error rate of simply emitting the literal sequence, i.e., the symbols associated with the keys that our noisy touch points actually fall within.", "labels": [], "entities": [{"text": "error rate", "start_pos": 74, "end_pos": 84, "type": "METRIC", "confidence": 0.9444526433944702}]}, {"text": "Improvements over the literal baseline are due to decoder auto-correction.", "labels": [], "entities": []}, {"text": "The resulting touchpoints are then fed into the decoder under each of our conditions, and the strings output from the decoder are then compared with the original text strings, which are taken to be the intended strings.", "labels": [], "entities": []}, {"text": "As mentioned elsewhere in the paper, the goal is to allow users to type their intended strings, without normalizing away their versions of the romanized words.", "labels": [], "entities": []}, {"text": "Thus we measure word-error rate versus the reference version in the romanized string.", "labels": [], "entities": []}, {"text": "Note that the keyboard decoder has various meta-parameters that can impact, e.g., the speed-accuracy trade-off.", "labels": [], "entities": []}, {"text": "In addition to sweeping over such parameters fora given method, as shown in, we compare performance across the methods at comparable operating points (in terms of average milliseconds per character) in Tables 1a and 1b.", "labels": [], "entities": []}, {"text": "Note that the absolute numerical values of the latencies are not meaningful, just the comparisons between the latencies.", "labels": [], "entities": []}, {"text": "As discussed in and mentioned earlier, latencies must below enough that no lag in keyboard responsiveness is perceived, and target values on device are often around 20ms per tap.", "labels": [], "entities": []}, {"text": "However this must be the case also for inexpensive devices with low processing power, and the decision to deploy a model would depend on device trials.", "labels": [], "entities": []}, {"text": "For the purposes of this paper, however, we just report values on a single device that can be used for comparison purposes.", "labels": [], "entities": []}, {"text": "The operating points chosen for the Tables are two that are plausible candidates for use on such inexpensive devices.", "labels": [], "entities": []}], "tableCaptions": [{"text": " Table 1: The word error rate for the decoding of noisy touchpoints into Latin script strings at two operating", "labels": [], "entities": [{"text": "word error rate", "start_pos": 14, "end_pos": 29, "type": "METRIC", "confidence": 0.6691231528917948}]}]}