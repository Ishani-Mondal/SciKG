{"title": [{"text": "Bottom-Up Unranked Tree-to-Graph Transducers for Translation into Semantic Graphs", "labels": [], "entities": [{"text": "Translation into Semantic Graphs", "start_pos": 49, "end_pos": 81, "type": "TASK", "confidence": 0.8602459877729416}]}], "abstractContent": [{"text": "We propose a formal model for translating unranked syntactic trees, such as dependency trees, into semantic graphs.", "labels": [], "entities": []}, {"text": "These tree-to-graph transducers can serve as a formal basis of transition systems for semantic parsing which recently have been shown to perform very well, yet hitherto lack formalization.", "labels": [], "entities": [{"text": "semantic parsing", "start_pos": 86, "end_pos": 102, "type": "TASK", "confidence": 0.7739577293395996}]}, {"text": "Our model features \"extended\" rules and an arc-factored normal form, comes with an efficient translation algorithm, and can be equipped with weights in a straightforward manner.", "labels": [], "entities": []}], "introductionContent": [{"text": "In dependency semantic parsing, one is given a natural language sentence and has to output a directed graph representing an associated, mostlikely semantic analysis.", "labels": [], "entities": [{"text": "dependency semantic parsing", "start_pos": 3, "end_pos": 30, "type": "TASK", "confidence": 0.8119622468948364}]}, {"text": "Semantic parsing integrates tasks that have usually been addressed separately in statistical natural language processing, such as named entity recognition, word sense disambiguation, semantic role labeling, and coreference resolution.", "labels": [], "entities": [{"text": "Semantic parsing", "start_pos": 0, "end_pos": 16, "type": "TASK", "confidence": 0.8532894551753998}, {"text": "named entity recognition", "start_pos": 130, "end_pos": 154, "type": "TASK", "confidence": 0.6174751420815786}, {"text": "word sense disambiguation", "start_pos": 156, "end_pos": 181, "type": "TASK", "confidence": 0.6873487631479899}, {"text": "semantic role labeling", "start_pos": 183, "end_pos": 205, "type": "TASK", "confidence": 0.6595805883407593}, {"text": "coreference resolution", "start_pos": 211, "end_pos": 233, "type": "TASK", "confidence": 0.9578951895236969}]}, {"text": "Semantic parsing is currently receiving considerable attention, as attested by the number of approaches being proposed for its solution ( and by the variety of existing semantic representations and available datasets (.", "labels": [], "entities": [{"text": "Semantic parsing", "start_pos": 0, "end_pos": 16, "type": "TASK", "confidence": 0.859291136264801}]}, {"text": "A successful approach to dependency semantic parsing by first parses the input sentence into a dependency tree t, and then applies a transition-based algorithm that translates t into a dependency graph in Abstract Meaning Representation (AMR), a popular semantic representation developed by.", "labels": [], "entities": [{"text": "dependency semantic parsing", "start_pos": 25, "end_pos": 52, "type": "TASK", "confidence": 0.8691241145133972}, {"text": "Abstract Meaning Representation (AMR)", "start_pos": 205, "end_pos": 242, "type": "TASK", "confidence": 0.7467249681552252}]}, {"text": "In this work, we present a finite-state transducer for tree-to-graph translation that can serve as a mathematical model for transition-based systems such as the one by and, more in general, for work on the syntax-semantics interface.", "labels": [], "entities": []}, {"text": "Bottom-up tree transducers) have gained significant attention in the field of machine translation, where they are used to map syntactic phrase structure trees from source to target languages.", "labels": [], "entities": [{"text": "machine translation", "start_pos": 78, "end_pos": 97, "type": "TASK", "confidence": 0.7971795201301575}]}, {"text": "This holds in particular for their \"extended\" version, which may process, in a single step, sections of the input consisting of several symbols; see () and references therein.", "labels": [], "entities": []}, {"text": "We propose a similar formalism for dependency semantic parsing, mapping syntactic dependency trees into directed graphs that represent the associated semantic interpretation.", "labels": [], "entities": [{"text": "dependency semantic parsing", "start_pos": 35, "end_pos": 62, "type": "TASK", "confidence": 0.8309690157572428}]}, {"text": "When translating dependency trees into graphs in a bottom-up fashion, we face two problems.", "labels": [], "entities": []}, {"text": "Firstly, bottom-up tree transducers process ranked trees, i.e., the number of children at each node is bounded by some constant.", "labels": [], "entities": []}, {"text": "Thus, typically, these tree transducers use a single rule to process in one shot anode along with all of its (previously processed) children in the source tree.", "labels": [], "entities": []}, {"text": "In contrast, in the case of dependency trees there is no global constant that limits the number of children anode may have, and processing all of the children by means of a single rule is problematic.", "labels": [], "entities": []}, {"text": "Secondly, in an output tree of a bottom-up tree transducer, nodes that are located near one another are translations of nodes in a source tree that are in close proximity as well.", "labels": [], "entities": []}, {"text": "This condition is often referred to as locality.", "labels": [], "entities": []}, {"text": "Locality does no longer hold true when translating trees into graphs.", "labels": [], "entities": []}, {"text": "In fact, so-called reentrancy nodes in a graph have several parents, which are translations of nodes in the source tree whose distance from one another may not be bounded by a constant.", "labels": [], "entities": []}, {"text": "Reentrancies thus require some form of nonlocal processing, generally not found in tree transducers.", "labels": [], "entities": []}, {"text": "The main contribution of this work is a finitestate tree-to-graph transducer that processes dependency trees in a bottom-up, left-to-right fashion.", "labels": [], "entities": []}, {"text": "Our solution to the two problems mentioned above is rather simple.", "labels": [], "entities": []}, {"text": "Each node is processed together with its children in several translation steps which consume the children left to right.", "labels": [], "entities": []}, {"text": "Furthermore, in order to implement reentrancy, each translated subtree produces a graph annotated with a record of selected vertices, to be made accessible later in the translation process.", "labels": [], "entities": []}, {"text": "While our transducers use extended translation rules in the sense of, they can be cast in a simple normal form, facilitating algorithmic processing.", "labels": [], "entities": []}, {"text": "We provide a polynomial time algorithm for translating an input dependency tree into a packed graph forest, from which each translation graph can efficiently be recovered.", "labels": [], "entities": []}, {"text": "Bottom-up tree-to-graph transducers were introduced by) who based their work on hyperedge replacement.", "labels": [], "entities": [{"text": "hyperedge replacement", "start_pos": 80, "end_pos": 101, "type": "TASK", "confidence": 0.7837818264961243}]}, {"text": "Since the graph construction mechanism we use is equivalent to hyperedge replacement, our notion of tree-to-graph transducers is essentially an unranked and extended generalization of theirs, except for the fact that ours cannot create multiple copies of unbounded material in the input.", "labels": [], "entities": [{"text": "hyperedge replacement", "start_pos": 63, "end_pos": 84, "type": "TASK", "confidence": 0.7604356408119202}]}, {"text": "This ability seems inappropriate for modeling natural language semantics.", "labels": [], "entities": []}, {"text": "The system by has inspired our work.", "labels": [], "entities": []}, {"text": "A technical comparison between their formalism and ours is made in Remark 1.", "labels": [], "entities": [{"text": "Remark 1", "start_pos": 67, "end_pos": 75, "type": "DATASET", "confidence": 0.8712922930717468}]}, {"text": "An alternative approach to the syntax-semantics interface exploits multi-component synchronous tree-adjoining grammars; see and references therein.", "labels": [], "entities": []}, {"text": "However, these formal models yield tree-like semantic representations, as opposed to general graphs.", "labels": [], "entities": []}, {"text": "A common approach in semantic parsing is to extend existing syntactic dependency parsers to produce graphs, realizing translation models from strings to graphs, as opposed to the treeto-graph model investigated here.", "labels": [], "entities": [{"text": "semantic parsing", "start_pos": 21, "end_pos": 37, "type": "TASK", "confidence": 0.7598934471607208}]}, {"text": "On this line, transition-based, greedy parsers have been adapted by,,, and.", "labels": [], "entities": []}, {"text": "Despite the fact that the input is a bare string, these systems exploit features obtained from a precomputed run of a dependency parser, thus committing to some best parse tree, similarly to the pipeline model of.", "labels": [], "entities": []}, {"text": "Dynamic programming parsers have also been adapted to produce graphs by and.", "labels": [], "entities": []}, {"text": "Semantic translation from strings to graphs is further investigated by and using synchronous hyperedge replacement grammars, who provide unsupervised learning algorithms for grammar extraction.", "labels": [], "entities": [{"text": "Semantic translation from strings to graphs", "start_pos": 0, "end_pos": 43, "type": "TASK", "confidence": 0.8545385698477427}, {"text": "grammar extraction", "start_pos": 174, "end_pos": 192, "type": "TASK", "confidence": 0.7486670315265656}]}, {"text": "Finally, use a neural supertag parser to map a string into a dependency-style tree representation of the compositional structure of the corresponding AMR graph.", "labels": [], "entities": []}, {"text": "More precisely, this tree is a term in a special algebra: its constants denote lexicalized AMR graph fragments, which are combined into larger and larger AMR graphs by two binary algebraic operations for graph combination.", "labels": [], "entities": []}, {"text": "These operations supply a partial AMR graph either with an argument or with a modifier.", "labels": [], "entities": []}, {"text": "The evaluation of the term then yields the output AMR for the input sentence.", "labels": [], "entities": [{"text": "AMR", "start_pos": 50, "end_pos": 53, "type": "METRIC", "confidence": 0.8377208113670349}]}, {"text": "The tree-to-graph mapping is entirely deterministic, in contrast to our approach.", "labels": [], "entities": []}, {"text": "also provide an unsupervised alignment algorithm that extracts rules from semantic graph banks.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": []}