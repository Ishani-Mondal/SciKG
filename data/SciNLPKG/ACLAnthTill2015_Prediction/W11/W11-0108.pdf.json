{"title": [{"text": "Modular Graph Rewriting to Compute Semantics", "labels": [], "entities": [{"text": "Modular Graph Rewriting", "start_pos": 0, "end_pos": 23, "type": "TASK", "confidence": 0.6681968768437704}]}], "abstractContent": [{"text": "Taking an asynchronous perspective on the syntax-semantics interface, we propose to use modular graph rewriting systems as the model of computation.", "labels": [], "entities": []}, {"text": "We formally define them and demonstrate their use with a set of modules which produce underspecified semantic representations from a syntactic dependency graph.", "labels": [], "entities": []}, {"text": "We experimentally validate this approach on a set of sentences.", "labels": [], "entities": []}, {"text": "The results open the way for the production of underspecified semantic dependency structures from corpora annotated with syntactic dependencies and, more generally, fora broader use of modular rewriting systems for computational linguistics.", "labels": [], "entities": []}], "introductionContent": [{"text": "The aim of our work is to produce a semantic representation of sentences on a large scale using a formal and exact approach based on linguistic knowledge.", "labels": [], "entities": []}, {"text": "In this perspective, the design of the syntax-semantics interface is crucial.", "labels": [], "entities": []}, {"text": "Based on the compositionality principle, most models of the syntax-semantics interface use asynchronous approach: the semantic representation of a sentence is built step by step in parallel with its syntactic structure.", "labels": [], "entities": []}, {"text": "According to the choice of the syntactic formalism, this approach is implemented in different ways: in a Context-Free Grammars (CFG) style framework, every syntactic rule of a grammar is associated with a semantic composition rule, as in the classical textbook by; following the principles introduced by Montague, Categorial Grammars use an homomorphism from the syntax to the semantics).", "labels": [], "entities": []}, {"text": "HPSG integrates the semantic and syntactic representations in feature structures which combine by unification ().", "labels": [], "entities": [{"text": "HPSG", "start_pos": 0, "end_pos": 4, "type": "DATASET", "confidence": 0.8932912945747375}]}, {"text": "LFG follows a similar principle ().", "labels": [], "entities": [{"text": "LFG", "start_pos": 0, "end_pos": 3, "type": "DATASET", "confidence": 0.9478425979614258}]}, {"text": "Ina synchronous approach, the syntax-semantics interface closely depends on the grammatical formalism.", "labels": [], "entities": []}, {"text": "Building such an interface can be very costly, especially if we aim at a large coverage for the grammar.", "labels": [], "entities": []}, {"text": "In our work, we have chosen an asynchronous approach in the sense that we start from a given syntactic analysis of a sentence to produce a semantic representation.", "labels": [], "entities": []}, {"text": "With respect to the synchronous approach, a drawback is that the reaction of the semantics on the syntax is delayed.", "labels": [], "entities": []}, {"text": "On the other hand, the computation of the semantics is made relatively independent from the syntactic formalism.", "labels": [], "entities": []}, {"text": "The only constraint is the shape of the output of the syntactic analysis.", "labels": [], "entities": []}, {"text": "In the formalisms mentioned above, the syntactic structure most often takes the form of a phrase structure, but the choice of constituency for the syntax makes the relationship with the semantics more complicated.", "labels": [], "entities": []}, {"text": "We have chosen dependency graphs, because syntactic dependencies are closely related to predicate-argument relations.", "labels": [], "entities": []}, {"text": "Moreover, they can be enriched with relations derived from the syntax, which are usually ignored, such as the arguments of infinitives or the anaphora determined by the syntax.", "labels": [], "entities": []}, {"text": "One may observe that our syntactic representation of sentences involves plain graphs and not trees.", "labels": [], "entities": []}, {"text": "Indeed, these relations can give rise to multiple governors and dependency cycles.", "labels": [], "entities": []}, {"text": "On the semantic side, we have also chosen graphs, which are widely used in different formalisms and theories, such as DMRS () or MTT) . The principles being fixed, our problem was then to choose a model of computation well suited to transforming syntactic graphs into semantic graphs.", "labels": [], "entities": []}, {"text": "The \u03bb-calculus, which is widely used informal semantics, is not a good candidate because it is appropriate for computing on trees but not on graphs.", "labels": [], "entities": []}, {"text": "Our choice naturally went to graph rewriting.", "labels": [], "entities": [{"text": "graph rewriting", "start_pos": 29, "end_pos": 44, "type": "TASK", "confidence": 0.7471953332424164}]}, {"text": "Graph rewriting is barely used in computational linguistics; it could be due to the difficulty to manage large sets of rules.", "labels": [], "entities": [{"text": "Graph rewriting", "start_pos": 0, "end_pos": 15, "type": "TASK", "confidence": 0.8523662090301514}]}, {"text": "Among the pioneers in the use of graph rewriting, we mention;;; Jijkoun and de;;.", "labels": [], "entities": [{"text": "graph rewriting", "start_pos": 33, "end_pos": 48, "type": "TASK", "confidence": 0.7103709876537323}]}, {"text": "A graph rewriting system is defined as a set of graph rewrite rules and a computation is a sequence of rewrite rule applications to a given graph.", "labels": [], "entities": []}, {"text": "The application of a rule is triggered via a mechanism of pattern matching, hence a sub-graph is isolated from its context and the result is a local modification of the input.", "labels": [], "entities": []}, {"text": "This allows a linguistic phenomenon to be easily isolated for applying a transformation.", "labels": [], "entities": []}, {"text": "Since each step of computation is fired by some local conditions in the whole graph, it is well known that one has no grip on the sequence of rewriting steps.", "labels": [], "entities": []}, {"text": "The more rules, the more interaction between rules, and the consistency of the whole rule system becomes difficult to maintain.", "labels": [], "entities": [{"text": "consistency", "start_pos": 60, "end_pos": 71, "type": "METRIC", "confidence": 0.996037483215332}]}, {"text": "This bothers our ambition of a large coverage for the grammar.", "labels": [], "entities": []}, {"text": "To solve this problem, we propose to organize rules in modules.", "labels": [], "entities": []}, {"text": "A module is a set of rules that is linguistically consistent and represents a particular step of the transformation.", "labels": [], "entities": []}, {"text": "For instance, in our proposal, there is a module transforming the syntactic arguments of verbs, predicative nouns and adjectives into their semantic arguments.", "labels": [], "entities": []}, {"text": "Another module resolves the anaphoric links which are internal to the sentence and determined by the syntax.", "labels": [], "entities": []}, {"text": "From a computational point of view, the grouping of a small number of rules inside a module allows some optimizations in their application, thus leading to efficiency.", "labels": [], "entities": []}, {"text": "For instance, the confluence of rewriting is a critical feature -one computes only one normal form, not all of them -for the performance of the program.", "labels": [], "entities": []}, {"text": "Since the underlying relation from syntax to semantics is not functional but relational, the system cannot be globally confluent.", "labels": [], "entities": []}, {"text": "Then, it is particularly interesting to isolate subsets of confluent rules.", "labels": [], "entities": []}, {"text": "Second point, with a small number of rules, one gets much more control on their output.", "labels": [], "entities": []}, {"text": "In particular, it is possible to automatically infer some invariant properties of graphs along the computation within a particular module.", "labels": [], "entities": []}, {"text": "Thus, it simplifies the writing of the rules for the next modules.", "labels": [], "entities": []}, {"text": "It is also possible to plan a strategy in the global evaluation process.", "labels": [], "entities": []}, {"text": "It is well known that syntactic parsers produce outputs in various formats.", "labels": [], "entities": []}, {"text": "As a by-product of our approach, we show that the choice of the input format (that is the syntax) seems to be of low importance overall.", "labels": [], "entities": []}, {"text": "Indeed, as far as two formats contain the same linguistic information with different representations, a system of rewrite rules can be designed to transform any graph from one format to another as a preliminary step.", "labels": [], "entities": []}, {"text": "The same remark holds for the output formats.", "labels": [], "entities": []}, {"text": "To illustrate our proposal, we have chosen the Paris7 TreeBank (hereafter P7TB) dependency format defined by  as the syntactic input format and the Dependency MRS format (hereafter DMRS) defined by as the semantic output format.", "labels": [], "entities": [{"text": "Paris7 TreeBank", "start_pos": 47, "end_pos": 62, "type": "DATASET", "confidence": 0.9920268058776855}]}, {"text": "We chose those two formats because the information they represent, if it is not complete, is relatively consensual and because both draw on large scale experiments: statistical dependency parsing for French 1 on the one hand and the DELPH-IN project 2 on the other hand.", "labels": [], "entities": [{"text": "statistical dependency parsing", "start_pos": 165, "end_pos": 195, "type": "TASK", "confidence": 0.6308805346488953}, {"text": "French 1", "start_pos": 200, "end_pos": 208, "type": "DATASET", "confidence": 0.9151946604251862}, {"text": "DELPH-IN project 2", "start_pos": 233, "end_pos": 251, "type": "DATASET", "confidence": 0.8409794966379801}]}, {"text": "Actually, in our experiments, since we do not have an appropriate corpus annotated according to the P7TB standard, we used our syntactic parser LEOPAR 3 whose outputs differ from this standard and we designed a rewriting system to go from one format to the other.", "labels": [], "entities": [{"text": "P7TB standard", "start_pos": 100, "end_pos": 113, "type": "DATASET", "confidence": 0.9485064744949341}]}, {"text": "The paper is organized as follows.", "labels": [], "entities": []}, {"text": "In section 1, we define our graph rewriting calculus, the \u03b2-calculus.", "labels": [], "entities": []}, {"text": "In Section 2, we describe the particular rewriting system that is used to transform graphs from the syntactic P7TB format into the DMRS semantic format.", "labels": [], "entities": []}, {"text": "In Section 3, we present experimental results on a test suite of sentences.", "labels": [], "entities": []}], "datasetContent": [{"text": "For the experimentation, we are interested in a test suite which is at the same time small enough to be manually validated and large enough to cover a rich variety of linguistic phenomena.", "labels": [], "entities": []}, {"text": "As said earlier, we use the P7 surface dependency format as input, so the first attempt at building a test suite is to consider examples in the guide which describes the format.", "labels": [], "entities": []}, {"text": "By nature, an annotation guide tries to cover a large range of phenomena with a small set of examples.", "labels": [], "entities": []}, {"text": "The latest version 4 of this guide ( ) contains 186 linguistic examples.", "labels": [], "entities": []}, {"text": "In our current implementation of the semantic constructions, we leave out clefts, coordinations and comparatives.", "labels": [], "entities": []}, {"text": "We also leave out a small set of exotic sentences for which we are notable to give a sensible syntactic structure.", "labels": [], "entities": []}, {"text": "Finally, our experiment runs on 116 French sentences.", "labels": [], "entities": []}, {"text": "Syntactic structures following P7 specifications are obtained with some graph rewriting on the output of our parser.", "labels": [], "entities": []}, {"text": "Each syntactic structure was manually checked and corrected when needed.", "labels": [], "entities": []}, {"text": "Then, graph rewriting with the modules described in the previous section is performed.", "labels": [], "entities": [{"text": "graph rewriting", "start_pos": 6, "end_pos": 21, "type": "TASK", "confidence": 0.7024157345294952}]}, {"text": "For all of these sentences, we produce at least one normal form.", "labels": [], "entities": []}, {"text": "Even if DMRS is underspecified, our system can output several semantic representations for one syntactic structure (for instance, for appositive and restrictive relative clauses).", "labels": [], "entities": []}, {"text": "We sometimes overgenerate because we do not use lexical information like the difference between scopal and non-scopal adverbs.", "labels": [], "entities": []}, {"text": "The result for three sentences is given below and the full set is available on a web page 5 . [", "labels": [], "entities": []}], "tableCaptions": []}