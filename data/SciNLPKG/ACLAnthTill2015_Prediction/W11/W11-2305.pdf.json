{"title": [{"text": "Asynchronous fixed-grid scanning with dynamic codes", "labels": [], "entities": [{"text": "Asynchronous fixed-grid scanning", "start_pos": 0, "end_pos": 32, "type": "TASK", "confidence": 0.6483573714892069}]}], "abstractContent": [{"text": "In this paper, we examine several methods for including dynamic, contextually-sensitive binary codes within indirect selection typing methods using a grid with fixed symbol positions.", "labels": [], "entities": []}, {"text": "Using Huffman codes derived from a character n-gram model, we investigate both synchronous (fixed latency highlighting) and asynchronous (self-paced using long versus short press) scanning.", "labels": [], "entities": []}, {"text": "Additionally, we look at methods that allow for scanning pasta target and returning to it versus methods that remove unselected items from consideration.", "labels": [], "entities": []}, {"text": "Finally , we investigate a novel method for displaying the binary codes for each symbol to the user, rather than using cell highlighting, as the means for identifying the required input sequence for the target symbol.", "labels": [], "entities": []}, {"text": "We demonstrate that dynamic coding methods for fixed position grids can be tailored for very diverse user requirements.", "labels": [], "entities": [{"text": "dynamic coding", "start_pos": 20, "end_pos": 34, "type": "TASK", "confidence": 0.6968382745981216}]}], "introductionContent": [{"text": "For many years, a key focus in Augmentative and Alternative Communication (AAC) has been providing text processing capabilities to those for whom direct selection of symbols on a keyboard (virtual or otherwise) is not a viable option.", "labels": [], "entities": [{"text": "Augmentative and Alternative Communication (AAC)", "start_pos": 31, "end_pos": 79, "type": "TASK", "confidence": 0.7535277349608285}]}, {"text": "In lieu of direct selection, a binary (yes/no) response can be given through any number of switches, including buttons or pads that are pressed with hand, head, or foot, eyeblink detectors, or other switches that can leverage whatever reliable movement is available.", "labels": [], "entities": []}, {"text": "These indirect selection methods typically involve systematically scanning through options and eliciting the binary yes/no response at each step of scanning.", "labels": [], "entities": []}, {"text": "For example, row/column scanning is a very common approach for indirect selection.", "labels": [], "entities": [{"text": "row/column scanning", "start_pos": 13, "end_pos": 32, "type": "TASK", "confidence": 0.6216324269771576}, {"text": "indirect selection", "start_pos": 63, "end_pos": 81, "type": "TASK", "confidence": 0.6528948545455933}]}, {"text": "Auto row/column scanning on a square grid, such as that shown in Figure 1, will highlight each row in turn for some fixed duration (dwell time); if the binary switch is triggered before the dwell time expires, the row is selected; otherwise the next row is highlighted.", "labels": [], "entities": []}, {"text": "Once a row is selected, cells in this row are then individually highlighted in turn, until one is selected, which identifies the intended character.", "labels": [], "entities": []}, {"text": "This sort of indirect selection method amounts to assigning a binary code to every symbol in the grid.", "labels": [], "entities": []}, {"text": "If triggering the switch (e.g., pressing a button or blinking) is taken as a 'yes' or 1, then its absence is taken as a 'no' or 0.", "labels": [], "entities": []}, {"text": "In such away, every letter in the grid has a binary code based on the scanning strategy.", "labels": [], "entities": []}, {"text": "For example, in, the letter 'n' is in the third row and fourth column; if row scanning starts at the top, it takes two 'no's and a 'yes' to select the correct row; and then three 'no's and a 'yes' to select the correct column.", "labels": [], "entities": [{"text": "row scanning", "start_pos": 74, "end_pos": 86, "type": "TASK", "confidence": 0.7033995240926743}]}, {"text": "This translates to a binary code of '0010001'.", "labels": [], "entities": []}, {"text": "In the preceding example, the codes for all symbols are determined by their position in the alphaordered grid.", "labels": [], "entities": []}, {"text": "However, faster input can be achieved by assigning shorter codes to likely symbols.", "labels": [], "entities": []}, {"text": "For example, imagine a user has just typed 'perso' and is ready to type the next letter.", "labels": [], "entities": []}, {"text": "In this context, the letter 'n' is quite likely in English, hence if a very short code is assigned to that letter (e.g., '01'), then the user requires only two actions (a 'no' and a 'yes') to produce the letter, rather than the 7 actions re- quired by the row/column code given above.", "labels": [], "entities": []}, {"text": "There are methods for assigning codes that minimize the expected code length fora given probability model.", "labels": [], "entities": []}, {"text": "The quality of the probability model used for deriving codes can make a large difference in the code length and hence in the efficiency of the input method.", "labels": [], "entities": []}, {"text": "When the model can accurately assign probabilities to symbols, the shortest binary codes can be assigned to the likeliest symbols, which thus require the fewest inputs (either yes or no) from the user.", "labels": [], "entities": []}, {"text": "The best probabilistic models will take into account what has already been typed to assign probability to each symbol.", "labels": [], "entities": []}, {"text": "The probabilities are contextually dependent, and therefore so are the optimal binary code assignments.", "labels": [], "entities": []}, {"text": "This was illustrated in the 'person' example provided earlier.", "labels": [], "entities": []}, {"text": "To provide another example, the probability of the letter 'u' is not particularly high overall in English (less than 0.02), but if the previously typed symbol is 'q', its probability is very high.", "labels": [], "entities": []}, {"text": "Thus, in many contexts, there are other letters that should get the shortest code, but in that particular context, following 'q', 'u' is very likely, hence it should receive the shortest code.", "labels": [], "entities": []}, {"text": "Common scanning methods, however, present a problem when trying to leverage contextually sensitive language models for efficient scanning.", "labels": [], "entities": []}, {"text": "In particular, methods of scanning that rely on highlighting contiguous regions -such as widely used row/column scanning -define their codes in terms of location in the grid, e.g., upper left-hand corner requires fewer keystrokes to select than lower right-hand corner using row/column scanning.", "labels": [], "entities": []}, {"text": "To improve the coding in such an approach requires moving characters to short-code regions of the grid.", "labels": [], "entities": []}, {"text": "In other words, with row/column scanning methods, the symbol needing the shortest code must move into the upper left-hand corner of the grid.", "labels": [], "entities": []}, {"text": "Yet the cognitive overhead of dealing with frequent grid reorganization is typically thought to outweigh any speedup that is achieved through more efficient coding (.", "labels": [], "entities": [{"text": "grid reorganization", "start_pos": 52, "end_pos": 71, "type": "TASK", "confidence": 0.7009297311306}]}, {"text": "If one assumes a fixed grid, i.e., no dynamic reorganization of the symbols, then row/column scanning can gain efficiency by placing frequent characters in the upper left-hand corner, but cannot use contextually informed models.", "labels": [], "entities": [{"text": "row/column scanning", "start_pos": 82, "end_pos": 101, "type": "TASK", "confidence": 0.6732579544186592}]}, {"text": "This is akin to Morse code, which assigns fixed codes to symbols based on overall frequency, without considering context., where two symbols in different rows and columns are jointly highlighted.", "labels": [], "entities": []}, {"text": "This approach, which we will term \"Huffman scanning\", allowed the binary codes to be optimized using Huffman coding methods (see Section 2.2) with respect to contextually sensitive language models without dynamic reorganization of the grid.", "labels": [], "entities": [{"text": "Huffman scanning", "start_pos": 35, "end_pos": 51, "type": "TASK", "confidence": 0.696198359131813}]}, {"text": "The method resulted in typing speedups over conventional row/column scanning.", "labels": [], "entities": []}, {"text": "One downside to the variable scanning that results from Huffman scanning is that users cannot anticipate their target symbol's binary code in any given context.", "labels": [], "entities": [{"text": "Huffman scanning", "start_pos": 56, "end_pos": 72, "type": "TASK", "confidence": 0.6426896750926971}]}, {"text": "In row/column scanning, the binary code of each symbol is immediately obvious from its location in the grid, hence users can anticipate when they will need to trigger the switch.", "labels": [], "entities": []}, {"text": "In Huffman scanning, users must continuously monitor and react when their target cells light up.", "labels": [], "entities": [{"text": "Huffman scanning", "start_pos": 3, "end_pos": 19, "type": "TASK", "confidence": 0.7140006721019745}]}, {"text": "The time required to allow for this motor reaction means that scan rates are typically slower than in row/column scanning; and stress levels -due to the demands of immediate response to highlighting -higher.", "labels": [], "entities": []}, {"text": "Huffman scanning is not the only way to allow variable coding on a fixed grid.", "labels": [], "entities": [{"text": "Huffman scanning", "start_pos": 0, "end_pos": 16, "type": "TASK", "confidence": 0.6991226524114609}]}, {"text": "In this paper, we investigate alternatives to Huffman scanning that also allow for efficient coding on a fixed grid.", "labels": [], "entities": [{"text": "Huffman scanning", "start_pos": 46, "end_pos": 62, "type": "TASK", "confidence": 0.7539931237697601}]}, {"text": "The three alternative methods that we investigate are asynchronous methods, i.e., all of the scanning is selfpaced; there is no scan rate that must be matched by the user.", "labels": [], "entities": []}, {"text": "The last of our alternative methods is a novel approach that displays the code for each symbol at once as a series of dots and dashes underneath the symbol -as used in Morse code -rather than using cell highlighting to prompt the user as in the other conditions.", "labels": [], "entities": []}, {"text": "Unlike Morse code, these codes are derived using Huffman coding based on n-gram language models, thus change with every context.", "labels": [], "entities": []}, {"text": "Since they are displayed for the user, no code memorization is required.", "labels": [], "entities": []}, {"text": "This novel interface differs from Huffman scanning in several ways, so we also present intermediate methods that differ in only one or another dimension, so that we can assess the impact of each characteristic.", "labels": [], "entities": [{"text": "Huffman scanning", "start_pos": 34, "end_pos": 50, "type": "TASK", "confidence": 0.6372998207807541}]}, {"text": "Our results show that displaying entire codes at once for asynchronous scanning was a popular and effective method for indirect selection, despite the fact that it shared certain dis-preferred characteristics with the least popular of our methods.", "labels": [], "entities": [{"text": "indirect selection", "start_pos": 119, "end_pos": 137, "type": "TASK", "confidence": 0.7825698554515839}]}, {"text": "This points the way to future work investigating methods to combine the preferred characteristics from our set of alternatives into a yet more effective interface.", "labels": [], "entities": []}], "datasetContent": [{"text": "We recruited 10 native English speaking subjects between the ages of 26 and 50 years, who are not users, we use the phrase set from to measure typing performance, and the same five strings from that set were used as evaluation strings in this study as in.", "labels": [], "entities": []}, {"text": "Practice strings were randomly selected from the rest of the phrase set.", "labels": [], "entities": []}, {"text": "Subjects used an Ablenet Jellybean R button as the binary switch.", "labels": [], "entities": [{"text": "Ablenet Jellybean R", "start_pos": 17, "end_pos": 36, "type": "DATASET", "confidence": 0.8293219804763794}]}, {"text": "The error rate parameter was fixed at 5% error rate.", "labels": [], "entities": [{"text": "error rate", "start_pos": 4, "end_pos": 14, "type": "METRIC", "confidence": 0.9764746427536011}, {"text": "error rate", "start_pos": 41, "end_pos": 51, "type": "METRIC", "confidence": 0.9694859385490417}]}, {"text": "The task in all conditions was to type the presented phrase exactly as it is presented.", "labels": [], "entities": []}, {"text": "Symbols that are typed in error -as shown in -must be repaired by selecting the delete symbol (\u2190) to delete the incorrect symbol, followed by the correct symbol.", "labels": [], "entities": []}, {"text": "The reported times and bits take into account the extra work required to repair errors.", "labels": [], "entities": []}, {"text": "We tested subjects under four conditions.", "labels": [], "entities": []}, {"text": "All four conditions made use of 8-gram character language models and Huffman coding, as described in Section 3.1, and an alpha-ordered grid.", "labels": [], "entities": []}, {"text": "The first condition is a replication of the Huffman scanning condition from, with the difference in scan rate (600ms versus mean 475ms in their paper) and the grid layout.", "labels": [], "entities": [{"text": "scan rate", "start_pos": 100, "end_pos": 109, "type": "METRIC", "confidence": 0.966311514377594}]}, {"text": "This is an auto scan approach, where the highlighting advances at the end of the dwell time, as described in Section 3.2.", "labels": [], "entities": []}, {"text": "The second condition is asynchronous scanning, i.e., replacing the dwell time with along button press as described in Section 3.3, but otherwise identical to condition 1.", "labels": [], "entities": []}, {"text": "The third condition was also asynchronous, but did not recompute the binary code after every bit, so that there is no return to characters eliminated from consideration, as described in Section 3.4, but otherwise identical to condition 2.", "labels": [], "entities": []}, {"text": "Finally, the fourth condition  displays the codes for each character as described in Section 3.5, without highlighting, but is otherwise identical to condition 3.", "labels": [], "entities": []}, {"text": "Subjects were given a brief demo of the four conditions by an author, then proceeded to a practice phase.", "labels": [], "entities": []}, {"text": "Practice phrases were given in each of the four conditions, until subjects reached sufficient proficiency in the method to type a phrase with fewer than 10% errors.", "labels": [], "entities": []}, {"text": "After the practice phases in all four conditions were completed, the test phases commenced.", "labels": [], "entities": []}, {"text": "The ordering of the conditions in the test phase was random.", "labels": [], "entities": []}, {"text": "Subjects again practiced in a condition until they typed a phrase with fewer than 10% errors, and then were presented with the five test strings in that condition.", "labels": [], "entities": []}, {"text": "After completion of the test phase fora condition, they were prompted to fill out a short survey about the condition.", "labels": [], "entities": []}, {"text": "presents means and standard deviations across our subjects for characters per minute, bits per character, error rate and what termed \"long code rate\", i.e., percentage of symbols that were correctly selected after being scanned past.", "labels": [], "entities": [{"text": "error rate", "start_pos": 106, "end_pos": 116, "type": "METRIC", "confidence": 0.9480267465114594}, {"text": "long code rate", "start_pos": 134, "end_pos": 148, "type": "METRIC", "confidence": 0.8294914563496908}]}, {"text": "For condition 1, we also present the result for the same condition reported in.", "labels": [], "entities": []}, {"text": "Comparing the first two rows of that table, we can see that our subjects typed slightly faster than those reported in in condition 1, with fewer bits per character, mainly due to lower error rates and less scanning past targets.", "labels": [], "entities": []}, {"text": "This can be attributed to either the slower scanning speed or the alphabetic ordering of the grid (or both).", "labels": [], "entities": []}, {"text": "In any case, even with the slower scan rate, the overall speed is faster in this condition than what was reported in that paper.", "labels": [], "entities": [{"text": "speed", "start_pos": 57, "end_pos": 62, "type": "METRIC", "confidence": 0.981338620185852}]}, {"text": "The other three conditions are novel to this paper.", "labels": [], "entities": []}, {"text": "Moving from synchronous to asynchronous (with long press) but leaving everything else the same  (condition 2) leads to slower typing speed but fewer bits per character.", "labels": [], "entities": []}, {"text": "The error rate is higher than in the synchronous condition 1, but there is less scanning past the target symbol.", "labels": [], "entities": [{"text": "error rate", "start_pos": 4, "end_pos": 14, "type": "METRIC", "confidence": 0.9871619343757629}]}, {"text": "In discussion with subjects, the higher error rate might be attributed to losing track of which button press (short or long) goes with highlighting, or also to intended short presses being registered by the system as long.", "labels": [], "entities": [{"text": "error rate", "start_pos": 40, "end_pos": 50, "type": "METRIC", "confidence": 0.9816907048225403}]}, {"text": "The final two conditions allow no return to characters once they have been scanned past, hence the \"long code rates\" go to zero, and the error rates increase.", "labels": [], "entities": []}, {"text": "Note that the optimal bits per character are slightly better than in the other trials, as mentioned in Section 3.4, yet the subject bits per character stay mostly the same as with condition 2.", "labels": [], "entities": []}, {"text": "Typing speed is slower in these two conditions, though slightly higher when the codes are displayed versus the use of highlighting.", "labels": [], "entities": [{"text": "Typing speed", "start_pos": 0, "end_pos": 12, "type": "METRIC", "confidence": 0.8528102934360504}]}, {"text": "In we present the mean Likert scores from the survey.", "labels": [], "entities": []}, {"text": "The four statements that subjects assessed were: The results in show high frustration and stress with condition 3, and much lower fatigue, stress and frustration (hence higher 'liking') for condition 4, where the codes are displayed.", "labels": [], "entities": []}, {"text": "Overall, there seemed to be a preference for Huffman synchronous, followed by displaying the codes.", "labels": [], "entities": []}], "tableCaptions": [{"text": " Table 1: Typing results for 10 users on 5 test strings (total 31 words, 145 characters) under 4 conditions.", "labels": [], "entities": [{"text": "Typing", "start_pos": 10, "end_pos": 16, "type": "TASK", "confidence": 0.928879976272583}]}, {"text": " Table 2: Mean Likert scores to survey questions (5 = a  lot; 1 = not at all)", "labels": [], "entities": []}]}