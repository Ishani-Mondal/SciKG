{"title": [{"text": "Constraint Grammar parsing with left and right sequential finite transducers", "labels": [], "entities": [{"text": "Constraint Grammar parsing", "start_pos": 0, "end_pos": 26, "type": "TASK", "confidence": 0.6267211039861044}]}], "abstractContent": [{"text": "We propose an approach to parsing Constraint Grammars using finite-state transducers and report on a compiler that converts Constraint Grammar rules into transducer representations.", "labels": [], "entities": [{"text": "parsing Constraint Grammars", "start_pos": 26, "end_pos": 53, "type": "TASK", "confidence": 0.8401204546292623}]}, {"text": "The resulting transducers are further optimized by conversion to left and right sequential transducers.", "labels": [], "entities": []}, {"text": "Using the method, we show that we can improve on the worst-case asymptotic bound of Constraint Grammar parsing from cubic to quadratic in the length of input sentences.", "labels": [], "entities": [{"text": "Constraint Grammar parsing", "start_pos": 84, "end_pos": 110, "type": "TASK", "confidence": 0.9181910355885824}]}], "introductionContent": [{"text": "The Constraint Grammar (CG) paradigm) is a popular formalism for performing partof-speech disambiguation, surface syntactic tagging, and certain forms of dependency analysis.", "labels": [], "entities": [{"text": "partof-speech disambiguation", "start_pos": 76, "end_pos": 104, "type": "TASK", "confidence": 0.763026773929596}, {"text": "surface syntactic tagging", "start_pos": 106, "end_pos": 131, "type": "TASK", "confidence": 0.6674769520759583}, {"text": "dependency analysis", "start_pos": 154, "end_pos": 173, "type": "TASK", "confidence": 0.7985057532787323}]}, {"text": "A CG is a collection of hand-written disambiguation rules for part-of-speech or syntactic functions.", "labels": [], "entities": []}, {"text": "The popularity of CGs is explained by a few factors.", "labels": [], "entities": []}, {"text": "They typically achieve quite high F-measures on unrestricted text, especially for free word-order languages (.", "labels": [], "entities": [{"text": "F-measures", "start_pos": 34, "end_pos": 44, "type": "METRIC", "confidence": 0.9990909099578857}]}, {"text": "Constraint Grammars can also be developed by linguists rather quickly, even for languages that have only meager resources available as regards tagged or parsed corpora, although it is hard to come by exact measures of how much effort development requires.", "labels": [], "entities": [{"text": "Constraint Grammars", "start_pos": 0, "end_pos": 19, "type": "TASK", "confidence": 0.792951226234436}]}, {"text": "One drawback to using CG, however, is that applying one to disambiguate input text tends to be very slow: for example, the Apertium project (), which offers the option of using both n-gram models and CG (by way of the vislcg3 compiler), reports that using n-gram models currently results in ten times faster operation, although at the cost of a loss inaccuracy.", "labels": [], "entities": []}, {"text": "In this paper, we describe a process of compiling individual CG rules into finite-state transducers (FSTs) that perform the corresponding disambiguation task on an ambiguous input sentence.", "labels": [], "entities": []}, {"text": "Using this approach, we can improve the worst-case running time of a CG parser to quadratic in the length of a sentence, down from the cubic time requirement reported earlier).", "labels": [], "entities": []}, {"text": "The method presented here implements faithfully all the operations allowed in the CG-2 system documented in.", "labels": [], "entities": []}, {"text": "The same approach can be used for various extensions and variants of the Constraint Grammar paradigm.", "labels": [], "entities": [{"text": "Constraint Grammar paradigm", "start_pos": 73, "end_pos": 100, "type": "TASK", "confidence": 0.7914924820264181}]}, {"text": "The idea of representing CG rules as FSTs has been suggested before, but to our knowledge this implementation represents the first time the idea has been tried in practice.", "labels": [], "entities": []}, {"text": "We also show that after compiling a collection of CG rules into their equivalent FSTs, the individual transducers can further be converted into left and right sequential transducers which greatly improves the speed of application of a rule.", "labels": [], "entities": []}, {"text": "In the following, we give a brief overview of the CG formalism, discuss previous work and CG parsers, provide an account of our method, and finally report on some practical experiments in compiling large-scale grammars into FSTs with our CGrule-to-transducer compiler.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": [{"text": " Table 1: Example sizes (number of states) of single rules  of varying left and right scope represented as transduc- ers, both individually and as separate left-sequential and  right-sequential transducers. The |T | represents the size  of the single transducer, and the |B|-columns the sums of  the sizes of the LR-sequential ones.", "labels": [], "entities": []}, {"text": " Table 2: Sums of sizes of resulting transducers with two  large-scale grammars.", "labels": [], "entities": [{"text": "Sums", "start_pos": 10, "end_pos": 14, "type": "TASK", "confidence": 0.9901170134544373}]}]}