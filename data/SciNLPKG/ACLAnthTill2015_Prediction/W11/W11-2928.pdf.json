{"title": [{"text": "Parsing of Partially Bracketed Structures for Parse Selection", "labels": [], "entities": [{"text": "Parse Selection", "start_pos": 46, "end_pos": 61, "type": "TASK", "confidence": 0.9353682398796082}]}], "abstractContent": [{"text": "We consider the problem of parsing a sentence that is partially annotated with information about where phrases start and end.", "labels": [], "entities": [{"text": "parsing a sentence", "start_pos": 27, "end_pos": 45, "type": "TASK", "confidence": 0.8567938804626465}]}, {"text": "The application domain is interactive parse selection with probabilistic grammars.", "labels": [], "entities": [{"text": "interactive parse selection", "start_pos": 26, "end_pos": 53, "type": "TASK", "confidence": 0.66527192791303}]}, {"text": "It is explained that the main obstacle is spurious ambiguity.", "labels": [], "entities": []}, {"text": "The proposed solution is first described in terms of appropriately constrained synchronous grammars, and then in terms of a computational model for parsing.", "labels": [], "entities": []}, {"text": "Experiments show the feasibility fora practical grammar.", "labels": [], "entities": []}], "introductionContent": [{"text": "In interactive parse selection, the objective is to obtain correct parses of sentences in a corpus, by means of an iterative process, alternately drawing upon a language model and human linguistic judgement.", "labels": [], "entities": [{"text": "interactive parse selection", "start_pos": 3, "end_pos": 30, "type": "TASK", "confidence": 0.6703972220420837}]}, {"text": "Ina first step, the most likely parse is computed on the basis of the model.", "labels": [], "entities": []}, {"text": "This parse is displayed to the human annotator, who looks for possible errors and enters corrections.", "labels": [], "entities": [{"text": "corrections", "start_pos": 89, "end_pos": 100, "type": "METRIC", "confidence": 0.9385568499565125}]}, {"text": "Each correction takes the form of an occurrence of a phrase that the parse should contain.", "labels": [], "entities": []}, {"text": "The model is then consulted anew, to recompute the most likely parse, but now under the constraint that all occurrences of phrases entered previously by the linguist must be included.", "labels": [], "entities": []}, {"text": "This process is repeated until no more errors remain.", "labels": [], "entities": []}, {"text": "Applications can be found in creation of treebanks) and computer-assisted translation.", "labels": [], "entities": [{"text": "computer-assisted translation", "start_pos": 56, "end_pos": 85, "type": "TASK", "confidence": 0.6327091157436371}]}, {"text": "Apart from the exact language model used in the process, there are various ways to implement interactive parse selection.", "labels": [], "entities": [{"text": "parse selection", "start_pos": 105, "end_pos": 120, "type": "TASK", "confidence": 0.8190770149230957}]}, {"text": "One obvious approach is to demand that errors are corrected strictly from left to right.", "labels": [], "entities": []}, {"text": "That is, where the occurrence of a phrase is asserted by the annotator, it is implicitly assumed that all phrases in the latest proposed parse that are wholly contained in the preceding prefix are correct.", "labels": [], "entities": []}, {"text": "This means that these structures in a left-hand portion of the parse tree can no longer change in future iterations.", "labels": [], "entities": []}, {"text": "Another degree of freedom in the design of interactive parse selection is the exact information that the human annotator provides about occurrences of phrases.", "labels": [], "entities": [{"text": "interactive parse selection", "start_pos": 43, "end_pos": 70, "type": "TASK", "confidence": 0.6797638336817423}]}, {"text": "The most obvious choice would be a triple consisting of the beginning, the end, and the syntactic category ('noun phrase', 'prepositional phrase', etc.).", "labels": [], "entities": []}, {"text": "If desired, the category could be omitted or underspecified.", "labels": [], "entities": []}, {"text": "This approach has been implemented for example by.", "labels": [], "entities": []}, {"text": "The main motivation for interactive parse selection is that it saves the human annotator manual labour, by automatic prediction of at least parts of parses that very often are correct.", "labels": [], "entities": [{"text": "parse selection", "start_pos": 36, "end_pos": 51, "type": "TASK", "confidence": 0.8271437585353851}]}, {"text": "With the criterion of minimizing human effort, it not clear however that the optimal design of interactive parse selection is of the kind outlined above, with a strictly left-to-right strategy, and with specification of both the beginning and the end for each corrected phrase.", "labels": [], "entities": [{"text": "interactive parse selection", "start_pos": 95, "end_pos": 122, "type": "TASK", "confidence": 0.6660283406575521}]}, {"text": "One objection against the leftto-right strategy is that errors maybe temporarily overlooked.", "labels": [], "entities": []}, {"text": "Typical implementations may allow backtracking to deal with this situation, but backtracking entails that work needs to be redone.", "labels": [], "entities": []}, {"text": "One objection against having to specify the beginning as well as the end of a corrected phrase is firstly that this requires more mouse clicks or keyboard strokes than if, say, only the correct beginning of a phrase were specified.", "labels": [], "entities": []}, {"text": "Furthermore, for long and complex sentences, it maybe tedious to determine both phrase boundaries.", "labels": [], "entities": []}, {"text": "For these reasons we explore a less rigid alter-native, namely to allow the human annotator to specify only the beginning of a phrase, or only the end of a phrase.", "labels": [], "entities": []}, {"text": "This is formalized in the remainder of this paper as an unmatched open bracket, or an unmatched close bracket.", "labels": [], "entities": []}, {"text": "Such a bracket maybe labelled with a category or not.", "labels": [], "entities": []}, {"text": "Parse selection is not constrained to be unidirectional, and at each iteration, brackets can be placed at arbitrary positions in the input sentence, and thereupon the most likely parse is (re-)computed that is consistent with the provided brackets so far.", "labels": [], "entities": [{"text": "Parse selection", "start_pos": 0, "end_pos": 15, "type": "TASK", "confidence": 0.9488399922847748}]}, {"text": "In our notation, the unmatched brackets are written as square brackets.", "labels": [], "entities": []}, {"text": "We refer to them as 'unmatched' because the user need not specify both the beginning and end of a phrase.", "labels": [], "entities": []}, {"text": "However, users may specify both the beginning of a phrase and the end of the same phrase, by a square open and a square close bracket, if they so choose.", "labels": [], "entities": []}, {"text": "Next to unmatched brackets, we also allow matched brackets in the input, which in our notation are written as round brackets.", "labels": [], "entities": []}, {"text": "These must always occur in pairs of one open bracket and one close bracket, specified together by the user.", "labels": [], "entities": []}, {"text": "Unlike square brackets, pairs of round brackets must be properly nested.", "labels": [], "entities": []}, {"text": "As square brackets, round brackets maybe labelled by categories or maybe unlabelled.", "labels": [], "entities": []}, {"text": "Sentences enriched with matched and unmatched brackets will be called partially bracketed strings.", "labels": [], "entities": []}, {"text": "As we will informally illustrate in the following section, parsing of partially bracketed strings by context-free grammars causes particular problems.", "labels": [], "entities": [{"text": "parsing of partially bracketed strings", "start_pos": 59, "end_pos": 97, "type": "TASK", "confidence": 0.862276816368103}]}, {"text": "The main issue is spurious ambiguity, by which one input string maybe parsed in different ways all corresponding to one and the same parse tree by the input grammar.", "labels": [], "entities": []}, {"text": "Where the language model is used to compute the most likely parse, performance may suffer from having one computation computed in more than one way.", "labels": [], "entities": []}, {"text": "A more serious consequence is that computation of inside probabilities is hindered by subparses being represented more than once.", "labels": [], "entities": []}, {"text": "Also n-best parsing algorithms no longer work correctly without further refinements.", "labels": [], "entities": []}, {"text": "The main contribution of this article is to offer a solution to avoiding all spurious ambiguity.", "labels": [], "entities": []}, {"text": "Our theoretical framework is that of order-preserving synchronous context-free grammars, to be summarized in Section 3.", "labels": [], "entities": []}, {"text": "With this machinery, mappings between unbracketed, bracketed and partially bracketed strings will be presented in Section 4.", "labels": [], "entities": []}, {"text": "A sketch of a proof that spurious ambiguity is avoided as claimed is the subject of Section 5.", "labels": [], "entities": []}, {"text": "The actual parsing process, which is based on Earley's algorithm, is presented in Section 6.", "labels": [], "entities": [{"text": "parsing", "start_pos": 11, "end_pos": 18, "type": "TASK", "confidence": 0.9837421178817749}]}, {"text": "Section 7 discusses an implementation.", "labels": [], "entities": []}, {"text": "The practicality of our approach is demonstrated by experiments measuring running time.", "labels": [], "entities": []}, {"text": "In addition, some possible optimizations are proposed.", "labels": [], "entities": []}, {"text": "We end our paper with conclusions, in Section 8.", "labels": [], "entities": []}, {"text": "The issue of avoiding spurious ambiguity was considered before by).", "labels": [], "entities": [{"text": "avoiding spurious ambiguity", "start_pos": 13, "end_pos": 40, "type": "TASK", "confidence": 0.9005850354830424}]}, {"text": "Our treatment differs in that the solution is at the same time more precise, in terms of synchronous CFGs rather than grammar transformations, and more succinct, using simpler constraints on allowable structures.", "labels": [], "entities": []}, {"text": "Also novel is our parsing algorithm, which is versed towards practical application.", "labels": [], "entities": [{"text": "parsing", "start_pos": 18, "end_pos": 25, "type": "TASK", "confidence": 0.9792796969413757}]}, {"text": "Earlier work on partially bracketed strings, such as that by, has involved matching brackets only.", "labels": [], "entities": []}], "datasetContent": [{"text": "We have implemented the construction from Table 1 and the parsing algorithm from.", "labels": [], "entities": [{"text": "parsing", "start_pos": 58, "end_pos": 65, "type": "TASK", "confidence": 0.977077066898346}]}, {"text": "Our aim was to assess the feasibility in practical terms.", "labels": [], "entities": []}, {"text": "The latter algorithm was based on an implementation of the standard Earley algorithm, which we used as abase line.", "labels": [], "entities": []}, {"text": "The implementation language is C++ and the experiments were performed on a laptop computer with a 2.66 GHz Intel Core 2 Duo processor.", "labels": [], "entities": []}, {"text": "First, a context-free grammar was extracted from sections 2-21 of the Penn Treebank, with NoTransform and NoEmpties as in), and unary rules were collapsed.", "labels": [], "entities": [{"text": "Penn Treebank", "start_pos": 70, "end_pos": 83, "type": "DATASET", "confidence": 0.9821896255016327}]}, {"text": "This grammar has 84613 rules, 372 nonterminals and 44389 terminals (words).", "labels": [], "entities": []}, {"text": "With this grammar, we parsed the (unbracketed) sentences from section 23 that had length 10 or less.", "labels": [], "entities": []}, {"text": "Of these, 92 sentences were outside the language generated by the grammar and were discarded.", "labels": [], "entities": []}, {"text": "Parsing of the remaining 178 sentences using the standard Earley algorithm took 8m27s in total.", "labels": [], "entities": []}, {"text": "Next, we tried to construct a context-free grammar that generates partially bracketed sentences without spurious ambiguity, as the right-projection of the construction in.", "labels": [], "entities": []}, {"text": "Predictably, this was found to be infeasible for any but very small subsets of our input grammar, because of the exponential behaviour in the length of right-hand sides.", "labels": [], "entities": []}, {"text": "Lastly, the extended Earley algorithm from Table 2 was applied on the same 178 sentences, but now in partially bracketed form.", "labels": [], "entities": []}, {"text": "We started with the fully bracketed sentences, as they appear in Open Complete  the treebank, and then randomly omitted a varying percentage of brackets and category labels.", "labels": [], "entities": [{"text": "Open Complete  the treebank", "start_pos": 65, "end_pos": 92, "type": "DATASET", "confidence": 0.7919551730155945}]}, {"text": "This process of 'fuzzifying' a fully bracketed sentence proceeds in stages, with one potential step turning a bracket pair ( A ) A into [ A ] A . If this step does not happen, there is another potential step turning ( A ) A into ( ).", "labels": [], "entities": []}, {"text": "For each labelled square bracket individually, a step may remove the label, which is then optionally followed by a step removing the bracket altogether.", "labels": [], "entities": []}, {"text": "The process is parameterized with a value p, which expresses the probability that a step of fuzzifying does not happen.", "labels": [], "entities": []}, {"text": "Hence, p = 0 means that all annotation is removed and p = 1 means that all brackets and labels are kept.", "labels": [], "entities": []}, {"text": "The results are given in.", "labels": [], "entities": []}, {"text": "The first row of the table corresponds to the sentences in unannotated form.", "labels": [], "entities": []}, {"text": "The running time is higher than the baseline of the standard Earley algorithm.", "labels": [], "entities": []}, {"text": "This was to be expected, as there are some extra steps in, introduced for handling of brackets, and these steps are performed even if the input contains no brackets at all.", "labels": [], "entities": []}, {"text": "Nonetheless, the running time is of the same order of magnitude.", "labels": [], "entities": []}, {"text": "In the next few rows of the table we see that the running time increases further.", "labels": [], "entities": [{"text": "running time", "start_pos": 50, "end_pos": 62, "type": "METRIC", "confidence": 0.9527643322944641}]}, {"text": "Again, this is to be expected, as the presence of brackets induces multiple instances of parsing items where there would be only one in the unbracketed case.", "labels": [], "entities": [{"text": "parsing items", "start_pos": 89, "end_pos": 102, "type": "TASK", "confidence": 0.878941148519516}]}, {"text": "When close to 100 % of the brackets are maintained, the running time again decreases.", "labels": [], "entities": [{"text": "running time", "start_pos": 56, "end_pos": 68, "type": "METRIC", "confidence": 0.9677647650241852}]}, {"text": "This is because the brackets reduce ambiguity.", "labels": [], "entities": []}, {"text": "One may object that the parsing of fully bracketed sentences should take close to 0 seconds, as those sentences are already parsed.", "labels": [], "entities": [{"text": "parsing of fully bracketed sentences", "start_pos": 24, "end_pos": 60, "type": "TASK", "confidence": 0.8553772330284118}]}, {"text": "However, we have not introduced any further optimizations to the Earley algorithm apart from those presented in, and the predictive nature of the algorithm leads to many steps creating different partial analyses at an open bracket of which all but one is discarded upon finding the matching close bracket.", "labels": [], "entities": []}, {"text": "The main objective was to investigate to which extent parsing of partially bracketed structures is possible, under the constraint that no spurious ambiguity should arise.", "labels": [], "entities": [{"text": "parsing of partially bracketed structures", "start_pos": 54, "end_pos": 95, "type": "TASK", "confidence": 0.8687182188034057}]}, {"text": "Our experiments show that the running time is of the same order of magnitude as parsing of unbracketed strings using the standard Earley algorithm.", "labels": [], "entities": [{"text": "parsing of unbracketed strings", "start_pos": 80, "end_pos": 110, "type": "TASK", "confidence": 0.8485601097345352}]}, {"text": "Further refinements can be expected to reduce the running time.", "labels": [], "entities": []}, {"text": "For example, we found a straightforward optimization that is realized by letting parts of the check from condition (8) happen as soon as possible, rather than delaying them until completion of an item in  1 coming from the first member in the righthand side can be checked as soon as that first member is known.", "labels": [], "entities": []}, {"text": "This and other optimizations lead to a more involved formulation however, and for presentational reasons we abstain from further discussion.", "labels": [], "entities": []}, {"text": "Further note that the general ideas that led to starting from the construction in can as easily be used to derive other parsing algorithms for partially bracketed strings, using any other parsing strategy such as the bottom-up Earley algorithm and left-corner parsing ().", "labels": [], "entities": []}], "tableCaptions": [{"text": " Table 3: CPU time for recognition of sentences of  length \u2264 10 from section 23 of the Penn Treebank, for  a varying probability p.", "labels": [], "entities": [{"text": "CPU time", "start_pos": 10, "end_pos": 18, "type": "METRIC", "confidence": 0.893884003162384}, {"text": "recognition of sentences", "start_pos": 23, "end_pos": 47, "type": "TASK", "confidence": 0.8697410623232523}, {"text": "Penn Treebank", "start_pos": 87, "end_pos": 100, "type": "DATASET", "confidence": 0.9504843354225159}]}]}