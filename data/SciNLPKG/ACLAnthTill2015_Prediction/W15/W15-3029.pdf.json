{"title": [{"text": "Discontinuous Statistical Machine Translation with Target-Side Dependency Syntax", "labels": [], "entities": [{"text": "Discontinuous Statistical Machine Translation", "start_pos": 0, "end_pos": 45, "type": "TASK", "confidence": 0.6057074442505836}]}], "abstractContent": [{"text": "For several languages only potentially non-projective dependency parses are readily available.", "labels": [], "entities": []}, {"text": "Projectivizing the parses and utilizing them in syntax-based translation systems often yields particularly bad translation results indicating that those translation models cannot properly utilize such information.", "labels": [], "entities": []}, {"text": "We demonstrate that our system based on multi bottom-up tree transducers, which can natively handle discontinuities, can avoid the large translation quality deterioration, achieve the best performance of all classical syntax-based translation systems, and close the gap to phrase-based and hierarchical systems that do not utilize syntax.", "labels": [], "entities": []}], "introductionContent": [{"text": "Syntax-based machine translation, in which the transfer is achieved from and/or to the level of syntax, has become widely used in the statistical machine translation community (.", "labels": [], "entities": [{"text": "Syntax-based machine translation", "start_pos": 0, "end_pos": 32, "type": "TASK", "confidence": 0.6528328855832418}, {"text": "statistical machine translation", "start_pos": 134, "end_pos": 165, "type": "TASK", "confidence": 0.6400125424067179}]}, {"text": "Different grammar formalisms have been proposed and evaluated as translation models driving the translation systems.", "labels": [], "entities": []}, {"text": "We use a variant of the local multi bottom-up tree transducer as proposed by.", "labels": [], "entities": []}, {"text": "More precisely, we use a string-to-tree variant of it, which offers two immediate advantages: (i) The source side of the rules is a simple string containing terminal symbols and the unique non-terminal X.", "labels": [], "entities": []}, {"text": "Consequently, we do not need to match an input sentence parse, which allows additional flexibility.", "labels": [], "entities": []}, {"text": "It has been demonstrated that this flexibility in the input often yields improved translation quality.", "labels": [], "entities": []}, {"text": "(ii) The target language side offers discontinuities because rules can contain a sequence of target tree fragments instead of a singletree fragment.", "labels": [], "entities": []}, {"text": "These fragments are applied synchronously, which allows the model to synchronously develop discontinuous parts in the output (e.g., to realize agreement).", "labels": [], "entities": []}, {"text": "Overall, this translation model already proved to be useful when translating from English into German, Chinese, and Arabic as demonstrated by.", "labels": [], "entities": []}, {"text": "The goal of the current contribution is to adjust the approach and the system to Eastern European languages, for which we expect discontinuities to occur.", "labels": [], "entities": []}, {"text": "The existing system () cannot readily be applied since it requires constituent-like parses for the target side in our string-to-tree setting.", "labels": [], "entities": []}, {"text": "However, for the target languages discussed here (Polish and Russian), only dependency parses are readily available.", "labels": [], "entities": []}, {"text": "Those parses relate the lexical items of the sentence via edges that are labeled with the syntactic function between the head and its dependent.", "labels": [], "entities": []}, {"text": "Overall, these structures also form trees, but they are often non-projective for our target languages.", "labels": [], "entities": []}, {"text": "Such non-projective dependency trees do not admit a constituent-like tree representation, so we first need to convert them into projective dependency trees, which can be converted easily into a constituent-like tree representation.", "labels": [], "entities": []}, {"text": "The conversion into projective dependency trees is known to preserve discontinuities, so we expect that out model is an ideally suited syntax-based translation model for those target languages.", "labels": [], "entities": []}, {"text": "We evaluate our approach in 2 standard translation tasks translating from English to both Polish and Russian.", "labels": [], "entities": [{"text": "translation tasks translating from English", "start_pos": 39, "end_pos": 81, "type": "TASK", "confidence": 0.7766737699508667}]}, {"text": "Those two target languages have rather free word order, so we expect discontinuities to occur frequently.", "labels": [], "entities": []}, {"text": "For both languages, we use a (non-projective) dependency parser to obtain the required target trees, which we projectivize.", "labels": [], "entities": []}, {"text": "Indeed, we confirm that non-projective parses area frequent phenomenon in both languages.", "labels": [], "entities": [{"text": "non-projective parses", "start_pos": 24, "end_pos": 45, "type": "TASK", "confidence": 0.7589973211288452}]}, {"text": "We then train our translation model on the constituent-like parse trees obtained from the projective dependency trees and evaluate the obtained machine translation systems.", "labels": [], "entities": []}, {"text": "In both cases, our system significantly outperforms the string-totree syntax-based component of MOSES.", "labels": [], "entities": [{"text": "MOSES", "start_pos": 96, "end_pos": 101, "type": "DATASET", "confidence": 0.8599331974983215}]}, {"text": "To put our evaluation scores into perspective, we also report scores fora vanilla phrasebased system (), a GHKMbased system (), and a hierarchical phrase-based system.", "labels": [], "entities": []}, {"text": "It shows that our system suffers much less from the syntactic discontinuities and is thus much better suited for syntax-based translation systems in such settings.", "labels": [], "entities": []}], "datasetContent": [{"text": "We evaluate the MBOT-based system (see Section 4) on two translation tasks: English-to-Polish and English-to-Russian.", "labels": [], "entities": [{"text": "MBOT-based", "start_pos": 16, "end_pos": 26, "type": "DATASET", "confidence": 0.7130956649780273}]}, {"text": "For both target languages only (potentially) non-projective dependency parses are easily available.", "labels": [], "entities": []}, {"text": "Our goal is to evaluate whether the discontinuity offered by the MBOT model helps in tasks involving such dependency parses.", "labels": [], "entities": []}, {"text": "Consequently, the baseline system is the syntax-based component) of the MOSES toolkit (, which uses a translation model that only permits continuous rules.", "labels": [], "entities": [{"text": "MOSES toolkit", "start_pos": 72, "end_pos": 85, "type": "DATASET", "confidence": 0.890357106924057}]}, {"text": "Both systems are string-to-tree in the sense that the projectivized parses are only used on the target side.", "labels": [], "entities": []}, {"text": "As mentioned in Section 3, the non-projective parses are obtained using the MALT parser and then converted to constituentlike trees.", "labels": [], "entities": []}, {"text": "Glue-rules in both systems ensure that partial translation candidates can always be concatenated without any reordering.", "labels": [], "entities": []}], "tableCaptions": [{"text": " Table 1: Number of parse labels before and after  the 'path'-lifting.", "labels": [], "entities": [{"text": "Number", "start_pos": 10, "end_pos": 16, "type": "METRIC", "confidence": 0.9594688415527344}, {"text": "path'-lifting", "start_pos": 56, "end_pos": 69, "type": "TASK", "confidence": 0.6702425877253214}]}, {"text": " Table 3: Evaluation results incl. MOSES phrase- based system, GHKM-based system, and hierar- chical system for reference. The bold MBOT  results are statistically significant improvements  over the baseline (at confidence p < 1%).", "labels": [], "entities": []}, {"text": " Table 4: Number of rules per type used when decoding test (Lex = lexical rules; Struct = structural rules;  [dis]cont. = [dis]contiguous).", "labels": [], "entities": []}]}