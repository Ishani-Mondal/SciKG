{"title": [{"text": "CG\u00ad3 \u00ad Beyond Classical Constraint Grammar", "labels": [], "entities": []}], "abstractContent": [{"text": "This paper discusses methodological strengths and shortcomings of the Constraint Grammar paradigm (CG), showing how the classical CG formalism can be extended to achieve greater expressive power and how it can be enhanced and hybridized with techniques from other parsing paradigms.", "labels": [], "entities": [{"text": "Constraint Grammar paradigm (CG)", "start_pos": 70, "end_pos": 102, "type": "TASK", "confidence": 0.5911391079425812}]}, {"text": "We present anew, largely theory\u00adindependent CG framework and rule compiler (CG\u00ad3), that allows the linguist to write CG rules incorporating different types of linguistic information and methodology from a wide range of parsing approaches, covering not only CG's native topological technique, but also dependency grammar, phrase structure grammar and unification grammar.", "labels": [], "entities": [{"text": "phrase structure grammar", "start_pos": 321, "end_pos": 345, "type": "TASK", "confidence": 0.780215342839559}, {"text": "unification grammar", "start_pos": 350, "end_pos": 369, "type": "TASK", "confidence": 0.925209105014801}]}, {"text": "In addition, we allow the integration of statistical\u00adnumerical constraints and non\u00addiscrete tag and string sets.", "labels": [], "entities": []}], "introductionContent": [{"text": "Within Computational Linguistics, Constraint Grammar (CG) is more a methodological than a descriptive paradigm, designed for the robust parsing of running text (.", "labels": [], "entities": [{"text": "Constraint Grammar (CG)", "start_pos": 34, "end_pos": 57, "type": "TASK", "confidence": 0.7561000227928162}]}, {"text": "The formalism provides a framework for expressing contextual linguistic constraints allowing the grammarian to assignor disambiguate token\u00adbased, morphosyntactic readings.", "labels": [], "entities": []}, {"text": "However, CG's primary concern is not the tag inventory itself, or the underlying linguistic theory of the categories and structures used, but rather the efficiency and accuracy of the method used to achieve a given linguistic annotation.", "labels": [], "entities": [{"text": "accuracy", "start_pos": 168, "end_pos": 176, "type": "METRIC", "confidence": 0.9983223080635071}]}, {"text": "Conceptually, a Constraint Grammar can be seen as a declarative whole of contextual possibilities and impossibilities fora language or genre, but in programming terms, it is implemented procedurally as a set of consecutively iterated rules that add, remove or select tag\u00adencoded information.", "labels": [], "entities": []}, {"text": "In its classical form, Constraint Grammar relies on a morphological analyzer providing so\u00adcalled cohorts of possible readings fora given word, and uses constraints that are largely topological 1 in nature, for both part\u00adof\u00adspeech disambiguation and the assignment of syntactic function tags.", "labels": [], "entities": [{"text": "Constraint Grammar", "start_pos": 23, "end_pos": 41, "type": "TASK", "confidence": 0.8657395839691162}, {"text": "part\u00adof\u00adspeech disambiguation", "start_pos": 215, "end_pos": 244, "type": "TASK", "confidence": 0.7634683847427368}]}, {"text": "(a\u00adc) provide examples for close context (a) and wide context (b) POS rules, and syntactic mapping (c).", "labels": [], "entities": []}, {"text": "(a) REMOVE VFIN IF (0 N) (\u00ad1 ART OR <poss> OR GEN); remove a finite verb reading if self (0) can also be a noun (N), and if there is an article (ART), possessive (<poss>) or genitive (GEN) 1 position left (\u00ad1).", "labels": [], "entities": [{"text": "REMOVE VFIN IF", "start_pos": 4, "end_pos": 18, "type": "METRIC", "confidence": 0.8000281453132629}, {"text": "ART", "start_pos": 29, "end_pos": 32, "type": "METRIC", "confidence": 0.9263232350349426}]}], "datasetContent": [], "tableCaptions": []}