{"title": [{"text": "Accounting for Allomorphy in Finite State Transducers", "labels": [], "entities": []}], "abstractContent": [{"text": "Building morphological parsers with existing finite state toolkits can result in something of a mis-match between the programming language of the toolkit and the linguistic concepts familiar to the average linguist.", "labels": [], "entities": []}, {"text": "We illustrate this mismatch with a particular linguistic construct, suppletive allomorphy, and discuss ways to encode suppletive allomorphy in the Stuttgart Finite State tools (sfst).", "labels": [], "entities": []}, {"text": "The complexity of the general solution motivates our work in providing an alternative formalism for morphology and phonology, one which can be translated automatically into sfst or other morphological parsing engines.", "labels": [], "entities": []}], "introductionContent": [{"text": "While many morphological transducers have been built using finite state tools such as the Xerox Finite State Tool (xfst and lexc,) and the Stuttgart Finite State Tools (sfst, (), linguists with whom we have worked, who are mostly not computer scientists or even computer programmers, have found such a project daunting.", "labels": [], "entities": []}, {"text": "We have therefore created a descriptive mechanism that more closely models views of morphology and phonology that linguists are already familiar with.", "labels": [], "entities": []}, {"text": "The resulting formal descriptions are automatically translated into the programming language of a finite state transducer (currently, sfst).", "labels": [], "entities": []}, {"text": "For this XML-based descriptive mechanism to work, the constructs of the model must be automatically mappable into the constructs available in the transducer, and this mapping must work for all instances of such constructs.", "labels": [], "entities": []}, {"text": "Many linguistic structures indeed have a fairly straightforward mapping into the formalism of finite state technology.", "labels": [], "entities": []}, {"text": "Phonological rules (in rulebased theories of phonology) for example map reasonably well to replace rules in xfst and sfst (although phonological rules expressed in terms of phonological features would not map so easily).", "labels": [], "entities": []}, {"text": "In such a case, the XML formalism is essentially syntactic sugar.", "labels": [], "entities": []}, {"text": "However, not all linguistic structures have such a straightforward mapping.", "labels": [], "entities": []}, {"text": "Some structures are simply beyond the reach of finite state systems; recursive syntactic structures are an obvious example.", "labels": [], "entities": []}, {"text": "Within morphology, full (unlimited) reduplication is another, although xfst provides a workaround for this.", "labels": [], "entities": []}, {"text": "In some cases, however, a linguistic structure maybe finite state, but still difficult to express in a natural and general way using existing finite state formalisms.", "labels": [], "entities": []}, {"text": "This paper describes one linguistic phenomenon, suppletive allomorphy, which has proven difficult to reliably encode in sfst.", "labels": [], "entities": []}, {"text": "In the next section I describe some desiderata fora linguistically based descriptive system.", "labels": [], "entities": []}, {"text": "The following section explains how suppletive allomorphy works, and the section after that describes an algorithm we initially tried in our attempts to treat suppletive allomorphy, but which gave wrong results in some cases.", "labels": [], "entities": []}, {"text": "The final algorithm works correctly, and we have implemented it to build parsers from grammars encoded in our linguistic formalism.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": []}