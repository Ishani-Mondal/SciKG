{"title": [], "abstractContent": [{"text": "Orthography is an integral part of language but in grammar engineering it is often ignored, simplified or just delegated to external tools.", "labels": [], "entities": []}, {"text": "We present new extensions to Grammatical Framework, which allow one and the same formalism to describe both orthography, syntax and morphology.", "labels": [], "entities": []}, {"text": "These extensions are also easily generaliz-able to other formalisms.", "labels": [], "entities": []}], "introductionContent": [{"text": "Orthography is often assumed to be something simple that is easily delegated to pre-or postprocessors.", "labels": [], "entities": []}, {"text": "The real grammar engineering starts only after the tokenization.", "labels": [], "entities": [{"text": "tokenization", "start_pos": 51, "end_pos": 63, "type": "TASK", "confidence": 0.9593278169631958}]}, {"text": "Unfortunately if this is mostly true for English, it is more complicated in other languages.", "labels": [], "entities": []}, {"text": "For instance, most Germanic languages tend to build compound nouns composed of one or more simple nouns.", "labels": [], "entities": []}, {"text": "Furthermore German requires that nouns should start with a capital letter unless if the noun is in the second part of a compound.", "labels": [], "entities": []}, {"text": "Handling compounds requires a separate compound splitter () for parsing and proper generator in linearization.", "labels": [], "entities": [{"text": "parsing", "start_pos": 64, "end_pos": 71, "type": "TASK", "confidence": 0.97597336769104}]}, {"text": "The capitalization is usually ignored in parsing but must be recovered for generation (.", "labels": [], "entities": []}, {"text": "Agglutinative languages tend to build long words by adding more and more suffixes which blurs the borderline between word and morpheme.", "labels": [], "entities": []}, {"text": "In that case the words themselves need to be parsed since it is not possible to enumerate all word forms in a finite lexicon.", "labels": [], "entities": []}, {"text": "The extreme case is in languages that does not separate words with spaces at all.", "labels": [], "entities": []}, {"text": "This is usually solved by using a preprocessor that finds a lattice of possible word segmentations which are later parsed).", "labels": [], "entities": []}, {"text": "Finally, in many languages there are lexical units that are phonetically dependent on the context.", "labels": [], "entities": []}, {"text": "A typical example is the indefinite article a/an in English which is different depending on the next word in the sentence.", "labels": [], "entities": []}, {"text": "Similarly the definite article la/l in French depends on the next word, except that the correct resolution also requires knowledge of a syntactic context which is available only in the grammar.", "labels": [], "entities": []}, {"text": "Because of all these complications, delegating the orthography to an external tool has many engineering disadvantages.", "labels": [], "entities": []}, {"text": "To start with, anew tool has to be developed for every language.", "labels": [], "entities": []}, {"text": "The tool moreover should partly encode knowledge that is already in the grammar.", "labels": [], "entities": []}, {"text": "For instance for compound splitting the tool should have access to the lexicon of the grammar.", "labels": [], "entities": [{"text": "compound splitting", "start_pos": 17, "end_pos": 35, "type": "TASK", "confidence": 0.8829434812068939}]}, {"text": "When an application is ported from one platform to another then the grammar itself is usually stored in a portable format and only the grammar interpreter needs to be ported.", "labels": [], "entities": []}, {"text": "However if external pre-and postprocessors are used then they have to be ported as well.", "labels": [], "entities": []}, {"text": "Everything is a lot simpler if the orthography is encoded in a portable way as part of the grammar itself.", "labels": [], "entities": []}, {"text": "We present extensions to the Grammatical Framework (GF; Ranta 2011) which allow orthographic conventions to be encoded as an integral part of the grammar.", "labels": [], "entities": [{"text": "Grammatical Framework (GF; Ranta 2011)", "start_pos": 29, "end_pos": 67, "type": "DATASET", "confidence": 0.7082863710820675}]}, {"text": "This possess the following challenges.", "labels": [], "entities": []}, {"text": "First of all GF is a reversible formalism.", "labels": [], "entities": []}, {"text": "One and the same grammar is used for both parsing and generation.", "labels": [], "entities": [{"text": "parsing", "start_pos": 42, "end_pos": 49, "type": "TASK", "confidence": 0.9663844108581543}]}, {"text": "In parsing we want grammars that are robust and permissible as long as this does not produce incorrect analyses.", "labels": [], "entities": []}, {"text": "On the other hand in generation we want to produce text of the best possible shape.", "labels": [], "entities": []}, {"text": "This means for instance that accepting a German noun that is not capitalized can be desirable but generating a text where the nouns are not capitalized should be avoided.", "labels": [], "entities": []}, {"text": "GF is by design a multilingual formalism.", "labels": [], "entities": [{"text": "GF", "start_pos": 0, "end_pos": 2, "type": "DATASET", "confidence": 0.6725462675094604}]}, {"text": "A single grammar typically contains modules for several different languages.", "labels": [], "entities": []}, {"text": "The modules are linked together through a Logical Framework 1) which serves as a language independent abstract syntax.", "labels": [], "entities": []}, {"text": "In this multilingual setting, having different pre-or post-processors for the different languages will defeat the purpose of having a single multilingual grammar.", "labels": [], "entities": []}, {"text": "GF grammars are distributed in a portable format () which can be deployed in different environments ranging from web servers and desktop translation systems to mobile devices.", "labels": [], "entities": [{"text": "GF grammars", "start_pos": 0, "end_pos": 11, "type": "TASK", "confidence": 0.5837063938379288}]}, {"text": "The virtual machine for GF) is also developed as a platform independent software.", "labels": [], "entities": []}, {"text": "By adding the orthographic extensions to the framework itself, we automatically make more GF applications portable since they will not be dependent on external tools.", "labels": [], "entities": []}, {"text": "The grammarian in GF writes a grammar by using a high-level functional programming language reminiscent of Haskell and ML.", "labels": [], "entities": []}, {"text": "However, if we abstract away from the high-level features, the backbone of the framework) is equivalent to a Parallel Multiple Context-Free Grammar (PMCFG;).", "labels": [], "entities": []}, {"text": "The latter subsumes other popular formalisms such as TAG) and CCG) but contains only some of the possible RCG grammars.", "labels": [], "entities": [{"text": "TAG", "start_pos": 53, "end_pos": 56, "type": "METRIC", "confidence": 0.7722768187522888}]}, {"text": "The full logical framework embedded in GF in principle makes GF as expressive as HPSG and other unification grammars, but we often find this extra level of complexity unnecessary and we stick with the backbone of the framework.", "labels": [], "entities": []}, {"text": "The extensions that we present are mostly framework independent and they can be added even to simple context-free grammars.", "labels": [], "entities": []}, {"text": "Because of that and to make it easier to relate the extensions to other formalisms we will use context-free grammars for the rest of the paper.", "labels": [], "entities": []}, {"text": "The actual implementation is in the PMCFG engine behind GF.", "labels": [], "entities": [{"text": "PMCFG engine", "start_pos": 36, "end_pos": 48, "type": "DATASET", "confidence": 0.8914097249507904}, {"text": "GF", "start_pos": 56, "end_pos": 58, "type": "DATASET", "confidence": 0.5839992761611938}]}, {"text": "There are four groups of extensions that we present in four sections: \u2022 BIND, SOFT_BIND and SOFT_SPACE in Section 2 \u2022 CAPIT and ALL_CAPIT in Section 3 \u2022 pre in Section 4 The name Grammatical Framework (GF) itself is the analogy of the general Logical Framework in \u2022 nonExist in Section 5 All of these extensions were frequently requested by different people in the GF community.", "labels": [], "entities": [{"text": "BIND", "start_pos": 72, "end_pos": 76, "type": "METRIC", "confidence": 0.9704504013061523}, {"text": "BIND", "start_pos": 83, "end_pos": 87, "type": "METRIC", "confidence": 0.75407874584198}, {"text": "pre", "start_pos": 153, "end_pos": 156, "type": "METRIC", "confidence": 0.969986617565155}]}, {"text": "They are now available as primitive operations of type string (Str) and are exported from the standard module Prelude.", "labels": [], "entities": []}, {"text": "The only exception is pre, which is a complex programming language construction.", "labels": [], "entities": [{"text": "pre", "start_pos": 22, "end_pos": 25, "type": "METRIC", "confidence": 0.8943052291870117}]}, {"text": "Ina public application the extensions were first extensively used in the offline mobile translator for twelve languages developed in.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": []}