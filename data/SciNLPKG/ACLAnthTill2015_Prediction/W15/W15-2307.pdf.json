{"title": [{"text": "A Synopsis of Morphoid Type Theory", "labels": [], "entities": [{"text": "Morphoid Type", "start_pos": 14, "end_pos": 27, "type": "TASK", "confidence": 0.6458947956562042}]}], "abstractContent": [{"text": "Morphoid type theory (MTT) is a type-theoretic foundation for mathematics supporting the concept of isomorphism and the substitution of isomorphics.", "labels": [], "entities": [{"text": "Morphoid type theory (MTT)", "start_pos": 0, "end_pos": 26, "type": "TASK", "confidence": 0.804984450340271}]}, {"text": "Unlike homotopy type theory (HoTT), which also supports isomor-phism, morphoid type theory is a direct extension of classical predicate calculus and avoids the intuitionistic constructs of propositions-as-types, path induction and squashing.", "labels": [], "entities": [{"text": "homotopy type theory (HoTT)", "start_pos": 7, "end_pos": 34, "type": "TASK", "confidence": 0.7591468195120493}]}, {"text": "Although HoTT is capable of supporting classical inference, MTT's thoroughly classical treatment is expected to be more comfortable for those who take a Platonic or realist approach to the practice of mathematics.", "labels": [], "entities": [{"text": "HoTT", "start_pos": 9, "end_pos": 13, "type": "DATASET", "confidence": 0.7788951396942139}, {"text": "MTT", "start_pos": 60, "end_pos": 63, "type": "TASK", "confidence": 0.756077229976654}]}], "introductionContent": [{"text": "The central issue in both homotopy type theory) and morphoid type theory) is isomorphism.", "labels": [], "entities": []}, {"text": "The notion of isomorphism in mathematics seems related to the notion of an application programming interface (API) in computer software.", "labels": [], "entities": []}, {"text": "An API specifies what information and behavior an object provides.", "labels": [], "entities": []}, {"text": "Two different implementations can produce identical behavior when interaction is restricted to that allowed by the API.", "labels": [], "entities": []}, {"text": "For example, textbooks on real analysis typically start from axioms involving multiplication, addition, and ordering.", "labels": [], "entities": []}, {"text": "Addition, multiplication and ordering define an abstract interfacethe well formed statements about real numbers are limited to those that can be defined in terms of the operations of the interface.", "labels": [], "entities": []}, {"text": "We can implement real numbers in different ways -as Dedekind cuts or Cauchy sequences.", "labels": [], "entities": []}, {"text": "However, these different implementations provide identical behavior as viewed through the interface -the different implementations are isomorphic as ordered fields.", "labels": [], "entities": []}, {"text": "The axioms of real analysis specify the reals up to isomorphism for ordered fields.", "labels": [], "entities": []}, {"text": "Peano's axioms (the second order version) similarly specify the structure of the natural numbers up to isomorphism.", "labels": [], "entities": []}, {"text": "The general notion of isomorphism is best illustrated by considering dependent pair types.", "labels": [], "entities": []}, {"text": "Here we will write a dependent pair type as) where the instances of this type are the pairs Pair(x, y) where x is an instance of the type \u03c3 and y is an instance of \u03c4.", "labels": [], "entities": [{"text": "Pair", "start_pos": 92, "end_pos": 96, "type": "METRIC", "confidence": 0.990373969078064}]}, {"text": "The type of directed graphs can be written as PairOf (N : type, P : (N \u00d7 N ) \u2192 Bool) where N is a type representing the set of nodes of the graph and P is a binary predicate on the nodes giving the edge relation.", "labels": [], "entities": []}, {"text": "Two directed graphs Pair(N , P ) and Pair(M, Q) are isomorphic if there exists a bijection from N to M that carries P to Q.", "labels": [], "entities": []}, {"text": "Some bijections will carry P to Q while others will not.", "labels": [], "entities": []}, {"text": "Two pairs Pair(x, y) and Pair(u, w) of a general dependent pair type PairOf (x : \u03c3, y : \u03c4) are isomorphic if there is a \u03c3-isomorphism from x to u that carries y tow.", "labels": [], "entities": []}, {"text": "Some \u03c3-isomorphisms from x to u will carry y tow while others will not.", "labels": [], "entities": []}, {"text": "This implies that to define isomorphism at general dependent pairs types we need that for any type \u03c3, and for any two isomorphic values x and u of type \u03c3, we can define the full set of \u03c3-isomorphisms from x to u.", "labels": [], "entities": []}, {"text": "An interesting special case is the full set of \u03c3-isomorphisms from x to x.", "labels": [], "entities": []}, {"text": "This is the symmetry group of x.", "labels": [], "entities": []}, {"text": "Both Homotopy type theory (HoTT) and morphoid type theory (MTT) are intended as typetheoretic foundations for mathematics supporting a concept of isomorphism.", "labels": [], "entities": [{"text": "Homotopy type theory (HoTT)", "start_pos": 5, "end_pos": 32, "type": "TASK", "confidence": 0.7925660212834676}]}, {"text": "HoTT is an extension of constructive logic while MTT is an extension of classical predicate calculus.", "labels": [], "entities": [{"text": "HoTT", "start_pos": 0, "end_pos": 4, "type": "DATASET", "confidence": 0.8877007365226746}, {"text": "MTT", "start_pos": 49, "end_pos": 52, "type": "DATASET", "confidence": 0.5453857183456421}]}, {"text": "More specifically, HoTT is aversion of Martin L\u00f6f type theory) extended to includes Voevodsky's univalence axiom.", "labels": [], "entities": []}, {"text": "Martin-L\u00f6f type theory involves propositions-astypes and path induction, neither of which are used in MTT.", "labels": [], "entities": [{"text": "MTT", "start_pos": 102, "end_pos": 105, "type": "TASK", "confidence": 0.9407761096954346}]}, {"text": "To accommodate classical (nonconstructive) inference, HoTT can be extended with aversion of the law of the excluded middle.", "labels": [], "entities": [{"text": "HoTT", "start_pos": 54, "end_pos": 58, "type": "TASK", "confidence": 0.6542600989341736}]}, {"text": "However, even in the classical version propositions continue to be represented as types rather than Boolean-valued expressions.", "labels": [], "entities": []}, {"text": "To accommodate classical inference HoTT also includes squashing -a technicality required to allow propositions-types to be treated more like Boolean-valued expressions.", "labels": [], "entities": [{"text": "HoTT", "start_pos": 35, "end_pos": 39, "type": "TASK", "confidence": 0.7819490432739258}]}, {"text": "In MTT all propositions are Boolean-valued and there is no need for squashing.", "labels": [], "entities": [{"text": "MTT", "start_pos": 3, "end_pos": 6, "type": "TASK", "confidence": 0.9071782827377319}]}, {"text": "Perhaps the most significant difference between HoTT and MTT involves the abstraction barrier imposed on types.", "labels": [], "entities": [{"text": "MTT", "start_pos": 57, "end_pos": 60, "type": "TASK", "confidence": 0.532988429069519}]}, {"text": "In MTT two types are typeisomorphic if there exists a bijection between them.", "labels": [], "entities": [{"text": "MTT", "start_pos": 3, "end_pos": 6, "type": "TASK", "confidence": 0.9102401733398438}]}, {"text": "In MTT two types with the same cardinality (number of equivalence classes) cannot be distinguished by well-typed predicates on types.", "labels": [], "entities": [{"text": "MTT", "start_pos": 3, "end_pos": 6, "type": "TASK", "confidence": 0.8861047029495239}]}, {"text": "In HoTT, however, types with the same cardinality can still be distinguished by well-typed predicates.", "labels": [], "entities": [{"text": "HoTT", "start_pos": 3, "end_pos": 7, "type": "DATASET", "confidence": 0.8890362977981567}]}, {"text": "In HoTT two types are equivalent only when they have the same higher-order groupoid structure.", "labels": [], "entities": []}, {"text": "For example, two graphs fail to be isomorphic unless the node types have the same higher order groupoid structure.", "labels": [], "entities": []}, {"text": "This can be interpreted as implementation details of a type leaking from the abstraction barrier on types.", "labels": [], "entities": []}, {"text": "This leakage interpretation is discussed more explicitly in section 3.", "labels": [], "entities": [{"text": "leakage interpretation", "start_pos": 5, "end_pos": 27, "type": "TASK", "confidence": 0.9256864488124847}]}, {"text": "HoTT allows one to block the leakage of type implementations by squashing types to \"sets\".", "labels": [], "entities": [{"text": "HoTT", "start_pos": 0, "end_pos": 4, "type": "DATASET", "confidence": 0.9423952698707581}]}, {"text": "A set is a type whose internal groupoid structure is effectively suppressed.", "labels": [], "entities": []}, {"text": "One can construct the type of topological space whose point types are sets.", "labels": [], "entities": []}, {"text": "In this case we get the familiar notion isomorphism (homeomorphism) where two topological spaces are homeomorphic if there is any bijection between their points that identifies their open sets.", "labels": [], "entities": []}, {"text": "We can then define the groupoid of topological spaces to be the category consisting of the topological spaces and the homeomorphisms between them.", "labels": [], "entities": []}, {"text": "This is the \"first order\" groupoid of topological spaces.", "labels": [], "entities": []}, {"text": "If we take the point types of topological spaces to be first order groupoids rather than sets, and restrict the point bijections to functors, we get the second order groupoid of topological spaces.", "labels": [], "entities": []}, {"text": "We can then define a third order groupoid and soon.", "labels": [], "entities": []}, {"text": "In HoTT we can even have \u03c9-order groupoids.", "labels": [], "entities": [{"text": "HoTT", "start_pos": 3, "end_pos": 7, "type": "DATASET", "confidence": 0.9259771704673767}]}, {"text": "In MTT the internal structure of types is approached in a different way.", "labels": [], "entities": [{"text": "MTT", "start_pos": 3, "end_pos": 6, "type": "TASK", "confidence": 0.9272966384887695}]}, {"text": "In MTT natural mappings are distinguished from general functions.", "labels": [], "entities": [{"text": "MTT natural mappings", "start_pos": 3, "end_pos": 23, "type": "TASK", "confidence": 0.9099826018015543}]}, {"text": "For example, there is an isomorphism (a linear bijection) from a finite dimensional vector space to its dual.", "labels": [], "entities": []}, {"text": "However, there is no natural isomorphism.", "labels": [], "entities": []}, {"text": "Although not covered in this synopsis, MTT takes a function to be natural if it can be written as a lambda expression.", "labels": [], "entities": [{"text": "MTT", "start_pos": 39, "end_pos": 42, "type": "TASK", "confidence": 0.8266266584396362}]}, {"text": "Lambda expressions (natural functions) have commutation properties not shared by general functions.", "labels": [], "entities": []}, {"text": "Two types \u03c3 and \u03c4 are cryptomorphic (in the sense of Birkoff or Rota) if there exists a pair of natural functions (lambda expressions) f : \u03c3 \u2192 \u03c4 and g : \u03c4 \u2192 \u03c3 such that f \u2022 g and g \u2022 fare both identity functions (viewed as functions on the isomorphism classes of \u03c3 and \u03c4 respectively).", "labels": [], "entities": []}, {"text": "MTT does not attempt to handle higher order groupoid structure.", "labels": [], "entities": [{"text": "MTT", "start_pos": 0, "end_pos": 3, "type": "DATASET", "confidence": 0.8359032869338989}]}, {"text": "This synopsis of MTT is preliminary and many of the features described here go beyond the features covered by soundness proofs in version 4 of.", "labels": [], "entities": [{"text": "MTT", "start_pos": 17, "end_pos": 20, "type": "TASK", "confidence": 0.834829568862915}]}, {"text": "This synopsis should be viewed as a plan, or program, for the next version of).", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": []}