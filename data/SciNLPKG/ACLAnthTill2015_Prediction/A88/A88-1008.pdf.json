{"title": [], "abstractContent": [{"text": "This paper describes a program for handling \"scope ambiguities\" in individual English sentences.", "labels": [], "entities": []}, {"text": "The program operates on initial logical translations, generated by a parser/translator, in which \"unscoped elements\" such as quantifiers, coordinators and negation are left in place to be extracted and positioned by the scoping program.", "labels": [], "entities": []}, {"text": "The program produces the set of valid scoped readings, omitting logically redundant readings, and places the readings in an approximate order of preference using a set of domain-independent heuristics.", "labels": [], "entities": []}, {"text": "The heuristics are based on information about the lexical type of each operator and on \"structural relations\" between pairs of operators.", "labels": [], "entities": []}], "introductionContent": [{"text": "Natural languages contain a variety of \"logical operators\" which interact with each other to give rise to different types of ambiguity.", "labels": [], "entities": []}, {"text": "The logical operators recognized by the scoping program include quantifiers, coordinators and negation, which are initially \"unscoped\" and must therefore be moved into position by the program, and adverbs, predicates and connectives (such as if-then).", "labels": [], "entities": []}, {"text": "At the moment, other operators such as tense, aspect and modals are left in place and therefore assume innermost scope.", "labels": [], "entities": []}, {"text": "There is some evidence that the handling of the scoping of quantifiers relative to such operators may require special treatment (eg.).", "labels": [], "entities": []}, {"text": "Three simple examples will illustrate some different types of scope ambiguity and their representation in an informal first order predicate logic, using restrictions on quantifiers and an infix notation for sentential formulas.", "labels": [], "entities": []}, {"text": "The meanings of the different interpretations should be clear.", "labels": [], "entities": []}, {"text": "For example, (4) may mean that John didn't meet either Jane or Mary (5) or that he didn't meet at least one of them (6).", "labels": [], "entities": []}, {"text": "Further examples are given in and.", "labels": [], "entities": []}, {"text": "Some alternative proposals for representing scope ambiguities are also discussed in the latter.", "labels": [], "entities": []}, {"text": "Until quite recently, designers of natural language understanding systems have given little attention to the problem of dealing with scope ambiguities.", "labels": [], "entities": [{"text": "natural language understanding", "start_pos": 35, "end_pos": 65, "type": "TASK", "confidence": 0.6574977238972982}]}, {"text": "Two of the earliest attempts to incorporate quantifier scoping into natural language understanding systems in ,an integral way are described in and.", "labels": [], "entities": []}, {"text": "Some more recent scoping algorithms are presented in,,, and.", "labels": [], "entities": []}, {"text": "While each of these algorithms introduces some new features, certain problems, such as the scoping of coordinators and the use of heuristics to select preferred readings, have generally been given little or no treatment.", "labels": [], "entities": []}, {"text": "Some of the main features of the algorithm being discussed here are: (a) it handles ambiguities created by quantifiers, coordinators, negation and adverbs, ~ (b) it works bottom-up and left-to-right and generates the set of valid scoped readings in one pass, (c) it removes logically redundant readings as they are encountered during the process of scoping and (d) it uses domain-independent heuristics, during the scoping, to arrange the readings in an approximate order of preference.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": []}