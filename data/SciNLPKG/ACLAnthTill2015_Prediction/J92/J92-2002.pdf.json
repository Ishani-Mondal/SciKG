{"title": [], "abstractContent": [{"text": "We describe an approach to unification grammars that integrates two paradigms: the object-oriented approach, which offers multiple inheritance, complex objects with role-value restrictions and role-values equality, querying as subsumption; the relational programming approach, which offers declarativity, logical variables, nondeterminism with backtracking, and existential queries.", "labels": [], "entities": [{"text": "unification grammars", "start_pos": 27, "end_pos": 47, "type": "TASK", "confidence": 0.9230249226093292}]}, {"text": "This approach is embodied in a constraint-based object-oriented formalism.", "labels": [], "entities": []}, {"text": "The interpreter of the formalism is described as a term rewriting system based on unification of typed feature structures.", "labels": [], "entities": []}, {"text": "The grammar writer organizes unification grammars as inheritance networks of typed feature structures.", "labels": [], "entities": []}, {"text": "Complex linguistic structures are described by means of recursive type constraints.", "labels": [], "entities": []}, {"text": "We illustrate the use of inheritance networks with two examples: an HPSG example where implication (as used for \"principles\") is modeled using inheritance and an example of bilingual transfer where the minimal amount of information needed for the translation is specified at different levels of generalization.", "labels": [], "entities": [{"text": "bilingual transfer", "start_pos": 173, "end_pos": 191, "type": "TASK", "confidence": 0.769684225320816}]}], "introductionContent": [{"text": "Ideally, a linguistic formalism combining the best of the object-oriented approach and the unification-based approach would be realized in a constraint-based architecture for an object-oriented language based on inheritance, feature structures, and unification.", "labels": [], "entities": []}, {"text": "The Typed Feature Structure language (TFS) is an attempt to provide a synthesis of several key concepts stemming from unification-based grammar formalisms (feature structure: knowledge representation languages (inheritance), and logic programming (narrowing).", "labels": [], "entities": [{"text": "Typed Feature Structure language (TFS)", "start_pos": 4, "end_pos": 42, "type": "TASK", "confidence": 0.695829050881522}]}, {"text": "The formalism supports an object-oriented style based on abstraction and generalization through inheritance; it is a fully declarative formalism based on unification of typed feature structures.", "labels": [], "entities": []}, {"text": "It is flexible and has enough expressive power to support various kinds of linguistic theories, not necessarily based on constituencyL The use of an object-oriented methodology for natural language processing is very attractive, and the use of inheritance offers a number of advantages such as abstraction and generalization, information sharing and default reasoning, and modularity and reusability).", "labels": [], "entities": []}, {"text": "Inheritance-based descriptions are already used in computational linguistics: linguistic theories such as Systemic Functional Grammar, Word Grammar (, or HPSG (Pollard and Sag 1987) make use of inheritance to describe linguistic structures at the lexical, morphological, syntactic, or semantic (conceptual) levels.", "labels": [], "entities": [{"text": "Word Grammar", "start_pos": 135, "end_pos": 147, "type": "TASK", "confidence": 0.606080561876297}]}, {"text": "These theories are usually directly implemented in object-oriented programming languages (e.g., LOOM in the case of the PENMAN system), but there is a growing number of linguistic formalisms used for specific purposes, e.g., DATR for the lexicon.", "labels": [], "entities": []}, {"text": "On the other hand, current linguistic theories such as LFG, UCG, HPSG, and some formalisms for linguistic description such as FUG or PATR-II are based on the notion of partial information: linguistic structures are described using feature structures that give partial information about the object being modeled, a linguistic structure being described by a set of feature structures that mutually constrain the description.", "labels": [], "entities": [{"text": "FUG", "start_pos": 126, "end_pos": 129, "type": "METRIC", "confidence": 0.7328917384147644}]}, {"text": "Feature structures are partially ordered according to a subsumption ordering interpreted as an ordering on the amount of conveyed information; the combination of information is defined as the unification of feature structures.", "labels": [], "entities": []}, {"text": "Formalisms based on feature structure and unification are declarative, and they can be given a sound formal semantics.", "labels": [], "entities": []}, {"text": "Combining object-oriented approaches to linguistic description with unificationbased grammar formalisms, as in HPSG, is very attractive.", "labels": [], "entities": [{"text": "linguistic description", "start_pos": 40, "end_pos": 62, "type": "TASK", "confidence": 0.7194004952907562}, {"text": "HPSG", "start_pos": 111, "end_pos": 115, "type": "DATASET", "confidence": 0.8928807973861694}]}, {"text": "On one hand, we gain the advantages of the object-oriented approach: abstraction and generalization through the use of inheritance.", "labels": [], "entities": []}, {"text": "On the other hand, we gain a fully declarative framework, with all the advantages of logical formalisms: expressive power, simplicity, and sound formal semantics.", "labels": [], "entities": [{"text": "simplicity", "start_pos": 123, "end_pos": 133, "type": "METRIC", "confidence": 0.9682652950286865}]}, {"text": "To arrive at such a result, we have to enrich the formalism of feature structures with the notion of inheritance and abandon some of the procedural features of object-oriented languages in order to gain referential transparency.", "labels": [], "entities": []}, {"text": "Referential transparency is one of the characteristic properties of declarative languages, where the meaning of each language construct is given by a few simple and general rules.", "labels": [], "entities": [{"text": "Referential transparency", "start_pos": 0, "end_pos": 24, "type": "TASK", "confidence": 0.8811775147914886}]}, {"text": "For example, the value of a variable should be independent from its position within the scope of its declaration.", "labels": [], "entities": []}, {"text": "This is true for PROLOG variables inside a clause, but not for PASCAL or LIsP variables that make use of assignment.", "labels": [], "entities": []}, {"text": "A higher level example is the meaning of a procedure: it is not transparent if the procedure makes use of global variables that are set by some other procedure.", "labels": [], "entities": []}, {"text": "Similarly, the meaning of a PROLOG predicate should be transparent because there is no global variable, but a predicate definition might be modified during execution by imperative predicates such as assert and retract, thus destroying the referential transparency of pure PROLOG.", "labels": [], "entities": []}, {"text": "Clearly, most of the object-oriented languages lack referential transparency in several ways, using for example procedural attachments for object methods.", "labels": [], "entities": []}, {"text": "Another example is the use of nonmonotonic inheritance, which is advocated in computational linguistics by, for example,.", "labels": [], "entities": []}, {"text": "Nonmonotonic inheritance is seen as a practical device designed to deal with exceptions, but such a feature goes against generality and referential transparency.", "labels": [], "entities": [{"text": "Nonmonotonic inheritance", "start_pos": 0, "end_pos": 24, "type": "TASK", "confidence": 0.7628174126148224}]}, {"text": "Furthermore, as expressed by, a still unresolved issue in nonmonotonic reasoning is the issue of ...", "labels": [], "entities": []}, {"text": "scaling formal non-monotonic theories up to real problems (merely a formality?).", "labels": [], "entities": []}, {"text": "Most existant theories are intractable some don't have even a proof theory--and it is often difficult to tell how large bodies of information will (or even should) interact.", "labels": [], "entities": []}, {"text": "Given the complexity of the state of the art in nonmonotonic reasoning and the lack of a basic commonly agreed formalization, a the issue of nonmonotonicity is not addressed in the work described in this article.", "labels": [], "entities": []}, {"text": "Knowledge representation languages are evolving toward more declarativity, as exemplified by the evolution from KL-ONE to languages such as GLASSIC () or LOOM ().", "labels": [], "entities": []}, {"text": "The terminological component describing the objects (the data model of object-oriented database systems) has always been more declarative than the assertional component (procedural attachment or methods), and the current trend is to integrate those two components more closely, where the assertional component is some kind of rule-based system, as in LOOM.", "labels": [], "entities": []}, {"text": "Typed feature structures are very similar to structured objects of object-oriented languages and to conceptual structures of knowledge representation languages.", "labels": [], "entities": []}, {"text": "Thus, typed feature structures have the potential to act as a lingua franca for both computational linguistics and artificial intelligence, and this should ease the communication between those two worlds.", "labels": [], "entities": []}, {"text": "Since conceptual structures are used for example in text generation () or knowledge-based machine translation (), typed feature structures provide an attractive alternative to current procedural implementations.", "labels": [], "entities": [{"text": "text generation", "start_pos": 52, "end_pos": 67, "type": "TASK", "confidence": 0.7654582858085632}, {"text": "knowledge-based machine translation", "start_pos": 74, "end_pos": 109, "type": "TASK", "confidence": 0.6905605792999268}]}, {"text": "In Section 2, we present a language that combines the notions of partial information and inheritance in a fully declarative framework.", "labels": [], "entities": []}, {"text": "It is based on feature structures augmented with the notion of types, which are organized into an inheritance network.", "labels": [], "entities": []}, {"text": "Using types, it is possible to define structured domains of feature structures and to classify feature structures.", "labels": [], "entities": []}, {"text": "Logical conditions are attached to types, akin to method attachment, but in a fully declarative framework.", "labels": [], "entities": []}, {"text": "Recursivity is an integral part of the language, giving the necessary expressive power for describing complex recursive linguistic structures.", "labels": [], "entities": []}, {"text": "We end the section by an overview of the TFS abstract rewrite machine used for computing descriptions of the meaning of typed feature structures.", "labels": [], "entities": []}, {"text": "3 Section 3 describes the use of inheritance in two examples of unification grammars using the TFS formalism: an HPSG grammar fora fragment of English and an LFGstyle transfer grammar fora small machine translation problem between English and French.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": []}