{"title": [{"text": "POLYNOMIAL TIME PARSING OF COMBINATORY CATEGORIAL GRAMMARS*", "labels": [], "entities": [{"text": "POLYNOMIAL TIME PARSING OF COMBINATORY CATEGORIAL GRAMMARS", "start_pos": 0, "end_pos": 58, "type": "METRIC", "confidence": 0.587366372346878}]}], "abstractContent": [{"text": "In this paper we present a polynomial time parsing algorithm for Combinatory Categorial Grammar.", "labels": [], "entities": [{"text": "Combinatory Categorial Grammar", "start_pos": 65, "end_pos": 95, "type": "TASK", "confidence": 0.798266609509786}]}, {"text": "The recognition phase extends the CKY algorithm for CFG.", "labels": [], "entities": [{"text": "CFG", "start_pos": 52, "end_pos": 55, "type": "DATASET", "confidence": 0.6453978419303894}]}, {"text": "The process of generating a representation of the parse trees has two phases.", "labels": [], "entities": []}, {"text": "Initially, a shared forest is build that encodes the set of all derivation trees for the input string.", "labels": [], "entities": []}, {"text": "This shared forest is then pruned to remove all spurious ambiguity.", "labels": [], "entities": []}], "introductionContent": [{"text": "Combinatory Categorial Grammar (CCG) is an extension of Classical Categorial Grammar in which both function composition and function application are allowed.", "labels": [], "entities": [{"text": "Combinatory Categorial Grammar (CCG)", "start_pos": 0, "end_pos": 36, "type": "TASK", "confidence": 0.7449808965126673}]}, {"text": "In addition, forward and backward slashes are used to place conditions on the relative ordering of adjacent categories that are, to be combined.", "labels": [], "entities": []}, {"text": "There has been considerable interest in parsing strategies for CCG'.", "labels": [], "entities": [{"text": "parsing", "start_pos": 40, "end_pos": 47, "type": "TASK", "confidence": 0.9792669415473938}]}, {"text": "One of the major problems that must be addressed is that of spurious ambiguity.", "labels": [], "entities": []}, {"text": "This refers to the possibility that a CCG can generate a large number of (exponentially many) derivation trees that assign the same function argument structure to a string.", "labels": [], "entities": []}, {"text": "In we noted that a CCG can also generate exponentially many genuinely ambiguous (non-spurious)derivations.", "labels": [], "entities": []}, {"text": "This constitutes a problem for the approaches cited above since it resuits in their respective algorithms taking exponential time in the worst case.", "labels": [], "entities": []}, {"text": "The algorithm we present is the first known polynomial time parser for CCG.", "labels": [], "entities": []}, {"text": "The parsing process has three phases.", "labels": [], "entities": [{"text": "parsing", "start_pos": 4, "end_pos": 11, "type": "TASK", "confidence": 0.9864683151245117}]}, {"text": "Once the recognizer decides (in the first phase) that an input can be generated by the given CCG the set of parse *This work was partially supported by NSF grant IRI-8909810.", "labels": [], "entities": [{"text": "NSF grant IRI-8909810", "start_pos": 152, "end_pos": 173, "type": "DATASET", "confidence": 0.624717096487681}]}, {"text": "We are very grateful to Aravind Joshi, Michael Niv, Mark Steedman and Kent Wittenburg for helpful discussior~.", "labels": [], "entities": []}, {"text": "1 trees can be extracted in the second phase.", "labels": [], "entities": []}, {"text": "Rather than enumerating all parses, in Section 3, we describe how they can be encoded by means of a shared forest (represented as a grammar) with which an expoo ential number of parses are encoded using a polynomially bounded structure.", "labels": [], "entities": []}, {"text": "This shared forest encodes all derivations including those that are spuriously ambiguous.", "labels": [], "entities": []}, {"text": "In Section 4.1, we show that it is possible to modify the shared forest so that it contains no spurious ambiguity.", "labels": [], "entities": []}, {"text": "This is done (in the third phase) by traversing the forest, examining two levels of nodes at each stage, detecting spurious ambiguity locally.", "labels": [], "entities": []}, {"text": "The three stage process of recognition, building the shared forest, and eliminating spurious ambiguity takes polynomial time.", "labels": [], "entities": [{"text": "recognition", "start_pos": 27, "end_pos": 38, "type": "TASK", "confidence": 0.9586712121963501}]}], "datasetContent": [], "tableCaptions": []}