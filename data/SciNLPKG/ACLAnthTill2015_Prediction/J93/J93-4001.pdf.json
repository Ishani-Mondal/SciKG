{"title": [{"text": "The Interface between Phrasal and Functional Constraints", "labels": [], "entities": [{"text": "Interface between Phrasal and Functional Constraints", "start_pos": 4, "end_pos": 56, "type": "TASK", "confidence": 0.5914784769217173}]}], "abstractContent": [{"text": "Many modern grammatical formalisms divide the task of linguistic specification into a context-free component of phrasal constraints and a separate component of attribute-value or functional constraints.", "labels": [], "entities": [{"text": "linguistic specification", "start_pos": 54, "end_pos": 78, "type": "TASK", "confidence": 0.7196444272994995}]}, {"text": "Conventional methods for recognizing the strings of a language also divide into two parts so that they can exploit the different computational properties of these components.", "labels": [], "entities": []}, {"text": "This \u2022 paper focuses on the interface between these components as a source of computational complexity distinct from the complexity internal to each.", "labels": [], "entities": []}, {"text": "We first analyze the common hybrid strategy in which a polynomial context-free parser is modified to interleave functional constraint solving with context-free constituent analysis.", "labels": [], "entities": [{"text": "functional constraint solving", "start_pos": 112, "end_pos": 141, "type": "TASK", "confidence": 0.688222348690033}]}, {"text": "This strategy depends on the property of monotonicity in order to prune unnecessary computation.", "labels": [], "entities": []}, {"text": "We describe a number of other properties that can be exploited for computational advantage, and we analyze some alternative interface strategies based on them.", "labels": [], "entities": []}, {"text": "We present the results of preliminary experiments that generally support our intuitive analyses.", "labels": [], "entities": []}, {"text": "A surprising outcome is that under certain circumstances an algorithm that does no pruning in the interface may perform significantly better than one that does.", "labels": [], "entities": []}], "introductionContent": [{"text": "A wide range of modern grammatical formalisms divide the task of linguistic specification either explicitly or implicitly into a context-free component of phrasal constraints and a separate component of attribute-value or functional constraints., for example, is very explicit in assigning both a phrase structure tree and an attribute-value functional structure to every sentence of a language.", "labels": [], "entities": []}, {"text": "Generalized Phrase Structure Grammar assigns a phrase structure tree whose categories are attributevalue structures.", "labels": [], "entities": [{"text": "Phrase Structure Grammar", "start_pos": 12, "end_pos": 36, "type": "TASK", "confidence": 0.7346506516138712}]}, {"text": "For Functional Unification Grammar) and other unification formalisms that evolved from it (such as HPSG), the phrase structure is more implicit, showing up as the record of the control strategy that recursively reinstantiates the collection of attribute-value constraints from the grammar.", "labels": [], "entities": [{"text": "HPSG", "start_pos": 99, "end_pos": 103, "type": "DATASET", "confidence": 0.9055001735687256}]}, {"text": "For Definite Clause Grammars () the phrase structure is implicit in the unification of the concealed string-position variables and the recursive reinstantiation of the additional logic variables that carry functional information.", "labels": [], "entities": []}, {"text": "The computational problem of recognizing whether a given string belongs to the language of a grammar also divides into two parts, since it must be determined that the string satisfies both the phrasal and functional constraints.", "labels": [], "entities": []}, {"text": "These two types of constraints have different computational properties.", "labels": [], "entities": []}, {"text": "It is well known that context-free phrase structure constraints can be solved in time polynomial in the length of the input sentence, whereas all known algorithms for solving Boolean combinations of equality or unification constraints in the worst-case run in time exponential in size of the constraint system.", "labels": [], "entities": []}, {"text": "There have been a number of approaches for implementing such hybrid constraint systems.", "labels": [], "entities": []}, {"text": "In one approach the context-free constraints are converted to the form of more general functional constraints so that a general-purpose constraint satisfaction method can uniformly solve all constraints.", "labels": [], "entities": []}, {"text": "While this has the advantage of simplicity and elegance, it usually gains no advantage from the special properties of the contextfree subsystem.", "labels": [], "entities": []}, {"text": "The original implementation for Definite Clause Grammars followed this strategy by translating the grammar into equivalent Prolog clauses and using the general Prolog interpreter to solve them.", "labels": [], "entities": []}, {"text": "On the other hand, functional constraints of a sufficiently restricted kind can be translated into context-free phrasal constraints and solved with special purpose mechanisms.", "labels": [], "entities": []}, {"text": "This is true, for example, of all GPSG feature constraints.", "labels": [], "entities": []}, {"text": "In the extreme, a GPSG could be completely converted to an equivalent context-free one and processed with only phrasal mechanisms, but the fast polynomial bound may then be overwhelmed by an enormous grammar-size constant, making this approach computationally infeasible for any realistic grammar.", "labels": [], "entities": []}, {"text": "More common approaches involve hybrid implementations that attempt to take advantage of the special computational properties of phrasal constraints while also handling the general expressiveness of arbitrary feature constraints.", "labels": [], "entities": []}, {"text": "Although this sounds good in principle, it turns out to be hard to accomplish in practice.", "labels": [], "entities": []}, {"text": "An obvious first approach, for example, is to solve the context-free constraints first using familiar polynomial algorithms, and then to enumerate the resulting phrase structure trees.", "labels": [], "entities": []}, {"text": "Their corresponding functional constraints are solved by converting to disjunctive normal form (DNF) and using also well-known general purpose constraint algorithms.", "labels": [], "entities": []}, {"text": "This configuration involves a simple composition of well-understood techniques but has proven to be a computational disaster.", "labels": [], "entities": []}, {"text": "The phrasal mechanisms compute in polynomial time a compact representation of all possible trees, each of which presents a potentially exponential problem for the constraint solver to solve.", "labels": [], "entities": []}, {"text": "If the phrasal component is not properly restricted, there can bean infinite number of such trees and the whole system is undecidable.", "labels": [], "entities": []}, {"text": "But even with an appropriate restriction on valid phrase structures, such as LFG's prohibition against nonbranching dominance chains, the number of such trees can be exponential in the length of the sentence.", "labels": [], "entities": []}, {"text": "Thus, even though a context-free parser can very quickly determine that those trees exist, if the grammar is exponentially ambiguous then the net effect is to produce an exponential number of potentially exponential functional constraint problems.", "labels": [], "entities": []}, {"text": "This is an important observation.", "labels": [], "entities": []}, {"text": "There have been several successful efforts in recent years to develop solution algorithms for Boolean combinations of functional constraints that are polynomial for certain special, perhaps typical, cases.", "labels": [], "entities": []}, {"text": "But even if the functional constraints could always be solved in polynomial time (for instance, if there were no disjunctions), the simple composition of phrasal constraints and functional constraints would still in the worst case be exponential in sentence length.", "labels": [], "entities": []}, {"text": "This exponential does not come from either of the components independently; rather, it lies in the interface between them.", "labels": [], "entities": []}, {"text": "Of course, simple composition is not the only strategy for solving hybrid constraint systems.", "labels": [], "entities": [{"text": "simple composition", "start_pos": 11, "end_pos": 29, "type": "TASK", "confidence": 0.6814511120319366}]}, {"text": "A typical approach involves interleaving phrasal and functional processing.", "labels": [], "entities": []}, {"text": "The functional constraints associated with each constituent are incrementally solved as the constituent is being constructed, and the constituent is discarded if those constraints prove to be unsatisfiable.", "labels": [], "entities": []}, {"text": "Although this interface strategy avoids the blatant excesses of simple composition, we show below that in the worst case it is also exponential in sentence length.", "labels": [], "entities": []}, {"text": "However, it is too early to conclude that there is no subexponential interface strategy, since the computational properties of this interface have not yet been extensively investigated.", "labels": [], "entities": []}, {"text": "This paper maps out a space of interface possibilities, describes alternative strategies that can provide exponential improvements in certain common situations, and suggests a number of areas for further exploration.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": []}