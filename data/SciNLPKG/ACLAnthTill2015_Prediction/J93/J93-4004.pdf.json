{"title": [{"text": "Planning Text for Advisory Dialogues: Capturing Intentional and Rhetorical Information", "labels": [], "entities": [{"text": "Capturing Intentional and Rhetorical Information", "start_pos": 38, "end_pos": 86, "type": "TASK", "confidence": 0.7984591484069824}]}], "abstractContent": [{"text": "To participate in a dialogue a system must be capable of reasoning about its own previous utterances.", "labels": [], "entities": []}, {"text": "Follow-up questions must be interpreted in the context of the ongoing conversation, and the system's previous contributions form part of this context.", "labels": [], "entities": []}, {"text": "Furthermore, if a system is to be able to clarify misunderstood explanations or to elaborate on prior explanations, it must understand what it has conveyed in prior explanations.", "labels": [], "entities": []}, {"text": "Previous approaches to generating multisentential texts have relied solely on rhetorical structuring techniques.", "labels": [], "entities": []}, {"text": "In this paper, we argue that, to handle explanation dialogues successfully, a discourse model must include information about the intended effect of individual parts of the text on the hearer, as well as how the parts relate to one another rhetorically.", "labels": [], "entities": []}, {"text": "We present a text planner that records this information and show how the resulting structure is used to respond appropriately to a follow-up question.", "labels": [], "entities": []}], "introductionContent": [{"text": "Explanation systems must produce multisentential texts, including justifications of their actions, descriptions of their problem-solving strategies, and definitions of the terms they use.", "labels": [], "entities": []}, {"text": "Previous research in natural language generation has shown that schemata of rhetorical predicates or rhetorical relations can be used to capture the structure of coherent multisentential texts.", "labels": [], "entities": [{"text": "natural language generation", "start_pos": 21, "end_pos": 48, "type": "TASK", "confidence": 0.6779324412345886}]}, {"text": "Schemata are scriptlike entities that encode standard patterns of discourse structure.", "labels": [], "entities": []}, {"text": "Associating a schema with a communicative goal allows a system to generate a text that achieves the goal.", "labels": [], "entities": []}, {"text": "However, we have found that schemata are insufficient as a discourse model for advisory dialogues.", "labels": [], "entities": []}, {"text": "Although they encode standard patterns of discourse structure, schemata do not include a representation of the intended effects of the components of a schema, nor how these intentions are related to one another or to the rhetorical structure of the text.", "labels": [], "entities": []}, {"text": "While this may not present a problem for systems that generate one-shot explanations, it is a serious limitation in a system intended to participate in a dialogue where users can, and frequently do, ask follow-up questions.", "labels": [], "entities": []}, {"text": "In this paper, we argue that to participate in explanation dialogues successfully, a generation system must represent and reason about the intended effect of individual parts of the text on the hearer, as well as how the parts relate to one another rhetorically.", "labels": [], "entities": []}, {"text": "We present a text planner that constructs explanations based on the intentions of the speaker at each step and that notes the rhetorical relation that holds between each pair of text spans.", "labels": [], "entities": []}, {"text": "By recording the planning process behind the system's utterances as well as the user's utterances in a dialogue history, our system is able to reason about its Johanna D. Moore and C6cile L.", "labels": [], "entities": []}, {"text": "Paris Planning Text for Advisory Dialogs STUDENT I can't figure out how to write the SWAP procedure in C.", "labels": [], "entities": [{"text": "Paris Planning Text", "start_pos": 0, "end_pos": 19, "type": "DATASET", "confidence": 0.9756527344385783}, {"text": "Advisory Dialogs STUDENT", "start_pos": 24, "end_pos": 48, "type": "TASK", "confidence": 0.5260016024112701}, {"text": "SWAP", "start_pos": 85, "end_pos": 89, "type": "TASK", "confidence": 0.960590124130249}]}, {"text": "[1] TEACHER You write a procedure called SWAP that takes the addresses of the two variables to be swapped as its arguments.", "labels": [], "entities": [{"text": "TEACHER", "start_pos": 4, "end_pos": 11, "type": "METRIC", "confidence": 0.9708728194236755}]}, {"text": "[3] [Student shows teacher his program code.]", "labels": [], "entities": []}, {"text": "TEACHER Here [points to call to SWAP in the main program], when you call SWAP, you have to pass the addresses of the variables you want swapped.", "labels": [], "entities": [{"text": "TEACHER", "start_pos": 0, "end_pos": 7, "type": "METRIC", "confidence": 0.9781559705734253}]}, {"text": "TEACHER Because otherwise the procedure just swaps its local copies of the argu-[6] ments.", "labels": [], "entities": [{"text": "TEACHER", "start_pos": 0, "end_pos": 7, "type": "METRIC", "confidence": 0.9774073958396912}]}, {"text": "TEACHER You cannot change the value of a variable defined outside a procedure unless you pass its address.", "labels": [], "entities": [{"text": "TEACHER", "start_pos": 0, "end_pos": 7, "type": "METRIC", "confidence": 0.9464797973632812}]}, {"text": "This is because C is call-by-value.", "labels": [], "entities": []}, {"text": "That means that when you pass an argument to a procedure in C, the procedure makes a copy of the argument, and does its work on that copy.", "labels": [], "entities": []}, {"text": "The value of the variable passed in as an argument remains unchanged.", "labels": [], "entities": []}, {"text": "TEACHER OK, suppose in our main program we have a variable V with value 3, and a procedure called PLUS-ONE that takes one argument, call it A.", "labels": [], "entities": [{"text": "TEACHER", "start_pos": 0, "end_pos": 7, "type": "METRIC", "confidence": 0.9718543887138367}, {"text": "PLUS-ONE", "start_pos": 98, "end_pos": 106, "type": "METRIC", "confidence": 0.9769829511642456}]}, {"text": "Now when we call PLUS-ONE(V) what actually happens is that the value of V, which is 3, is copied to A.", "labels": [], "entities": []}, {"text": "So A equals 3 and our procedure adds 1 to A, so A now equals 4.", "labels": [], "entities": []}, {"text": "The original variable V that appeared in the call to PLUS-ONE does not change.", "labels": [], "entities": [{"text": "PLUS-ONE", "start_pos": 53, "end_pos": 61, "type": "DATASET", "confidence": 0.7550826668739319}]}, {"text": "STUDENT So, how can I ever write a procedure that swaps two values?", "labels": [], "entities": [{"text": "STUDENT", "start_pos": 0, "end_pos": 7, "type": "METRIC", "confidence": 0.7269642353057861}]}, {"text": "TEACHER You write a procedure that takes addresses of variables as its arguments.", "labels": [], "entities": [{"text": "TEACHER", "start_pos": 0, "end_pos": 7, "type": "METRIC", "confidence": 0.8990500569343567}]}, {"text": "[12] When you call it, you pass the pointers to the variables to be swapped.", "labels": [], "entities": []}, {"text": "So you write SWAP(&X,&Y).", "labels": [], "entities": []}, {"text": "The & sign means take the address of the variable.", "labels": [], "entities": []}, {"text": "When you say &X, the address of X is copied to a temporary variable, and SWAP uses the temporary copy of the address.", "labels": [], "entities": []}, {"text": "But the address always points to the same place, namely the location where X is held.", "labels": [], "entities": []}, {"text": "So SWAP will operate on X, using a copy of X's address, rather than operating on a copy of X.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": []}