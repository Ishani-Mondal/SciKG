{"title": [{"text": "[] [] Incremental Construction of Minimal Acyclic State Automata and Transducers", "labels": [], "entities": []}], "abstractContent": [{"text": "In this paper, we describe anew method for constructing minimal, determin-istic, acyclic finite state automata and transducers.", "labels": [], "entities": []}, {"text": "Traditional methods consist of two steps.", "labels": [], "entities": []}, {"text": "The first one is to construct atrie, the second one-to perform minimization.", "labels": [], "entities": []}, {"text": "Our approach is to construct an automaton in a single step by adding new strings one by one and minimizing the resulting automaton on-the-fly.", "labels": [], "entities": []}, {"text": "We present a general algorithm as well as a specialization that relies upon the lexicographical sorting of the input strings.", "labels": [], "entities": []}], "introductionContent": [{"text": "Finite state automata are used in a variety of applications, such as natural language processing (NLP).", "labels": [], "entities": [{"text": "natural language processing (NLP)", "start_pos": 69, "end_pos": 102, "type": "TASK", "confidence": 0.8054635028044382}]}, {"text": "They may store sets of words or sets of words with annotations, such as the corresponding pronunciation, lexeme, morphotactic categories, et cetera.", "labels": [], "entities": []}, {"text": "The main reasons for the use of finite state automata in the NLP domain are their small size and very short lookup time.", "labels": [], "entities": []}, {"text": "Of particular interest to the NLP community are deterministic, acyclic, finite state automata, which we call dictionaries.", "labels": [], "entities": []}, {"text": "We refer to the set of all such dictionary automata as DAFSA.", "labels": [], "entities": [{"text": "DAFSA", "start_pos": 55, "end_pos": 60, "type": "DATASET", "confidence": 0.9248579740524292}]}, {"text": "Dictionaries can be constructed in various ways, using different data.", "labels": [], "entities": []}, {"text": "(See Watson fora taxonomy of (general) finite state automata construction algorithms.)", "labels": [], "entities": [{"text": "finite state automata construction", "start_pos": 39, "end_pos": 73, "type": "TASK", "confidence": 0.627154640853405}]}, {"text": "A word is simply a finite sequence of symbols over some alphabet (we do not associate them with a meaning during the construction phase).", "labels": [], "entities": []}, {"text": "For the purpose of this article, the input data is a finite sequence of words.", "labels": [], "entities": []}, {"text": "This is a necessary and suificient condition for any resulting deterministic automaton to be acyclic.", "labels": [], "entities": []}, {"text": "The MyhiU-Nerode theorem (see Hopcroft and Ullman) states that among the many automata that accept a given language, there is a unique automaton (excluding isomorphisms) that has a minimal number of states.", "labels": [], "entities": []}, {"text": "This is called the minimal automaton of the language.", "labels": [], "entities": []}, {"text": "The generalized algorithm presented in this paper has been independently developed by Jan Daciuk (he is also the sole developer of the sorted specialization of the algorithm) of the Techni-\u2022 University of Gdazisk and by Richard Watson and Bruce Watson of the IST Technologies Research Group at Ribbit Software Systems Inc.", "labels": [], "entities": []}, {"text": "Jan Daciuk has made his C++ implementations of the algorithms freely available for research purposes at ~n~.pg. gda.", "labels": [], "entities": []}, {"text": "pl/~j andac/f sa. html.", "labels": [], "entities": []}, {"text": "Ribbit's commercial C++ and Java implementations are available via ~.", "labels": [], "entities": []}, {"text": "Ribbit's implementations include several additional features such as a method to remove words from the dictionary (while maintaining \u2022in\u2022reality) and the ability to associate any type of annotation with a word in the dictionary (hence providing an efficient (p-)subsequential transducer implementation).", "labels": [], "entities": []}, {"text": "In addition, it is possible to save a constructed dictionary and reload it on a different platform and implementation fan.", "labels": [], "entities": []}, {"text": "gaiage (without endianess problems).", "labels": [], "entities": []}, {"text": "The algorithms have been used for constructing dictionaries and transducers for spell checking, morphological analysis, two-level morphology, restoration of diacritics and perfect hashing.", "labels": [], "entities": [{"text": "spell checking", "start_pos": 80, "end_pos": 94, "type": "TASK", "confidence": 0.8489112854003906}, {"text": "morphological analysis", "start_pos": 96, "end_pos": 118, "type": "TASK", "confidence": 0.7253853976726532}]}, {"text": "In addition, the algorithms have proven useful in numerous problems outside the field of NLP (for example, DNA sequence matching, computer virus recognition and document indexing).", "labels": [], "entities": [{"text": "DNA sequence matching", "start_pos": 107, "end_pos": 128, "type": "TASK", "confidence": 0.6461535592873892}, {"text": "computer virus recognition", "start_pos": 130, "end_pos": 156, "type": "TASK", "confidence": 0.6626946926116943}, {"text": "document indexing", "start_pos": 161, "end_pos": 178, "type": "TASK", "confidence": 0.7160104960203171}]}], "datasetContent": [], "tableCaptions": []}