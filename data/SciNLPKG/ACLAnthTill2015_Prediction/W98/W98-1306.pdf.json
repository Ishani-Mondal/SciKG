{"title": [{"text": "Treatment of ~-Moves in Subset Construction", "labels": [], "entities": [{"text": "Subset Construction", "start_pos": 24, "end_pos": 43, "type": "TASK", "confidence": 0.7870276570320129}]}], "abstractContent": [{"text": "The paper discusses the problem of determinising finite-state automata containing large numbers of e-moves.", "labels": [], "entities": []}, {"text": "Experiments with finite-state approximations of natural language grammars often give rise to very large automata with a very large number of e-moves.", "labels": [], "entities": []}, {"text": "The paper identifies three subset construction algorithms which treat e-moves.", "labels": [], "entities": []}, {"text": "A number of experiments has been performed which indicate that the algorithms diff~ considerably in practice.", "labels": [], "entities": []}, {"text": "Furthermore, the experiments suggest that the average number of e-moves per state can be used to predict which algorithm is likely to perform best fora given input automatorL", "labels": [], "entities": []}], "introductionContent": [{"text": "In experimenting with finite-state approximation techniques for context-free and more powerful grammatical formalisms (such as the techniques presented in,,) we have found that the resulting automata often are extremely large.", "labels": [], "entities": []}, {"text": "Moreover, the automata contain many e-moves (jumps).", "labels": [], "entities": []}, {"text": "And finally, if such automata are determinised then the resulting automata are often smaller.", "labels": [], "entities": []}, {"text": "It turns out that a straightforward implementation of the subset construction determinisation algorithm performs badly for such inputs.", "labels": [], "entities": []}, {"text": "As a motivating example, consider the definite-clause grammar that has been developed for the OVIS2 Spoken Dialogue System.", "labels": [], "entities": [{"text": "OVIS2 Spoken Dialogue System", "start_pos": 94, "end_pos": 122, "type": "DATASET", "confidence": 0.7281183451414108}]}, {"text": "This grammar is described in detail in van . After removing the feature constraints of this grammar, and after the removal of the sub-grammar for temporal expressions, this context-free skeleton grammar was input to an implementation of the technique described in.", "labels": [], "entities": []}, {"text": "The resulting non-deterministic automaton (labelled zov/s2 below) contains 89832 states, 80935 e-moves, and 80400 transitions.", "labels": [], "entities": []}, {"text": "The determinised automaton contains only 6541 states, and 60781 transitions.", "labels": [], "entities": []}, {"text": "Finally, the minimal automaton contains only 78 states and 526 transitions!", "labels": [], "entities": []}, {"text": "Other grammars give rise to similar numbers.", "labels": [], "entities": []}, {"text": "Thus, the approximation techniques yield particularly 'verbose' automata for relatively simple languages.", "labels": [], "entities": []}, {"text": "The experiments were performed using the FSA Utilities toolkit . At the time, an old version of the toolkit was used, which ran into memory problems for some of these automata.", "labels": [], "entities": [{"text": "FSA Utilities toolkit", "start_pos": 41, "end_pos": 62, "type": "DATASET", "confidence": 0.9445199370384216}]}, {"text": "For this reason,, the subset construction algorithm has been re-implemented, paying special attention to the treatment of e-moves.", "labels": [], "entities": [{"text": "subset construction", "start_pos": 22, "end_pos": 41, "type": "TASK", "confidence": 0.7435481548309326}]}, {"text": "Three variants of the subset construction algorithm are identified which differ in the way e-moves are treated: per graph The most obvious and straightforward approach is sequential in the following sense.", "labels": [], "entities": []}, {"text": "Firstly, an equivalent automaton without e-moves is constructed for the input.", "labels": [], "entities": []}, {"text": "In or-A later implementation by Nederhof (p.c.) avoids construction of the complete non-determistic automaton by determinis'mg and minimising subautomata before they are embedded into larger subautomata.", "labels": [], "entities": []}, {"text": "mm B D der to do this, the transitive closure of the graph consisting of all e-moves is computed.", "labels": [], "entities": []}, {"text": "Secondly, the resulting automaton is then treated by a subset construction algorithm for e-free automata.", "labels": [], "entities": []}, {"text": "per state For each state which occurs in a subset produced during subset construction, compute the states which are reachable using e-moves.", "labels": [], "entities": []}, {"text": "The results of this computation can be memorised, or computed for each state in a preprocessing step.", "labels": [], "entities": []}, {"text": "This is the approach mentioned briefly in.", "labels": [], "entities": []}, {"text": "2 per subset For each subset Q of states which arises during subset construction, compute Q' D Q which extends Q with all states which are reachable from any member of Q using emoves.", "labels": [], "entities": []}, {"text": "Such an algorithm is described in.", "labels": [], "entities": []}, {"text": "We extend this algorithm by memorising the e-closure computation.", "labels": [], "entities": []}, {"text": "\u2022 The motivation for this paper is the experience that the first approach turns out to be impractical for automata with very large numbers of e-moves.", "labels": [], "entities": []}, {"text": "An integration of the subset construction algorithm with the computation of e-reachable states performs much better in practice.", "labels": [], "entities": []}, {"text": "The per subset algorithm almost always performs better than the per state approach.", "labels": [], "entities": []}, {"text": "However, for automata with a low number of jumps, the per graph algorithm outperforms the others.", "labels": [], "entities": []}, {"text": "In constructing an e-free automaton the number of transitions increases.", "labels": [], "entities": []}, {"text": "Given the fact that the input automaton already is extremely large (compared to the simplicity of the language it defines), this is an undesirable situation.", "labels": [], "entities": []}, {"text": "An equivalent e-freeautomaton for the example given above results in an automaton with 2353781 transitions.", "labels": [], "entities": []}, {"text": "The implementation ofper subset is the only variant which succeeds in determinising the input automaton of this example.", "labels": [], "entities": []}, {"text": "In the following section some background information concerning the FSA Utilities toolbox is provided.", "labels": [], "entities": [{"text": "FSA Utilities toolbox", "start_pos": 68, "end_pos": 89, "type": "DATASET", "confidence": 0.8767610788345337}]}, {"text": "Section 3 then presents a short statement of the problem (determinise a given finite-state automaton), and a subset construction algorithm which solves this problem in the absence of e-moves.", "labels": [], "entities": []}, {"text": "Section 4 identifies three variants of the subset construction algorithm which take e-moves into account.", "labels": [], "entities": []}, {"text": "Finally, section 5 discusses some experiments in order to compare the three variants both on randomly generated automata and on automata generated by approximation algorithms.", "labels": [], "entities": []}], "datasetContent": [{"text": "Two sets of experiments have been performed.", "labels": [], "entities": []}, {"text": "In the first set of experiments a number of random automata is generated according to a number of criteria (based on).", "labels": [], "entities": []}, {"text": "In the second set of experiments, results are provided fora number of (much larger) automata that surfaced during actual development work on finite-state approximation techniques.", "labels": [], "entities": []}, {"text": "Firstly, consider a number of experiments for randomly generated automata.", "labels": [], "entities": []}, {"text": "Following, the absolute transition density of an automaton is defined as the number of transitions divided by the square of the number of states times the number of symbols (i.e. the number of transitions divided by the number of possible transitions).", "labels": [], "entities": []}, {"text": "Deterministic transition density is the number of transitions divided by the number of states times the number of symbols (i.e. the ratio of the number of transitions and the number of possible trans~'ons in a deterministic machine).", "labels": [], "entities": []}, {"text": "shows that deterministic transition density is a reliable measure for the difficulty of subset construction.", "labels": [], "entities": [{"text": "subset construction", "start_pos": 88, "end_pos": 107, "type": "TASK", "confidence": 0.7690612971782684}]}, {"text": "Exponential blow-up can be expected for input automata with deterministic transition density of around 2. 5 A number of automata were generated randomly, according to the number of states, symbols, and transition density.", "labels": [], "entities": []}, {"text": "The random generator makes sure that all states are reachable from the start state.", "labels": [], "entities": []}, {"text": "For the first experiment, a number of automata was randomly generated, consisting of 15 symbols, and 15, 20, 25, 100 or 1000 states, using various densities (and no e-moves).", "labels": [], "entities": []}, {"text": "5 Leslie uses the terms absolute density and deterministic density.", "labels": [], "entities": []}, {"text": "The results are summarised in.", "labels": [], "entities": []}, {"text": "Only a single result is given since each of the implementations works equally well in the absence of e-moves.", "labels": [], "entities": []}, {"text": "8 A new concept called absolute jump density is introduced to specify the number of c-moves.", "labels": [], "entities": []}, {"text": "It is defined as the number of e-moves divided by the square of the number of states (i.e., the probability that an e-move exists fora given pair of states).", "labels": [], "entities": []}, {"text": "Furthermore, deterministic jump density is the number of e-moves divided by the number of states (i.e., the average number of ~-moves which leave a given state).", "labels": [], "entities": []}, {"text": "In order to measure the differences between the three implementations, a number of automata has been generated consisting of 15 states and 15 symbols, using various transition densities between 0.01 and 0.3 (for larger densities the automata tend to collapse to an automaton for 27*).", "labels": [], "entities": []}, {"text": "For each of these transition densities, jump densities were chosen in the range 0.01 to 0.24 (again, for larger values the automaton collapses).", "labels": [], "entities": []}, {"text": "In the outcomes of this experiment are summarised by listing the average amount of CPU-time required per deterministic jump density (for each of the three algorithms).", "labels": [], "entities": []}, {"text": "Thus, every dot represents the average for determinising a number of different input automata with various absolute transition densities and the same deterministic jump densi~.", "labels": [], "entities": []}, {"text": "The figures 5, 6 and 7 summarise similar experiments using input automata with 20, 25 and 100 states, z The striking aspect of these experiments is that the per graph algorithm is more efficient for lower deterministic jump densities, whereas, if the deterministic jump density gets larger, the per subset algorithm is more efficient.", "labels": [], "entities": []}, {"text": "The turning point is around a deterministic jump density between I and 1.5~ where it seems that for larger automata the turning point occurs at a 'lower determinisic jump density.", "labels": [], "entities": []}, {"text": "Interestingly, this generalisation is supported by the experiments on automata which were generated by approximation techniques (although the results for randomly generated automata are more consistent than the results for \"real' examples).", "labels": [], "entities": []}, {"text": "Experiment: Automata generated by approximation algorithms The automata used in the previous experiments were randomly generated, according to a number of criteria.", "labels": [], "entities": []}, {"text": "However, it may well be that in practice the automata that are to be treated by the algorithm have typical properties which were not reflected in this test data.", "labels": [], "entities": []}, {"text": "For this reason results are presented fora number of automata that were generated using approximation techniques for context-free grammars.", "labels": [], "entities": []}, {"text": "In particular, a number of automata has been used generated by Mark-Jan Nederhof using the technique described in.", "labels": [], "entities": []}, {"text": "In addition, a small number of automata have been used which were generated using the technique of (as implemented by Nederhof).", "labels": [], "entities": []}, {"text": "The automata typically contain lots of jumps.", "labels": [], "entities": []}, {"text": "Moreover, the number of states of the resulting automaton is often smaller than the number of states in the input automaton, Results are given in table 1.", "labels": [], "entities": []}, {"text": "One of the most striking examples is the ygrim automaton consisting of 3382 states CPU-time was measured on a HP 9000/780 machine running HP-UX 10.20, 240Mb, with SICStus Prolog 3 #3.", "labels": [], "entities": []}, {"text": "For comparison with an \"industrial strength\" implementation, we have applied the determiniser of AT&T's FSM utilities for the same examples.", "labels": [], "entities": []}, {"text": "The results show that for automata with very small transition densities FSM is faster (up to 2 Or 3 times as fast), but for automata with larger densities the results are very similar, in some cases our Prolog implementation is even faster.", "labels": [], "entities": [{"text": "FSM", "start_pos": 72, "end_pos": 75, "type": "METRIC", "confidence": 0.8952444791793823}, {"text": "Prolog", "start_pos": 203, "end_pos": 209, "type": "DATASET", "confidence": 0.9150058627128601}]}, {"text": "Note finally that our timings do include IO, but not the start-up of the Prolog engine.", "labels": [], "entities": [{"text": "timings", "start_pos": 22, "end_pos": 29, "type": "METRIC", "confidence": 0.9730100035667419}, {"text": "IO", "start_pos": 41, "end_pos": 43, "type": "METRIC", "confidence": 0.998572587966919}, {"text": "Prolog engine", "start_pos": 73, "end_pos": 86, "type": "DATASET", "confidence": 0.9712408483028412}]}, {"text": "We also provide the results for FSM again; we used the pipe fsmrmepsilon I fsmdeterminize \u2022 According to Fernando Pereira (pc) the comparison is less meaningful in this case because the fsmrmepsilon program treats weighted automata.", "labels": [], "entities": [{"text": "FSM", "start_pos": 32, "end_pos": 35, "type": "DATASET", "confidence": 0.5290030241012573}]}, {"text": "This generalisation requires some overhead also in case no weights are used (for the determiniser this generalisation does not lead to any significant overhead).", "labels": [], "entities": []}, {"text": "Pereira mentions furthermore that FSM used to include a determiniser with integrated treatment of jumps.", "labels": [], "entities": [{"text": "FSM", "start_pos": 34, "end_pos": 37, "type": "TASK", "confidence": 0.6325374841690063}]}, {"text": "Because this version could not (easily) be generalised for weighted automata it was dropped from the tool-set.", "labels": [], "entities": []}], "tableCaptions": []}