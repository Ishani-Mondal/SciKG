{"title": [{"text": "Implementing Voting Constraints with Finite State Transducers", "labels": [], "entities": [{"text": "Implementing Voting Constraints", "start_pos": 0, "end_pos": 31, "type": "TASK", "confidence": 0.8995757500330607}]}], "abstractContent": [{"text": "We describe a constraint-based morphological disambiguation system in which individual constraint rules vote on matching morphological parses followed by its implementation using finite state transducers.", "labels": [], "entities": []}, {"text": "Voting constraint rules have a number of desirable properties: The outcome of the disambiguation is independent of the order of application of the local contextual constraint rules.", "labels": [], "entities": []}, {"text": "Thus the rule developer is relieved from worrying about conflicting rule sequencing.", "labels": [], "entities": []}, {"text": "The approach can also combine statistically and manually obtained constraints, and incorporate negative constraints that rule out certain patterns.", "labels": [], "entities": []}, {"text": "The transducer implementation has a number of desirable properties compared to other finite state tagging and light parsing approaches, implemented with automata intersection.", "labels": [], "entities": [{"text": "finite state tagging and light parsing", "start_pos": 85, "end_pos": 123, "type": "TASK", "confidence": 0.6554410109917322}]}, {"text": "The most important of these is that since constraints do not remove parses there is no risk of an overzealous constraint \"killing a sentence ~ by removing all parses of a token during intersection.", "labels": [], "entities": []}, {"text": "After a description of our approach we present preliminary results from tagging the Wall Street Journal Corpus with this approach.", "labels": [], "entities": [{"text": "Wall Street Journal Corpus", "start_pos": 84, "end_pos": 110, "type": "DATASET", "confidence": 0.9799598753452301}]}, {"text": "With about 400 statistically derived constraints and about 570 manual constraints , we can attain an accuracy of 97.82% on the training corpus and 97.29% on the test corpus.", "labels": [], "entities": [{"text": "accuracy", "start_pos": 101, "end_pos": 109, "type": "METRIC", "confidence": 0.9996836185455322}]}, {"text": "We then describe a finite state implementation of our approach and discuss various related issues.", "labels": [], "entities": []}], "introductionContent": [{"text": "We describe a finite state implementation of a constraint-based morphological disambiguation system in which individual constraints vote on matching morphological parses and disambiguation of all tokens in a sentence is performed at the end, by selecting parses that collectively makeup the the highest voted combination.", "labels": [], "entities": []}, {"text": "The approach depends on assigning votes to constraints via statistical and/or manual means, and then letting constraint rules cast votes on matching parses of a given lexical item.", "labels": [], "entities": []}, {"text": "This approach does not reflect the outcome of matching constraint rules to the set of morphological parses immediately.", "labels": [], "entities": []}, {"text": "Only after all applicable rules are applied to a sentence, all tokens are disambiguated in parallel.", "labels": [], "entities": []}, {"text": "Thus, the outcome of the rule applications is independent of the order of rule applications.", "labels": [], "entities": []}, {"text": "Constraint-based morphological disambiguation systems (e.g.) typically look at a context of several sequential tokens each annotated with their possible morphological interpretations (or tags), and in a reductionistic way, remove parses that are considered to be impossible in the given context.", "labels": [], "entities": []}, {"text": "Since constraint rule application is ordered, parses removed by one rule may not be used or referred to in subsequent rule applications.", "labels": [], "entities": []}, {"text": "Addition of anew rule requires that its place in the sequence be carefully determined to avoid any undesirable interactions.", "labels": [], "entities": [{"text": "anew", "start_pos": 12, "end_pos": 16, "type": "METRIC", "confidence": 0.9856350421905518}]}, {"text": "Automata intersection based approaches run the risk of deleting all parses of a sentence, and have also been observed to end up with large intersected machines.", "labels": [], "entities": []}, {"text": "Our approach eliminates the ordering problem, since parse removals are not committed during application, but only after all rules are processed.", "labels": [], "entities": [{"text": "parse removals", "start_pos": 52, "end_pos": 66, "type": "TASK", "confidence": 0.8190109431743622}]}, {"text": "highlights the voting congtraints paradigm..", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": [{"text": " Table 1. Performance with 2,3, 4 and 5-gram voting constraints", "labels": [], "entities": []}, {"text": " Table 2. Results from tagging with both statistically and manually derived voting constraints rules", "labels": [], "entities": [{"text": "tagging", "start_pos": 23, "end_pos": 30, "type": "TASK", "confidence": 0.9699013829231262}]}]}