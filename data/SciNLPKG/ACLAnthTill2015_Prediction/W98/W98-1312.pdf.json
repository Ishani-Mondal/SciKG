{"title": [{"text": "Constraining Separated Morphotactic Dependencies in Finite-State Grammars", "labels": [], "entities": []}], "abstractContent": [{"text": "[Morphology, Morphotactics, Finite State, Separated Dependencies] This paper examines dependencies between separated (non-adjacent) morphemes in natural-language words and a variety of ways to constrain them in finite-state morphology.", "labels": [], "entities": []}, {"text": "Methods include running separate constraining transducers at runtime, composing in constraints at compile time, feature unification, and the use of FLAG DIACRITICS.", "labels": [], "entities": [{"text": "feature unification", "start_pos": 112, "end_pos": 131, "type": "TASK", "confidence": 0.7513928115367889}]}, {"text": "Examples are provided from Modern Standard Arabic.", "labels": [], "entities": [{"text": "Modern Standard Arabic", "start_pos": 27, "end_pos": 49, "type": "DATASET", "confidence": 0.9191962679227194}]}, {"text": "In choosing a practical solution, developers must iveigh the size, performance and flexibility of the overall system.", "labels": [], "entities": []}], "introductionContent": [{"text": "In finite-state morphotactics, the efficient constraint of separated (non-adjacent) morpheme dependencies is a serious practical challenge.", "labels": [], "entities": []}, {"text": "This paper will examine some typical separated dependencies, using examples from Modem Standard Arabic, showing various methods that have been invented, and perhaps reinvented several times, to block lexical overgeneration.", "labels": [], "entities": [{"text": "Modem Standard Arabic", "start_pos": 81, "end_pos": 102, "type": "DATASET", "confidence": 0.8702083230018616}]}, {"text": "The challenge in working systems is to enforce the necessary constraints without causing the lexicons to explode in size and without slowing the nmtime performance too badly.", "labels": [], "entities": []}, {"text": "The term MORPHOLOGY, as used by linguists in the Two-Level and Finite-State traditions, encompasses both MORPHOTACTICS (also called MORPHOSYNTAX), and the phonological or orthographical VARIATION rules that map between LEXICAL strings (i.e. abstract or underlying strings) and SURFACE strings.", "labels": [], "entities": []}, {"text": "The theory and practical use of finite-state variation rules are well documented and will not be dealt with here.", "labels": [], "entities": []}, {"text": "In the area of morphotactics, the commonly available languages for finite-state lexical specification provide linguists with a notation wherein related classes of morphemes, e.g. verb endings, noun endings, direct-object clitic suffixes, etc., are grouped together into sublexicons, and each individual morpheme is assigned a CONTINUATION CLASS which designates which subclasses of morphemes can follow it in a valid word.", "labels": [], "entities": [{"text": "finite-state lexical specification", "start_pos": 67, "end_pos": 101, "type": "TASK", "confidence": 0.6976383725802103}]}, {"text": "In formal terms, the grouping together of related morphemes into sublexicons translates into the union operation, and continuations translate into the concatenation operation.", "labels": [], "entities": []}, {"text": "As far as concatenating languages are concerned, these two finite-state operations are often sufficient for defining the language of possible lexical strings.", "labels": [], "entities": []}, {"text": "Where there are morphotaetie dependencies, i.e. where some morphemes require or prohibit the appearance of other morphemes in a word, and where the morphemes in question are adjacent, the necessary dependencies can be constrained via appropriate definition of the continuation classes.", "labels": [], "entities": []}, {"text": "However, when similar co-occurrence restrictions exist between morphemes that are physically separated in a word, then the continuation-class notation breaks down and must be supplemented by one of the mechanisms to be discussed below.", "labels": [], "entities": []}, {"text": "We shall conclude with a presentation of FLAG DIACRITICS as a practical compromise that keeps lexicons small, runs efficiently, provides linguists with a notation reminiscent of feature-unification, and is compatible with general finite-state computation.", "labels": [], "entities": [{"text": "FLAG", "start_pos": 41, "end_pos": 45, "type": "METRIC", "confidence": 0.6529653072357178}]}], "datasetContent": [], "tableCaptions": []}