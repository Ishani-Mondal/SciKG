{"title": [], "abstractContent": [{"text": "There has been recent interest in the problem of decoding letter substitution ciphers using techniques inspired by natural language processing.", "labels": [], "entities": [{"text": "decoding letter substitution ciphers", "start_pos": 49, "end_pos": 85, "type": "TASK", "confidence": 0.6678868234157562}]}, {"text": "We consider a different type of classical encoding scheme known as the running key cipher, and propose a search solution using Gibbs sampling with a word language model.", "labels": [], "entities": []}, {"text": "We evaluate our method on synthetic cipher-texts of different lengths, and find that it out-performs previous work that employs Viterbi decoding with character-based models.", "labels": [], "entities": []}], "introductionContent": [{"text": "The running key cipher is an encoding scheme that uses a secret key R that is typically a string of words, usually taken from a book or other text that is agreed upon by the sender and receiver.", "labels": [], "entities": []}, {"text": "When sending a plaintext message P , the sender truncates R to the length of the plaintext.", "labels": [], "entities": []}, {"text": "The scheme also relies on a substitution function f , which is usually publicly known, that maps a plaintext letter p and key letter r to a unique ciphertext letter c.", "labels": [], "entities": []}, {"text": "The most common choice for f is the tabula recta, where c = (p + r) mod 26 for letters in the English alphabet, with A = 0, B = 1, and soon.", "labels": [], "entities": [{"text": "A", "start_pos": 117, "end_pos": 118, "type": "METRIC", "confidence": 0.9565548300743103}]}, {"text": "To encode a plaintext with a running key, the spaces in the plaintext and the key are removed, and for every 0 \u2264 i < |P |, the ciphertext letter at position i is computed to be Ci \u2190 f (P i , R i ).", "labels": [], "entities": []}, {"text": "shows an example encoding using the tabula recta.", "labels": [], "entities": []}, {"text": "For a given ciphertext and known f , the plaintext uniquely determines the running key and vice versa.", "labels": [], "entities": []}, {"text": "* Research conducted while the author was visiting ISI.", "labels": [], "entities": [{"text": "ISI", "start_pos": 51, "end_pos": 54, "type": "DATASET", "confidence": 0.8942298293113708}]}, {"text": "Since we know that the plaintext and running key are both drawn from natural language, our objective function for the solution plaintext under some language model is: where the running key R P,C is the key that corresponds to plaintext P and ciphertext C.", "labels": [], "entities": []}, {"text": "Note that if R P,C is a perfectly random sequence of letters, this scheme is effectively a 'one-time pad', which is provably unbreakable.", "labels": [], "entities": []}, {"text": "The knowledge that both the plaintext and the key are natural language strings is important in breaking a running key cipher.", "labels": [], "entities": []}, {"text": "The letter-frequency distribution of running key ciphertexts is notably flatter than than the plaintext distribution, unlike substitution ciphers where the frequency profile remains unchanged, modulo letter substitutions.", "labels": [], "entities": []}, {"text": "However, the ciphertext letter distribution is not uniform; there are peaks corresponding to letters (like I) that are formed by high-frequency plaintext/key pairs (like E and E).", "labels": [], "entities": []}], "datasetContent": [{"text": "For comparison with the previous work, we reimplement Viterbi decoding over letter 6-grams) trained on the Brown Corpus.", "labels": [], "entities": [{"text": "Brown Corpus", "start_pos": 107, "end_pos": 119, "type": "DATASET", "confidence": 0.9821207523345947}]}, {"text": "In addition to decipherment accuracy, we compare the running time in seconds of the two algorithms.", "labels": [], "entities": [{"text": "accuracy", "start_pos": 28, "end_pos": 36, "type": "METRIC", "confidence": 0.9936233162879944}]}, {"text": "Both decipherment programs were implemented in Python and run on the same machines.", "labels": [], "entities": []}, {"text": "The Gibbs Sampler was run for 10000 iterations.", "labels": [], "entities": [{"text": "Gibbs Sampler", "start_pos": 4, "end_pos": 17, "type": "DATASET", "confidence": 0.9588286280632019}]}, {"text": "As in the Griffing paper, since the plaintext and running key are interchangeable, we measure the accuracy of a hypothesized solution against the reference as the max of the accuracy between the hypothesized plaintext and the reference plaintext, and the hypothesized plaintext and the reference key.", "labels": [], "entities": [{"text": "accuracy", "start_pos": 98, "end_pos": 106, "type": "METRIC", "confidence": 0.9992135763168335}, {"text": "accuracy", "start_pos": 174, "end_pos": 182, "type": "METRIC", "confidence": 0.998170018196106}]}, {"text": "shows the average decipherment accuracy of our algorithm and the baseline on each dataset.", "labels": [], "entities": [{"text": "accuracy", "start_pos": 31, "end_pos": 39, "type": "METRIC", "confidence": 0.9856991171836853}]}, {"text": "Also shown is the number of times that the Gibbs Sampling search failed -that is, when the algorithm did not hypothesize a solution that had a probability at least as high as the reference within 10000 iterations.", "labels": [], "entities": []}], "tableCaptions": [{"text": " Table 2: Decipherment accuracy (proportion of correctly deciphered characters). Plaintext and key sources for the  ciphertext test data were extracted by starting at random points in the corpora, and selecting the following n characters.", "labels": [], "entities": [{"text": "accuracy", "start_pos": 23, "end_pos": 31, "type": "METRIC", "confidence": 0.9789713621139526}]}, {"text": " Table 3: Substitution function parameterized by the keyword, CIPHER. f (p, r) is the entry in the row corresponding to p and the", "labels": [], "entities": [{"text": "CIPHER", "start_pos": 62, "end_pos": 68, "type": "METRIC", "confidence": 0.6602123379707336}]}]}