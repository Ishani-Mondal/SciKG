{"title": [{"text": "A Comparative Study of Target Dependency Structures for Statistical Machine Translation", "labels": [], "entities": [{"text": "Statistical Machine Translation", "start_pos": 56, "end_pos": 87, "type": "TASK", "confidence": 0.8623844583829244}]}], "abstractContent": [{"text": "This paper presents a comparative study of target dependency structures yielded by several state-of-the-art linguistic parsers.", "labels": [], "entities": []}, {"text": "Our approach is to measure the impact of these non-isomorphic dependency structures to be used for string-to-dependency translation.", "labels": [], "entities": [{"text": "string-to-dependency translation", "start_pos": 99, "end_pos": 131, "type": "TASK", "confidence": 0.7303957343101501}]}, {"text": "Besides using traditional dependency parsers, we also use the dependency structures transformed from PCFG trees and predicate-argument structures (PASs) which are generated by an HPSG parser and a CCG parser.", "labels": [], "entities": []}, {"text": "The experiments on Chinese-to-English translation show that the HPSG parser's PASs achieved the best dependency and translation accuracies.", "labels": [], "entities": [{"text": "Chinese-to-English translation", "start_pos": 19, "end_pos": 49, "type": "TASK", "confidence": 0.6759548634290695}]}], "introductionContent": [{"text": "Target language side dependency structures have been successfully used in statistical machine translation (SMT) by and achieved state-of-the-art results as reported in the NIST 2008 Open MT Evaluation workshop and the NTCIR-9 Chinese-to-English patent translation task.", "labels": [], "entities": [{"text": "statistical machine translation (SMT)", "start_pos": 74, "end_pos": 111, "type": "TASK", "confidence": 0.802739347020785}, {"text": "NIST 2008 Open MT Evaluation workshop", "start_pos": 172, "end_pos": 209, "type": "TASK", "confidence": 0.7291365067164103}, {"text": "NTCIR-9 Chinese-to-English patent translation task", "start_pos": 218, "end_pos": 268, "type": "TASK", "confidence": 0.840302562713623}]}, {"text": "A primary advantage of dependency representations is that they have a natural mechanism for representing discontinuous constructions, which arise due to longdistance dependencies or in languages where grammatical relations are often signaled by morphology instead of word order.", "labels": [], "entities": []}, {"text": "It is known that dependency-style structures can be transformed from a number of linguistic struc- * Now at Baidu Inc.", "labels": [], "entities": [{"text": "Baidu Inc.", "start_pos": 108, "end_pos": 118, "type": "DATASET", "confidence": 0.9273731907208761}]}, {"text": "\u2020 Now at Nara Institute of tures.", "labels": [], "entities": [{"text": "Nara Institute of tures", "start_pos": 9, "end_pos": 32, "type": "DATASET", "confidence": 0.9505270719528198}]}, {"text": "For example, using the constituent-todependency conversion approach proposed by, we can easily yield dependency trees from PCFG style trees.", "labels": [], "entities": []}, {"text": "A semantic dependency representation of a whole sentence, predicate-argument structures (PASs), are also included in the output trees of (1) a state-of-the-art head-driven phrase structure grammar (HPSG)) parser, Enju 1 ( and (2) a state-of-the-art CCG parser 2.", "labels": [], "entities": []}, {"text": "The motivation of this paper is to investigate the impact of these non-isomorphic dependency structures to be used for SMT.", "labels": [], "entities": [{"text": "SMT", "start_pos": 119, "end_pos": 122, "type": "TASK", "confidence": 0.9960765242576599}]}, {"text": "That is, we would like to provide a comparative evaluation of these dependencies in a string-to-dependency decoder).", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": [{"text": " Table 3: Comparison of dependency and translation accuracies. Moses-1 = phrasal, Moses-2 = hierarchical.", "labels": [], "entities": []}, {"text": " Table 2: Comparison of the dependencies of the English  sentences in the training data. Without () = % of similar  root words; with () = % of similar head words.", "labels": [], "entities": []}]}