{"title": [{"text": "Using Paraphrases of Deep Semantic Representions to Support Regression Testing in Spoken Dialogue Systems", "labels": [], "entities": []}], "abstractContent": [{"text": "Rule-based spoken dialogue systems require a good regression testing framework if they are to be maintainable.", "labels": [], "entities": []}, {"text": "We argue that there is a tension between two extreme positions when constructing the database of test examples.", "labels": [], "entities": []}, {"text": "On the one hand, if the examples consist of input/output tuples representing many levels of internal processing, they are fine-grained enough to catch most processing errors , but unstable undermost system modifications.", "labels": [], "entities": []}, {"text": "If the examples are pairs of user input and final system output, they are much more stable, but too coarse-grained to catch many errors.", "labels": [], "entities": []}, {"text": "In either case, there are fairly severe difficulties in judging examples correctly.", "labels": [], "entities": []}, {"text": "We claim that a good compromise can be reached by implementing a paraphrasing mechanism which maps internal semantic representations into surface forms, and carrying out regression testing using paraphrases of semantic forms rather than the semantic forms themselves.", "labels": [], "entities": []}, {"text": "We describe an implementation of the idea using the Open Source Regulus toolkit, where paraphrases are produced using Regulus grammars compiled in generation mode.", "labels": [], "entities": []}, {"text": "Paraphrases can also be used at run-time to produce confirmations.", "labels": [], "entities": []}, {"text": "By compiling the paraphrase grammar a second time, as a recogniser, it is possible in a simple and natural way to guarantee that confirmations are always within system coverage.", "labels": [], "entities": []}], "introductionContent": [{"text": "Design features that enable important functionality in medium vocabulary, mixed-initiative spoken dialogue systems also create challenges for the project cycle, and in particular for regression testing.", "labels": [], "entities": []}, {"text": "Two issues that make regression testing particularly difficult are the need for context dependent interpretation, and the use of multiple levels of representation.", "labels": [], "entities": [{"text": "regression testing", "start_pos": 21, "end_pos": 39, "type": "TASK", "confidence": 0.951334536075592}, {"text": "context dependent interpretation", "start_pos": 80, "end_pos": 112, "type": "TASK", "confidence": 0.6349176367123922}]}, {"text": "Both of these features are typically necessary for non-trivial dialogue systems of this type.", "labels": [], "entities": []}, {"text": "Multiple levels of processing, as usual, provide necessary modularity.", "labels": [], "entities": []}, {"text": "Context dependent interpretation enables responses that are tuned to the current circumstances of the interaction or the world, and frequently helps resolve ambiguity.", "labels": [], "entities": [{"text": "Context dependent interpretation", "start_pos": 0, "end_pos": 32, "type": "TASK", "confidence": 0.6601818899313608}]}, {"text": "The implications for regression testing, though, are less happy.", "labels": [], "entities": [{"text": "regression testing", "start_pos": 21, "end_pos": 39, "type": "TASK", "confidence": 0.9432383179664612}]}, {"text": "The context of each interaction in the test suite needs to be stored as part of the interaction.", "labels": [], "entities": []}, {"text": "Multiple levels of representation that are, for example, useful for doing ellipsis resolution or reference resolution, also complicate testing.", "labels": [], "entities": [{"text": "ellipsis resolution", "start_pos": 74, "end_pos": 93, "type": "TASK", "confidence": 0.7095002382993698}, {"text": "reference resolution", "start_pos": 97, "end_pos": 117, "type": "TASK", "confidence": 0.7743829488754272}]}, {"text": "If regression testing is done on each separate level of processing, or involves internal representations, small changes to a representation atone level can mean having to revise and rejudge the entire test suite to keep it up to date.", "labels": [], "entities": []}, {"text": "This paper discusses the methodology we have developed to address regression testing issues within the Regulus framework.) is an Open Source toolkit for builting medium vocabulary spoken dialogue and translation applications, and has been used to build a number of non-trivial spoken dialogue systems.", "labels": [], "entities": [{"text": "Regulus framework.", "start_pos": 103, "end_pos": 121, "type": "DATASET", "confidence": 0.9225495457649231}, {"text": "builting medium vocabulary spoken dialogue and translation", "start_pos": 153, "end_pos": 211, "type": "TASK", "confidence": 0.6013607808521816}]}, {"text": "Prominent examples include NASA's Clarissa Procedure Navigator (), Geneva University's multi-modal mobile-platform Calendar application ( , SDS, a prototype in-car system developed by UC Santa Cruz in collaboration with Ford Motors Research which was voted first in Ford's 2007 internal technology fair, and Taxi, a speech-enabled game in which the user interacts with a simulated cabdriver to navigate around a map of Manhattan.", "labels": [], "entities": []}, {"text": "It has also been used to build the MedSLT medical speech translation system.", "labels": [], "entities": [{"text": "MedSLT medical speech translation", "start_pos": 35, "end_pos": 68, "type": "TASK", "confidence": 0.6752869635820389}]}, {"text": "The Regulus platform includes tools for developing feature grammars, and compiling them in various ways.", "labels": [], "entities": [{"text": "Regulus platform", "start_pos": 4, "end_pos": 20, "type": "DATASET", "confidence": 0.9483800232410431}]}, {"text": "In particular, it is possible to compile grammars into generators, and use them to support paraphrasing from the internal semantic representations created during dialogue processing.", "labels": [], "entities": []}, {"text": "This capability is key to the newest part of our regression testing approach, and is discussed in detail in Section 3.", "labels": [], "entities": [{"text": "regression testing", "start_pos": 49, "end_pos": 67, "type": "TASK", "confidence": 0.9541747272014618}]}, {"text": "First, though, Section 2 gives an overview of Regulus and the architecture of Regulus-based systems; we discuss features that complicate regression testing, and how to address these problems within this type of architecture.", "labels": [], "entities": [{"text": "Regulus", "start_pos": 46, "end_pos": 53, "type": "DATASET", "confidence": 0.7831767201423645}]}, {"text": "Section 4 discusses how test suites are constructed and what types of items they may contain.", "labels": [], "entities": []}, {"text": "In Section 5 we show how paraphrases can also be included in the run-time architecture.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": [{"text": " Table 1: Examples of regression testing tuples in the English Calendar system. Each tuple shows the current world  context (timestamp and speaker), the preceding paraphrase, the input, and the paraphrase produced from it.", "labels": [], "entities": [{"text": "English Calendar system", "start_pos": 55, "end_pos": 78, "type": "DATASET", "confidence": 0.9429216583569845}]}]}