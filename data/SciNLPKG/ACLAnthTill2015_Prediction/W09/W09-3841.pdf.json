{"title": [{"text": "Parsing Directed Acyclic Graphs with Range Concatenation Grammars", "labels": [], "entities": []}], "abstractContent": [{"text": "Range Concatenation Grammars (RCGs) area syntactic formalism which possesses many attractive properties.", "labels": [], "entities": [{"text": "Range Concatenation Grammars (RCGs", "start_pos": 0, "end_pos": 34, "type": "TASK", "confidence": 0.6893206417560578}]}, {"text": "It is more powerful than Linear Context-Free Rewriting Systems, though this power is not reached to the detriment of efficiency since its sentences can always be parsed in polynomial time.", "labels": [], "entities": []}, {"text": "If the input, instead of a string, is a Directed Acyclic Graph (DAG), only simple RCGs can still be parsed in polynomial time.", "labels": [], "entities": []}, {"text": "For non-linear RCGs, this polynomial parsing time cannot be guaranteed anymore.", "labels": [], "entities": []}, {"text": "In this paper, we show how the standard parsing algorithm can be adapted for parsing DAGs with RCGs, both in the linear (simple) and in the non-linear case.", "labels": [], "entities": [{"text": "parsing DAGs", "start_pos": 77, "end_pos": 89, "type": "TASK", "confidence": 0.8605642318725586}]}], "introductionContent": [{"text": "The Range Concatenation Grammar (RCG) formalism has been introduced by Boullier ten years ago.", "labels": [], "entities": [{"text": "Range Concatenation Grammar (RCG) formalism", "start_pos": 4, "end_pos": 47, "type": "TASK", "confidence": 0.7594388127326965}]}, {"text": "A complete definition can be found in, together with some of its formal properties and a parsing algorithm (qualified hereof standard) which runs in polynomial time.", "labels": [], "entities": []}, {"text": "In this paper we shall only consider the positive version of RCGs which will be abbreviated as PRCG.", "labels": [], "entities": [{"text": "PRCG", "start_pos": 95, "end_pos": 99, "type": "DATASET", "confidence": 0.9057365655899048}]}, {"text": "PRCGs are very attractive since they are more powerful than the Linear Context-Free Rewriting Systems (LCFRSs) by.", "labels": [], "entities": []}, {"text": "In fact LCFRSs are equivalent to simple PRCGs which area subclass of PRCGs.", "labels": [], "entities": []}, {"text": "Many Mildly ContextSensitive (MCS) formalisms, including Tree Adjoining Grammars (TAGs) and various kinds of Multi-Component TAGs, have already been Negative RCGs do not add formal power since both versions exactly cover the class PTIME of languages recognizable in deterministic polynomial time (see) for an indirect proof and () fora direct proof).", "labels": [], "entities": []}, {"text": "translated into their simple PRCG counterpart in order to get an efficient parser for free (see for example ().", "labels": [], "entities": []}, {"text": "However, in many Natural Language Processing applications, the most suitable input fora parser is not a sequence of words (forms, terminal symbols), but a more complex representation, usually defined as a Direct Acyclic Graph (DAG), which correspond to finite regular languages, for taking into account various kinds of ambiguities.", "labels": [], "entities": []}, {"text": "Such ambiguities may come, among others, from the output of speech recognition systems, from lexical ambiguities (and in particular from tokenization ambiguities), or from a nondeterministic spelling correction module.", "labels": [], "entities": [{"text": "spelling correction", "start_pos": 191, "end_pos": 210, "type": "TASK", "confidence": 0.7891708016395569}]}, {"text": "Yet, it has been shown by) that parsing of regular languages (and therefore of DAGs) using simple PRCGs is polynomial.", "labels": [], "entities": []}, {"text": "In the same paper, it is also proven that parsing of finite regular languages (the DAG case) using arbitrary RCGs is NP-complete.", "labels": [], "entities": [{"text": "parsing of finite regular languages", "start_pos": 42, "end_pos": 77, "type": "TASK", "confidence": 0.8514682292938233}]}, {"text": "This papers aims at showing how these complexity results can be made concrete in a parser, by extending a standard RCG parsing algorithm so as to handle input DAGs.", "labels": [], "entities": []}, {"text": "We will first recall both some basic definitions and their notations.", "labels": [], "entities": []}, {"text": "Afterwards we will see, with a slight modification of the notion of ranges, how it is possible to use the standard PRCG parsing algorithm to get in polynomial time a parse forest with a DAG as input.", "labels": [], "entities": [{"text": "PRCG parsing", "start_pos": 115, "end_pos": 127, "type": "TASK", "confidence": 0.731086790561676}]}, {"text": "However, the resulting parse forest is valid only for simple PRCGs.", "labels": [], "entities": []}, {"text": "In the non-linear case, and consistently with the complexity results mentioned above, we show that the resulting parse forest needs further processing for filtering out inconsistent parses, which may need an exponential time.", "labels": [], "entities": []}, {"text": "The proposed filtering algorithm allows for parsing DAGs in practice with any PRCG, including non-linear ones.", "labels": [], "entities": [{"text": "parsing DAGs", "start_pos": 44, "end_pos": 56, "type": "TASK", "confidence": 0.8610031604766846}]}], "datasetContent": [], "tableCaptions": []}