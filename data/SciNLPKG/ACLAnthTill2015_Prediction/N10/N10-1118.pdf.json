{"title": [{"text": "Optimal Parsing Strategies for Linear Context-Free Rewriting Systems", "labels": [], "entities": []}], "abstractContent": [{"text": "Factorization is the operation of transforming a production in a Linear Context-Free Rewriting System (LCFRS) into two simpler productions by factoring out a subset of the nontermi-nals on the production's righthand side.", "labels": [], "entities": []}, {"text": "Fac-torization lowers the rank of a production but may increase its fan-out.", "labels": [], "entities": [{"text": "Fac-torization", "start_pos": 0, "end_pos": 14, "type": "METRIC", "confidence": 0.8282837867736816}]}, {"text": "We show how to apply factorization in order to minimize the parsing complexity of the resulting grammar, and study the relationship between rank, fan-out, and parsing complexity.", "labels": [], "entities": []}, {"text": "We show that it is always possible to obtain optimum parsing complexity with rank two.", "labels": [], "entities": []}, {"text": "However, among transformed grammars of rank two, minimum parsing complexity is not always possible with minimum fan-out.", "labels": [], "entities": []}, {"text": "Applying our factorization algorithm to LCFRS rules extracted from dependency treebanks allows us to find the most efficient parsing strategy for the syntactic phenomena found in non-projective trees.", "labels": [], "entities": []}], "introductionContent": [{"text": "G\u00f3mez- recently examined the problem of transforming arbitrary grammars in the Linear Context-Free Rewriting System (LCFRS) formalism) in order to reduce the rank of a grammar to 2 while minimizing its fan-out.", "labels": [], "entities": []}, {"text": "The work was motivated by the desire to develop efficient chart-parsing algorithms for non-projective dependency trees () that do not rely on the independence assumptions of spanning tree algorithms).", "labels": [], "entities": []}, {"text": "Efficient parsing algorithms for general LCFRS are also relevant in the context of Synchronous Context-Free Grammars (SCFGs) as a formalism for machine translation, as well as the desire to handle even more general synchronous grammar formalisms which allow nonterminals to cover discontinuous spans in either language ().", "labels": [], "entities": [{"text": "machine translation", "start_pos": 144, "end_pos": 163, "type": "TASK", "confidence": 0.7340767085552216}]}, {"text": "LCFRS provides a very general formalism which subsumes SCFGs, the Multitext Grammars of, as well as mildly context-sensitive monolingual formalisms such as Tree Adjoining Grammar).", "labels": [], "entities": [{"text": "LCFRS", "start_pos": 0, "end_pos": 5, "type": "DATASET", "confidence": 0.9338255524635315}]}, {"text": "Thus, work on transforming general LCFRS grammars promises to be widely applicable in both understanding how these formalisms interrelate, and, from a more practical viewpoint, deriving efficient parsing algorithms for them.", "labels": [], "entities": []}, {"text": "In this paper, we focus on the problem of transforming an LCFRS grammar into an equivalent grammar for which straightforward application of dynamic programming to each rule yields a tabular parsing algorithm with minimum complexity.", "labels": [], "entities": []}, {"text": "This is closely related, but not equivalent, to the problem considered by, who minimize the fan-out, rather than the parsing complexity, of the resulting grammar.", "labels": [], "entities": []}, {"text": "In Section 4, we show that restricting our attention to factorized grammars with rank no greater than 2 comes at no cost in parsing complexity.", "labels": [], "entities": []}, {"text": "This result maybe surprising, as comment that \"there maybe cases in which one has to find an optimal trade-off between rank and fan-out\" in order to minimize parsing complexity -in fact, no such trade-off is necessary, as rank 2 is always sufficient for optimal parsing complexity.", "labels": [], "entities": []}, {"text": "Given this fact, we show how to adapt the factorization algorithm of G\u00f3mez- to return a transformed grammar with minimal parsing complexity and rank 2.", "labels": [], "entities": []}, {"text": "In Section 5, we give a counterexample to the conjecture that minimal parsing complexity is possible among binarizations with minimal fan-out.", "labels": [], "entities": []}], "datasetContent": [{"text": "A number of recent papers have examined dynamic programming algorithms for parsing non-projective dependency structures by exploring how well various categories of polynomially-parsable grammars cover the structures found in dependency treebanks for various languages (.", "labels": [], "entities": [{"text": "parsing non-projective dependency structures", "start_pos": 75, "end_pos": 119, "type": "TASK", "confidence": 0.8726496547460556}]}, {"text": "give an algorithm for extracting LCFRS rules from dependency structures.", "labels": [], "entities": []}, {"text": "One rule is extracted for each word in the dependency tree.", "labels": [], "entities": []}, {"text": "The rank of the rule is the number of children that the word has in the dependency tree, as shown by the example in.", "labels": [], "entities": []}, {"text": "The fan-out of the symbol corresponding to a word is the number of continuous intervals in the sentence formed by the word and its descendants in the tree.", "labels": [], "entities": []}, {"text": "Projec-complexity arabic czech danish dutch german port swedish  tive trees yield LCFRS rules of fan-out one and parsing complexity three, while the fan-out and parsing complexity from non-projective trees are in principle unbounded.", "labels": [], "entities": []}, {"text": "Extracting LCFRS rules from treebanks allows us to study how many of the rules fall within certain constraints.", "labels": [], "entities": []}, {"text": "give an algorithm for binarizing LCRFS rules without increasing the rules' fan-out; however, this is not always possible, and the algorithm does not succeed even in some cases for which such a binarization is possible.", "labels": [], "entities": []}, {"text": "find that all but 0.02% of productions in the CoNLL 2006 training data, which includes various languages, can be binarized by their algorithm, but they do not give the fan-out or parsing complexity of the resulting rules.", "labels": [], "entities": [{"text": "CoNLL 2006 training data", "start_pos": 46, "end_pos": 70, "type": "DATASET", "confidence": 0.9726898968219757}]}, {"text": "In related work, define the class of mildly ill-nested dependency structures of varying gap degrees; gap degree is essentially fanout minus one.", "labels": [], "entities": [{"text": "gap degree", "start_pos": 101, "end_pos": 111, "type": "METRIC", "confidence": 0.9567528069019318}]}, {"text": "For a given gap degree k, this class of grammars can be parsing in time O(n 3k+4 ) for lexicalized grammars.", "labels": [], "entities": []}, {"text": "study dependency treebanks for nine languages and find that all dependency structures meet the mildly ill-nested condition in the dependency treebanks for some gap degree.", "labels": [], "entities": []}, {"text": "However, they do not report the maximum gap degree or parsing complexity.", "labels": [], "entities": []}, {"text": "We extracted LCFRS rules from dependency treebanks using the same procedure as, and applied the algorithm of directly to calculate their minimum parsing complexity.", "labels": [], "entities": []}, {"text": "This allows us to characterize the parsing complexity of the rules found in the treebank without needing to define specific conditions on the rules, such as well-nestedness () or mildly ill-nestedness, that may not be necessary for all efficiently parsable grammars.", "labels": [], "entities": []}, {"text": "The numbers of rules of different complexities are shown in.", "labels": [], "entities": []}, {"text": "As found by previous studies, the vast majority of productions are context-free (projective trees, parsable in O(n 3 )).", "labels": [], "entities": []}, {"text": "Of non-projective rules, the vast majority can be parsed in O(n 6 ), including the well-nested structures of gap degree one defined by.", "labels": [], "entities": []}, {"text": "The single most complex rule had parsing complexity of O(n 20 ), and was derived from a Swedish sentence which turns out to be so garbled as to be incomprehensible (taken from the high school essay portion of the Swedish treebank).", "labels": [], "entities": [{"text": "O", "start_pos": 55, "end_pos": 56, "type": "METRIC", "confidence": 0.990483283996582}, {"text": "high school essay portion of the Swedish treebank", "start_pos": 180, "end_pos": 229, "type": "DATASET", "confidence": 0.6178695149719715}]}, {"text": "It is interesting to note that, while the binarization algorithm is exponential in the worst case, it is practical for real data: analyzing all the rules extracted from the various treebanks takes only a few minutes.", "labels": [], "entities": []}, {"text": "We did not find any cases in rules extracted from Treebank data of rules where minimizing parsing complexity is inconsistent with minimizing fan-out, as is the case for the rule of.", "labels": [], "entities": [{"text": "Treebank data", "start_pos": 50, "end_pos": 63, "type": "DATASET", "confidence": 0.9297577440738678}]}], "tableCaptions": [{"text": " Table 1: Number of productions with specified parsing complexity", "labels": [], "entities": []}]}