{"title": [{"text": "Unsupervised Template Mining for Semantic Category Understanding", "labels": [], "entities": [{"text": "Template Mining", "start_pos": 13, "end_pos": 28, "type": "TASK", "confidence": 0.7262818515300751}]}], "abstractContent": [{"text": "We propose an unsupervised approach to constructing templates from a large collection of semantic category names, and use the templates as the semantic representation of categories.", "labels": [], "entities": []}, {"text": "The main challenge is that many terms have multiple meanings, resulting in a lot of wrong templates.", "labels": [], "entities": []}, {"text": "Statistical data and semantic knowledge are extracted from a web corpus to improve template generation.", "labels": [], "entities": [{"text": "template generation", "start_pos": 83, "end_pos": 102, "type": "TASK", "confidence": 0.7573609054088593}]}, {"text": "A nonlinear scoring function is proposed and demonstrated to be effective.", "labels": [], "entities": []}, {"text": "Experiments show that our approach achieves significantly better results than baseline methods.", "labels": [], "entities": []}, {"text": "As an immediate application, we apply the extracted templates to the cleaning of a category collection and see promising results (preci-sion improved from 81% to 89%).", "labels": [], "entities": [{"text": "preci-sion", "start_pos": 130, "end_pos": 140, "type": "METRIC", "confidence": 0.9931422472000122}]}], "introductionContent": [{"text": "A semantic category is a collection of items sharing common semantic properties.", "labels": [], "entities": []}, {"text": "For example, all cities in Germany form a semantic category named \"city in Germany\" or \"German city\".", "labels": [], "entities": []}, {"text": "In Wikipedia, the category names of an entity are manually edited and displayed at the end of the page for the entity.", "labels": [], "entities": []}, {"text": "There have been quite a lot of approaches) in the literature to automatically extracting category names and instances (also called is-a or hypernymy relations) from the web.", "labels": [], "entities": [{"text": "automatically extracting category names and instances", "start_pos": 64, "end_pos": 117, "type": "TASK", "confidence": 0.7704349011182785}]}, {"text": "Most existing work simply treats a category name as a text string containing one or multiple words, without caring about its internal structure.", "labels": [], "entities": []}, {"text": "In this paper, we explore the semantic structure of category names (or simply called \"categories\").", "labels": [], "entities": []}, {"text": "For example, both \"CEO of General Motors\" and \"CEO of Yahoo\" have structure \"CEO of\".", "labels": [], "entities": []}, {"text": "We call such a structure a category template.", "labels": [], "entities": []}, {"text": "Taking a large collection of open-domain categories as input, we construct a list of category templates and build a mapping from categories to templates.", "labels": [], "entities": []}, {"text": "shows some example semantic categories and their corresponding templates.", "labels": [], "entities": []}, {"text": "Templates can be treated as additional features of semantic categories.", "labels": [], "entities": []}, {"text": "The new features can be exploited to improve some upper-layer applications like web search and question answering.", "labels": [], "entities": [{"text": "question answering", "start_pos": 95, "end_pos": 113, "type": "TASK", "confidence": 0.889685332775116}]}, {"text": "In addition, by linking categories to templates, it is possible (for a computer program) to infer the semantic meaning of the categories.", "labels": [], "entities": []}, {"text": "For example in, from the two templates linking to category \"symptom of insulin deficiency\", it is reasonable to interpret the category as: \"a symptom of a medical condition called insulin deficiency which is about the deficiency of one type of hormone called insulin.\"", "labels": [], "entities": []}, {"text": "In this way, our knowledge about a category can go beyond a simple string and its member entities.", "labels": [], "entities": []}, {"text": "An immediate application of templates is removing invalid category names from a noisy category collection.", "labels": [], "entities": []}, {"text": "Promising results are observed for this application in our experiments.", "labels": [], "entities": []}, {"text": "An intuitive approach to this task (i.e., extracting templates from a collection of category names) national holiday of South Africa national holiday of symptom of cortisol deficiency  contains two stages: category labeling, and template scoring.", "labels": [], "entities": [{"text": "category labeling", "start_pos": 206, "end_pos": 223, "type": "TASK", "confidence": 0.7154318988323212}]}, {"text": "Category labeling: Divide a category name into multiple segments and replace some key segments with its hypernyms.", "labels": [], "entities": [{"text": "Category labeling", "start_pos": 0, "end_pos": 17, "type": "TASK", "confidence": 0.8217219114303589}]}, {"text": "As an example, assume \"CEO of Delphinus\" is divided to three segments \"CEO + of + Delphinus\"; and the last segment (Delphinus) has hypernyms \"constellation\", \"company\", etc.", "labels": [], "entities": []}, {"text": "By replacing this segment with its hypernyms, we get candidate templates \"CEO of\" (a wrong template), \"CEO of\", and the like.", "labels": [], "entities": []}, {"text": "Template scoring: Compute the score of each candidate template by aggregating the information obtained in the first phase.", "labels": [], "entities": []}, {"text": "A major challenge here is that many segments (like \"Delphinus\" in the above example) have multiple meanings.", "labels": [], "entities": []}, {"text": "As a result, wrong hypernyms maybe adopted to generate incorrect candidate templates (like \"CEO of [constellation]\").", "labels": [], "entities": []}, {"text": "In this paper, we focus on improving the template scoring stage, with the goal of assigning lower scores to bad templates and larger scores to high-quality ones.", "labels": [], "entities": []}, {"text": "There have been some research efforts) on exploring the structure of category names by building patterns.", "labels": [], "entities": []}, {"text": "However, we automatically assign semantic types to the pattern variables (or called arguments) while they do not.", "labels": [], "entities": []}, {"text": "For example, our template has the form of \"city in\" while their patterns are like \"city in\".", "labels": [], "entities": []}, {"text": "More details are given in the related work section.", "labels": [], "entities": []}, {"text": "A similar task is query understanding, including query tagging and query template mining.", "labels": [], "entities": [{"text": "query understanding", "start_pos": 18, "end_pos": 37, "type": "TASK", "confidence": 0.8731221556663513}, {"text": "query tagging", "start_pos": 49, "end_pos": 62, "type": "TASK", "confidence": 0.7177422940731049}, {"text": "query template mining", "start_pos": 67, "end_pos": 88, "type": "TASK", "confidence": 0.6475429634253184}]}, {"text": "Query tagging () corresponds to the category labeling stage described above.", "labels": [], "entities": [{"text": "Query tagging", "start_pos": 0, "end_pos": 13, "type": "TASK", "confidence": 0.8020374774932861}]}, {"text": "It is different from template generation because the results are for one query only, without merging the information of all queries to generate the final templates.", "labels": [], "entities": [{"text": "template generation", "start_pos": 21, "end_pos": 40, "type": "TASK", "confidence": 0.745087593793869}]}, {"text": "Category template construction are slightly different from query template construction.", "labels": [], "entities": [{"text": "Category template construction", "start_pos": 0, "end_pos": 30, "type": "TASK", "confidence": 0.6147559384504954}, {"text": "query template construction", "start_pos": 59, "end_pos": 86, "type": "TASK", "confidence": 0.7285034159819285}]}, {"text": "First, some useful features such as query click-through is not available in category template construction.", "labels": [], "entities": [{"text": "category template construction", "start_pos": 76, "end_pos": 106, "type": "TASK", "confidence": 0.7213604847590128}]}, {"text": "Second, categories should be valid natural language phrases, while queries need not.", "labels": [], "entities": []}, {"text": "For example, \"city Germany\" is a query but not a valid category name.", "labels": [], "entities": []}, {"text": "We discuss in more details in the related work section.", "labels": [], "entities": []}, {"text": "Our major contributions are as follows.", "labels": [], "entities": []}, {"text": "1) To the best of our knowledge, this is the first work of template generation specifically for categories in unsupervised manner.", "labels": [], "entities": [{"text": "template generation", "start_pos": 59, "end_pos": 78, "type": "TASK", "confidence": 0.7232013940811157}]}, {"text": "2) We extract semantic knowledge and statistical information from a web corpus for improving template generation.", "labels": [], "entities": [{"text": "template generation", "start_pos": 93, "end_pos": 112, "type": "TASK", "confidence": 0.7423175275325775}]}, {"text": "Significant performance improvement is obtained in our experiments.", "labels": [], "entities": []}, {"text": "3) We study the characteristics of the scoring function from the viewpoint of probabilistic evidence combination and demonstrate that nonlinear functions are more effective in this task.", "labels": [], "entities": []}, {"text": "4) We employ the output templates to clean our category collection mined from the web, and get apparent quality improvement (precision improved from 81% to 89%).", "labels": [], "entities": [{"text": "precision", "start_pos": 125, "end_pos": 134, "type": "METRIC", "confidence": 0.9995502829551697}]}, {"text": "After discussing related work in Section 2, we define the problem and describe one baseline approach in Section 3.", "labels": [], "entities": []}, {"text": "Then we introduce our approach in Section 4.", "labels": [], "entities": []}, {"text": "Experimental results are reported and analyzed in Section 5.", "labels": [], "entities": []}, {"text": "We conclude the paper in Section 6.", "labels": [], "entities": []}], "datasetContent": [{"text": "The input category names for experiments are automatically extracted from a web corpus (Section 3.1).", "labels": [], "entities": []}, {"text": "Two test-sets are built for evaluation from the output templates of various methods.", "labels": [], "entities": []}, {"text": "Subsets: In order to conveniently compare the performance of different methods, we create 20 sub-collections (called subsets) from the whole input category collection.", "labels": [], "entities": []}, {"text": "Each subset contains all the categories having the same headword (e.g., \"symptom of insulin deficiency\" and \"depression symptom\" are in the same subset because they share the same headword \"symptom\").", "labels": [], "entities": []}, {"text": "To choose the 20 headwords, we first sample 100 at random from the set of all headwords; then manually choose 20 for diversity.", "labels": [], "entities": []}, {"text": "The headwords include symptom, school, food, gem, hero, weapon, model, etc.", "labels": [], "entities": []}, {"text": "We run the 10 methods on these subsets and sort the output templates by their scores.", "labels": [], "entities": []}, {"text": "Top-30 templates from each method on each subset are selected and mixed together for annotation.", "labels": [], "entities": []}, {"text": "Fullset: We run method NLP+C (which has the best performance according to our subsets experiments) on the input categories and sort the output templates by their scores.", "labels": [], "entities": []}, {"text": "Then we split the templates into 9 sections according to their ranking position.", "labels": [], "entities": []}, {"text": "Then 40 templates are randomly chosen from each section and mixed together for annotation.", "labels": [], "entities": []}, {"text": "The selected templates (from subsets and the fullset) are annotated by six annotators, with each template assigned to two annotators.", "labels": [], "entities": []}, {"text": "A template is assigned a label of \"good\", \"fair\", or \"bad\" by an annotator.", "labels": [], "entities": []}, {"text": "The percentage agreement between the annotators is 80.2%, with kappa 0.624.", "labels": [], "entities": [{"text": "agreement", "start_pos": 15, "end_pos": 24, "type": "METRIC", "confidence": 0.7120524048805237}, {"text": "kappa", "start_pos": 63, "end_pos": 68, "type": "METRIC", "confidence": 0.9744826555252075}]}, {"text": "For the subset experiments, we adopt Precision@k (k=10,20,30) to evaluate the top templates generated by each method.", "labels": [], "entities": [{"text": "Precision", "start_pos": 37, "end_pos": 46, "type": "METRIC", "confidence": 0.9940162897109985}]}, {"text": "The scores for \"good\", \"fair\", and \"bad\" are 1, 0.5, and 0.", "labels": [], "entities": []}, {"text": "The score of each template is the average annotation score over two annotators (e.g., if a template is annotated \"good\" by one annotator and \"fair\" by another, its score is (1.0+0.5)/2=0.75).", "labels": [], "entities": []}, {"text": "The evaluation score of a method is the average over the 20 subsets.", "labels": [], "entities": []}, {"text": "For the fullset experiments, we report the precision for each section.", "labels": [], "entities": [{"text": "precision", "start_pos": 43, "end_pos": 52, "type": "METRIC", "confidence": 0.9996820688247681}]}], "tableCaptions": [{"text": " Table 1: Performance comparison among the  methods on subset.", "labels": [], "entities": []}]}