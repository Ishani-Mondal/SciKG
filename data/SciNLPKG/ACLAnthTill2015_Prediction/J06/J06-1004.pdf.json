{"title": [{"text": "Finite-State Registered Automata for Non-Concatenative Morphology", "labels": [], "entities": []}], "abstractContent": [{"text": "We introduce finite-state registered automata (FSRAs), anew computational device within the framework of finite-state technology, specifically tailored for implementing non-concatenative morphological processes.", "labels": [], "entities": []}, {"text": "This model extends and augments existing finite-state techniques, which are presently not optimized for describing this kind of phenomena.", "labels": [], "entities": []}, {"text": "We first define the model and discuss its mathematical and computational properties.", "labels": [], "entities": []}, {"text": "Then, we provide an extended regular language whose expressions denote FSRAs.", "labels": [], "entities": [{"text": "FSRAs", "start_pos": 71, "end_pos": 76, "type": "METRIC", "confidence": 0.6819512248039246}]}, {"text": "Finally, we exemplify the utility of the model by providing several examples of complex morphological and phonological phenomena, which are elegantly implemented with FSRAs.", "labels": [], "entities": [{"text": "FSRAs", "start_pos": 167, "end_pos": 172, "type": "DATASET", "confidence": 0.6742594242095947}]}], "introductionContent": [{"text": "Finite-state (FS) technology has been considered adequate for describing the morphological processes of the world's languages since the pioneering works of and.", "labels": [], "entities": []}, {"text": "Several toolboxes provide extended regular expression description languages and compilers of the expressions to finite-state automata (FSAs) and transducers (FSTs) (.", "labels": [], "entities": []}, {"text": "While FS approaches to most natural languages have generally been very successful, it is widely recognized that they are less suitable for non-concatenative phenomena; in particular, FS techniques are assumed not to be able to efficiently account for the non-concatenative word formation processes that Semitic languages exhibit (.", "labels": [], "entities": [{"text": "FS", "start_pos": 6, "end_pos": 8, "type": "TASK", "confidence": 0.9730980396270752}, {"text": "FS", "start_pos": 183, "end_pos": 185, "type": "TASK", "confidence": 0.9222811460494995}, {"text": "word formation", "start_pos": 273, "end_pos": 287, "type": "TASK", "confidence": 0.7833037972450256}]}, {"text": "While much of the inflectional morphology of Semitic languages can be rather straightforwardly described using concatenation as the primary operation, the main word formation process in such languages is inherently non-concatenative.", "labels": [], "entities": [{"text": "word formation", "start_pos": 160, "end_pos": 174, "type": "TASK", "confidence": 0.7460376620292664}]}, {"text": "The standard account describes words in Semitic languages as combinations of two morphemes: a root and a pattern.", "labels": [], "entities": []}, {"text": "The root consists of consonants only, by default three (although longer roots are known).", "labels": [], "entities": []}, {"text": "The pattern is a combination of vowels and, possibly, consonants too, with \"slots\" into which the root consonants can be inserted.", "labels": [], "entities": []}, {"text": "Words are created by interdigitating roots into patterns: The first consonant of the root is inserted into the first consonantal slot of the pattern, the second root consonant fills the second slot, and the third fills the last slot.", "labels": [], "entities": []}, {"text": "After the root combines with the pattern, some morpho-phonological alternations take place, which maybe non-trivial but are mostly concatenative.", "labels": [], "entities": []}, {"text": "The major problem that we tackle in this work is medium-distance dependencies, whereby some elements that are related to each other in some deep-level representation (e.g., the consonants of the root) are separated on the surface.", "labels": [], "entities": []}, {"text": "While these phenomena do not lie outside the descriptive power of FS systems, na\u00a8\u0131velyna\u00a8\u0131vely implementing them in existing finite-state calculi is either impossible or, at best, results in large networks that are inefficient to process, as the following examples demonstrate.", "labels": [], "entities": [{"text": "FS", "start_pos": 66, "end_pos": 68, "type": "TASK", "confidence": 0.8367231488227844}]}], "datasetContent": [{"text": "In order to practically compare the space and time performance of FSRAs and FSAs, we have implemented the special operators introduced in Sections 4 and 5 for circumfixation and interdigitation, as well as direct construction of FSRAs.", "labels": [], "entities": [{"text": "FSAs", "start_pos": 76, "end_pos": 80, "type": "DATASET", "confidence": 0.797368586063385}, {"text": "FSRAs", "start_pos": 229, "end_pos": 234, "type": "DATASET", "confidence": 0.8270230293273926}]}, {"text": "We have compared FSRAs with ordinary FSAs by building corresponding networks for circumfixation, interdigitation, and n-bit incrementation.", "labels": [], "entities": []}, {"text": "For circumfixation, we constructed networks for the circumfixation of 1,043 Hebrew roots and 4 circumfixes.", "labels": [], "entities": []}, {"text": "For interdigitation we constructed a network accepting the splicing of 1,043 roots into 20 patterns.", "labels": [], "entities": []}, {"text": "For n-bit incrementation we constructed networks for 10-bit, 50-bit, and 100-bit incrementors.", "labels": [], "entities": []}, {"text": "displays the size of each of the networks in terms of states, arcs, and actual file size.", "labels": [], "entities": []}, {"text": "Clearly, FSRAs provide a significant reduction in the network size.", "labels": [], "entities": [{"text": "FSRAs", "start_pos": 9, "end_pos": 14, "type": "METRIC", "confidence": 0.5324309468269348}]}, {"text": "In particular, we could not construct an n-bit incrementor FSA for any n greater than 100 as a result of memory problems, whereas using FSRAs we had no problem constructing networks even for n = 50, 000.", "labels": [], "entities": []}, {"text": "In addition, we compared the recognition times of the two models.", "labels": [], "entities": []}, {"text": "For that purpose, we used the circumfixation, interdigitation, 10-bit incrementation, and 50-bit incrementation networks to analyze 200, 1,000, and 5,000 words.", "labels": [], "entities": []}, {"text": "As can be seen in, time performance is comparable for the two models, except for interdigitation, where FSAs outperform FSRAs by a constant factor.", "labels": [], "entities": [{"text": "FSAs", "start_pos": 104, "end_pos": 108, "type": "METRIC", "confidence": 0.7756083011627197}]}, {"text": "The reason is that in this network the usage of registers is massive and thereby, there is a higher cost to the reduction of the network size, in terms of analysis time.", "labels": [], "entities": []}, {"text": "This is an instance of the common tradeoff of time versus space: FSRAs improve the network size at the cost of slower analysis time in some cases.", "labels": [], "entities": []}, {"text": "When using finite-state devices for natural language processing, often the generated networks become too large to be practical.", "labels": [], "entities": []}, {"text": "In such cases, using FSRAs can make network size manageable.", "labels": [], "entities": []}, {"text": "Using the closure constructions one can build desired networks of reasonable size, and at the end decide whether to convert them to ordinary FSAs, if time performance is an issue.", "labels": [], "entities": [{"text": "FSAs", "start_pos": 141, "end_pos": 145, "type": "TASK", "confidence": 0.5629464983940125}]}], "tableCaptions": [{"text": " Table 1  Space comparison between FSAs and FSRAs.", "labels": [], "entities": [{"text": "FSAs", "start_pos": 35, "end_pos": 39, "type": "DATASET", "confidence": 0.6602762937545776}, {"text": "FSRAs", "start_pos": 44, "end_pos": 49, "type": "DATASET", "confidence": 0.6797674298286438}]}, {"text": " Table 2  Time comparison between FSAs and FSRAs.", "labels": [], "entities": [{"text": "Time", "start_pos": 10, "end_pos": 14, "type": "METRIC", "confidence": 0.9787256717681885}, {"text": "FSAs", "start_pos": 34, "end_pos": 38, "type": "DATASET", "confidence": 0.51859450340271}, {"text": "FSRAs", "start_pos": 43, "end_pos": 48, "type": "DATASET", "confidence": 0.5336968302726746}]}]}