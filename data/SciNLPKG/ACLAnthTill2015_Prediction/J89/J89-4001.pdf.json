{"title": [{"text": "A PARSING ALGORITHM FOR UNIFICATION GRAMMAR", "labels": [], "entities": [{"text": "A PARSING ALGORITHM FOR UNIFICATION GRAMMAR", "start_pos": 0, "end_pos": 43, "type": "METRIC", "confidence": 0.6697001953919729}]}], "abstractContent": [{"text": "We describe a table-driven parser for unification grammar that combines bottom-up construction of phrases with top-down filtering.", "labels": [], "entities": [{"text": "unification grammar", "start_pos": 38, "end_pos": 57, "type": "TASK", "confidence": 0.9706026017665863}]}, {"text": "This algorithm works on a class of grammars called depth-bounded grammars, and it is guaranteed to halt for any input string.", "labels": [], "entities": []}, {"text": "Unlike many unification parsers, our algorithm works directly on a unification grammar-it does not require that we divide the grammar into a context-free \"backbone\" and a set of feature agreement constraints.", "labels": [], "entities": [{"text": "unification parsers", "start_pos": 12, "end_pos": 31, "type": "TASK", "confidence": 0.8956320285797119}]}, {"text": "We give a detailed proof of correctness.", "labels": [], "entities": []}, {"text": "For the case of a pure bottom-up parser, our proof does not rely on the details of unification-it works for any pattern-matching technique that satisfies certain simple conditions.", "labels": [], "entities": []}], "introductionContent": [{"text": "Unrestricted unification grammars have the formal power of a Turing machine.", "labels": [], "entities": [{"text": "Unrestricted unification grammars", "start_pos": 0, "end_pos": 33, "type": "TASK", "confidence": 0.7301740050315857}]}, {"text": "Thus there is no algorithm that finds all parses of a given sentence in any unification grammar and always halts.", "labels": [], "entities": []}, {"text": "Some unification grammar systems just live with this problem.", "labels": [], "entities": [{"text": "unification grammar", "start_pos": 5, "end_pos": 24, "type": "TASK", "confidence": 0.8935086727142334}]}, {"text": "Any general parsing method for definite clause grammar will enter an infinite loop in some cases, and it is the task of the grammar writer to avoid this.", "labels": [], "entities": [{"text": "definite clause grammar", "start_pos": 31, "end_pos": 54, "type": "TASK", "confidence": 0.6694212158521017}]}, {"text": "Generalized phrase structure grammar avoids the problem because it has only the formal power of context-free grammar (, but according to this is not adequate for describing human language.", "labels": [], "entities": [{"text": "phrase structure grammar", "start_pos": 12, "end_pos": 36, "type": "TASK", "confidence": 0.7395759026209513}]}, {"text": "Lexical functional grammar employs a better solution.", "labels": [], "entities": [{"text": "Lexical functional grammar", "start_pos": 0, "end_pos": 26, "type": "TASK", "confidence": 0.8454187512397766}]}, {"text": "A lexical functional grammar must include a finitely ambiguous context-free grammar, which we will call the context-free backbone.", "labels": [], "entities": []}, {"text": "A parser for lexical functional grammar first builds the finite set of context-free parses of the input and then eliminates those that don't meet the other requirements of the grammar.", "labels": [], "entities": []}, {"text": "This method guarantees that the parser will halt.", "labels": [], "entities": []}, {"text": "This solution maybe adequate for lexical functional grammars, but for other unification grammars finding a finitely ambiguous context-free backbone is a problem.", "labels": [], "entities": []}, {"text": "Ina definite clause grammar, an obvious way to build a context-free backbone is to keep only the topmost function letters in each rule.", "labels": [], "entities": []}, {"text": "Thus the rule s ----> np(P,N) vp becomes s-->npvp (In this example we use the notation of Pereira and Warren 1980, except that we do not put square brackets around terminals, because this conflicts with standard notation for context-free grammars.)", "labels": [], "entities": []}, {"text": "Suppose we use a simple X-bar theory.", "labels": [], "entities": []}, {"text": "Let major-category (Type, Barlevel) denote a phrase in a major category.", "labels": [], "entities": []}, {"text": "A noun phrase may consist of a single noun, for instance, John.", "labels": [], "entities": []}, {"text": "This suggests a rule like this: major-category (n,2) --~ major-category (n, 1) In the context-free backbone this becomes major-category --* major-category so the context-free backbone is infinitely ambiguous.", "labels": [], "entities": []}, {"text": "One could devise more elaborate examples, but this one suffices to make the point: not every natural unification grammar has an obvious context-free backbone.", "labels": [], "entities": []}, {"text": "Therefore it is useful to have a parser that does not require us to find a context-free backbone, but works directly on a unification grammar.", "labels": [], "entities": []}, {"text": "We propose to guarantee that the parsing problem is solvable by restricting ourselves to depth-bounded grammars.", "labels": [], "entities": [{"text": "parsing problem", "start_pos": 33, "end_pos": 48, "type": "TASK", "confidence": 0.9247085452079773}]}, {"text": "A unification grammar is depth-bounded if for every L > 0 there is a D > 0 such that every parse tree fora sentential form of L symbols has depth less than D.", "labels": [], "entities": []}, {"text": "In other words, the depth of a tree is bounded by the length of the string it derives.", "labels": [], "entities": []}, {"text": "A context-free grammar is depth-bounded if and only if every string of symbols is finitely ambiguous.", "labels": [], "entities": []}, {"text": "We will generalize the notion of finite ambiguity to unification grammars and show that for unification grammars, depth-boundedness is a stronger property than finite ambiguity.", "labels": [], "entities": []}, {"text": "Copyright 1989 by the Association for Computational Linguistics.", "labels": [], "entities": []}, {"text": "Permission to copy without fee all or part of this material is granted provided that the copies are not made for direct commercial advantage and the CL reference and this copyright notice are included on the first page.", "labels": [], "entities": [{"text": "CL reference", "start_pos": 149, "end_pos": 161, "type": "DATASET", "confidence": 0.8458401560783386}]}, {"text": "To copy otherwise, or to republish, requires a fee and/or specific permission.", "labels": [], "entities": []}, {"text": "0362-613X/89/010219-232503.00 Depth-bounded unification grammars have more formal power than context-free grammars.", "labels": [], "entities": [{"text": "Depth-bounded unification grammars", "start_pos": 30, "end_pos": 64, "type": "TASK", "confidence": 0.7206808229287466}]}, {"text": "As an example we give a depth-bounded grammar for the language xx, which is not context-free.", "labels": [], "entities": []}, {"text": "Suppose the terminal symbols area through z.", "labels": [], "entities": []}, {"text": "We introduce function letters a' through z' to represent the terminals.", "labels": [], "entities": []}, {"text": "The rules of the grammar are as follows, withe denoting the empty string.", "labels": [], "entities": []}, {"text": "s ~ x(L)x(L) x(cons(A,L)) ~ pre-terminal(A) x(L) x(nil) ~ e pre-terminal(a') ~ a pre-terminal(z') ~ z The reasoning behind the grammar should be clear--x(cons(a',cons(b',nil))) derives ab, and the first rule guarantees that every sentence has the form xx.", "labels": [], "entities": []}, {"text": "The grammar is depth-bounded because the depth of a tree is a linear function of the length of the string it derives.", "labels": [], "entities": []}, {"text": "A similar grammar can derive the crossed serial dependencies of Swiss German, which according to no context-free grammar can derive.", "labels": [], "entities": []}, {"text": "It is clear where the extra formal power comes from: a contextfree grammar has a finite set of nonterminals, but a unification grammar can build arbitrarily large nonterminal symbols.", "labels": [], "entities": []}, {"text": "It remains to show that there is a parsing algorithm for depth-bounded unification grammars.", "labels": [], "entities": [{"text": "depth-bounded unification grammars", "start_pos": 57, "end_pos": 91, "type": "TASK", "confidence": 0.6630619565645853}]}, {"text": "We have developed such an algorithm, based on the context-free parser of, which is a table-driven parser.", "labels": [], "entities": []}, {"text": "If we generalize the table-building algorithm to a unification grammar in an obvious way, we get an algorithm that is guaranteed to halt for all depthbounded grammars (not for all unification grammars).", "labels": [], "entities": []}, {"text": "Given that the tables can be built, it is easy to show that the parser halts on every input.", "labels": [], "entities": []}, {"text": "This is not a special property of our parser--a straightforward bottom-up parser will also halt on all depth-bounded grammars, because it builds partial parse trees in order of their depth.", "labels": [], "entities": []}, {"text": "Our contribution is to show that a simple algorithm will verify depth-boundedness when in fact it holds.", "labels": [], "entities": []}, {"text": "If the grammar is not depth-bounded, the tablebuilding algorithm will enter an infinite loop, and it is up to the grammar writer to fix this.", "labels": [], "entities": []}, {"text": "In practice we have not found this troublesome, but it is still an unpleasant property of our method.", "labels": [], "entities": []}, {"text": "Section 7 will describe a possible solution for this problem.", "labels": [], "entities": []}, {"text": "Sections 2 and 3 of this paper define the basic concepts of our formalism.", "labels": [], "entities": []}, {"text": "Section 4 proves the soundness and completeness of our simplest parser, which is purely bottom-up and excludes rules with empty right-hand sides.", "labels": [], "entities": []}, {"text": "Section 5 admits rules with empty right sides, and section 6 adds top-down filtering.", "labels": [], "entities": []}, {"text": "Section 7 discusses the implementation and possible extensions.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": []}