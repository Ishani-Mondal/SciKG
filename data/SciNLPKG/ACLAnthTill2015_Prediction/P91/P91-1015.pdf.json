{"title": [{"text": "Head Corner Parsing for Discontinuous Constituency", "labels": [], "entities": []}], "abstractContent": [{"text": "I describe a head-driven parser fora class of grammars that handle discontinuous constituency by a richer notion of string combination than ordinary concatenation.", "labels": [], "entities": []}, {"text": "The parser is a generalization of the left-corner parser (Matsumoto et al., 1983) and can be used for grammars written in powerful formalisms such as non-concatenative versions of HPSG (Pollard, 1984; Reape, 1989).", "labels": [], "entities": []}], "introductionContent": [{"text": "Although most formalisms in computational linguistics assume that phrases are built by string concatenation (eg. as in PATR II, GPSG, LFG and most versions of Categorial Grammar), this assumption is challenged in non-concatenative grammatical formalisms.", "labels": [], "entities": []}, {"text": "In Pollard's dissertation several versions of 'qlead wrapping\" are defined.", "labels": [], "entities": []}, {"text": "In the analysis of the Australian free word-order language Guugu Yimidhirr, Mark Johnson uses a 'combine' predicate in a DCG-like grammar that corresponds to the union of words.", "labels": [], "entities": [{"text": "Australian free word-order language Guugu Yimidhirr", "start_pos": 23, "end_pos": 74, "type": "DATASET", "confidence": 0.615568275252978}]}, {"text": "Mike Reape uses an operation called 'sequence union' to analyse Germanic semi-free word order constructions).", "labels": [], "entities": []}, {"text": "Other examples include Tree Adjoining Grammars (, and versions of Categorial Grammar and references cited there.", "labels": [], "entities": []}, {"text": "There are several motivations for non-concatenative grammars.", "labels": [], "entities": []}, {"text": "First, specialized string combination operations allow elegant linguistic accounts of phenomena that are otherwise notoriously hard.", "labels": [], "entities": []}, {"text": "Examples are the analyses of Dutch cross serial dependencies by head wrapping or sequence union).", "labels": [], "entities": []}, {"text": "Furthermore, in non-concatenative grammars it is possible to relate (parts of) constituents that belong together semantically, but which are not adjacent.", "labels": [], "entities": []}, {"text": "Hence such grammars facilitate a simple compositional semantics.", "labels": [], "entities": []}, {"text": "In CF-based grammars such phenomena usually are treated by complex 'threading' mechanisms.", "labels": [], "entities": []}, {"text": "Non-concatenative grammatical formalisms may also be attractive from a computational point of view.", "labels": [], "entities": []}, {"text": "It is easier to define generation algorithms if the semantics is builtin a systematically constrained way).", "labels": [], "entities": []}, {"text": "The semantic-head-driven generation strategy faces problems in case semantic heads are 'displaced', and this displacement is analyzed using threading.", "labels": [], "entities": []}, {"text": "However, in this paper I sketch a simple analysis of verb-second (an example of a displacement of semantic heads) by an operation similar to head wrapping which a headdriven generator processes without any problems (or extensions) at all.", "labels": [], "entities": []}, {"text": "Clearly, there are also some computational problems, because most 'standard' parsing strategies assume context-free concatenation of strings.", "labels": [], "entities": []}, {"text": "These problems are the subject of this paper.", "labels": [], "entities": []}, {"text": "I will restrict the attention to a class of constraint-based formalisms, in which operations on strings are defined that are more powerful than concatenation, but which operations are restricted to be nonerasing, and linear.", "labels": [], "entities": []}, {"text": "The resulting class of systems can be characterized as Linear Context-Free Rewriting Systems (LCFRS), augmented with feature-structures (F-LCFRS).", "labels": [], "entities": []}, {"text": "For a discussion of the properties of LCFRS without feature-structures, see.", "labels": [], "entities": []}, {"text": "Note though that these properties do not carryover to the current system, because of the augmention with feature structures.", "labels": [], "entities": []}, {"text": "As in LCFRS, the operations on strings in F-LCFRS can be characterized as follows.", "labels": [], "entities": []}, {"text": "First, derived structures will be mapped onto a set of occurances of words; i.e. each derived structure 'knows' which words it 'dominates'.", "labels": [], "entities": []}, {"text": "For example, each derived feature structure may contain an attribute 'phon' whose value is a list of atoms representing the string it dominates.", "labels": [], "entities": []}, {"text": "I will write w(F) for the set of occurances of words that the derived structure F dominates.", "labels": [], "entities": []}, {"text": "Dn into anew structure M.", "labels": [], "entities": []}, {"text": "Nonerasure requires that the union of w applied to each daughter is a subset of w(M): Linearity requires that the difference of the cardinalities of these sets is a constant factor; i.e. a rule may only introduce a fixed number of words syncategorematically: CF-based formalisms clearly fulfill this requirement, as do Head Grammars, grammars using sequence union, and TAG's.", "labels": [], "entities": []}, {"text": "I assume in the remainder of this paper that I.Jin=l w(Di) = w(M), for all rules other than lexical entries (i.e. all words are introduced on a terminal).", "labels": [], "entities": []}, {"text": "Note though that a simple generalization of the algorithm presented below handles the general case (along the lines ofby treating rules that introduce extra lexical material as nonchain-rules).", "labels": [], "entities": []}, {"text": "Furthermore, I will assume that each rule has a designated daughter, called the head.", "labels": [], "entities": []}, {"text": "Although I will not impose any restrictions on the head, it will turnout that the parsing strategy to be proposed will be very sensitive to the choice of heads, with the effect that F-LCFRS's in which the notion 'head' is defined in a systematic way (Pollard's Head Grammars, Reape's version of HPSG, Dowty's version of Categorial Grammar), maybe much more efficiently parsed than other grammars.", "labels": [], "entities": [{"text": "parsing", "start_pos": 82, "end_pos": 89, "type": "TASK", "confidence": 0.9649274945259094}, {"text": "Reape's version of HPSG", "start_pos": 276, "end_pos": 299, "type": "DATASET", "confidence": 0.704293429851532}]}, {"text": "The notion seed of a parse tree is defined recursively in terms of the head.", "labels": [], "entities": []}, {"text": "The seed of a tree will be the seed of its head.", "labels": [], "entities": []}, {"text": "The seed of a terminal will be that terminal itself.", "labels": [], "entities": []}, {"text": "In ( a head-driven algorithm based on active chart parsing is described.", "labels": [], "entities": [{"text": "chart parsing", "start_pos": 45, "end_pos": 58, "type": "TASK", "confidence": 0.7452946305274963}]}, {"text": "The details of the algorithm are unclear from the paper which makes a comparison with our approach hard; it is not clear whether the parser indeed allows for example the head-wrapping operations of.", "labels": [], "entities": []}, {"text": "Reape presented two algorithms which are generalizations of a shift-reduce parser, and the CKY algorithm, for the same class of grammars.", "labels": [], "entities": []}, {"text": "I present a head-driven bottom-up algorithm for F-LCFR grammars.", "labels": [], "entities": []}, {"text": "The algorithm resembles the head-driven parser by Martin Kay, but is generalized in order to be used for this larger class of grammars.", "labels": [], "entities": []}, {"text": "The disadvantages Kay noted for his parser do not carryover to this generalized version, as redundant search paths for CF-based grammars turnout to be genuine parts of the search space for F-LCFR grammars.", "labels": [], "entities": []}, {"text": "The advantage of my algorithm is that it both employs bottom-up and top-down filtering in a straightforward way.", "labels": [], "entities": []}, {"text": "The algorithm is closely related to head-driven generators.", "labels": [], "entities": []}, {"text": "The algorithm proceeds in a bottom-up, head-driven fashion.", "labels": [], "entities": []}, {"text": "In modern linguistic theories very much information is defined in lexical entries, whereas rules are reduced to very general (and very uninformative) schemata.", "labels": [], "entities": []}, {"text": "More information usually implies less search space, hence it is sensible to parse bottomup in order to obtain useful information as soon as possible.", "labels": [], "entities": []}, {"text": "Furthermore, in many linguistic theories a special daughter called the head determines what kind of other daughters there maybe.", "labels": [], "entities": []}, {"text": "Therefore, it is also sensible to start with the head in order to know for what else you have to look for.", "labels": [], "entities": []}, {"text": "As the parser proceeds from head to head it is furthermore possible to use powerful top-down predictions based on the usual head feature percolations.", "labels": [], "entities": []}, {"text": "Finally note that proceding bottom-up solves some non-termination problems, because in lexicalized theories it is often the case that information in lexical entries limit the recursive application of rules (eg. the size of the subcat list of an entry determines the depth of the derivation tree of which this entry can be the seed).", "labels": [], "entities": []}, {"text": "Before I present the parser in section 3, I will first present an example of a F-LCFR grammar, to obtain a flavor of the type of problems the parser handles reasonably well.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": []}