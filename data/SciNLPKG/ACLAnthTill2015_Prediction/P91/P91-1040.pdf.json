{"title": [{"text": "CONSTRAINT PROJECTION: AN EFFICIENT TREATMENT OF DISJUNCTIVE FEATURE DESCRIPTIONS", "labels": [], "entities": [{"text": "AN EFFICIENT TREATMENT OF DISJUNCTIVE FEATURE DESCRIPTIONS", "start_pos": 23, "end_pos": 81, "type": "METRIC", "confidence": 0.6527249727930341}]}], "abstractContent": [{"text": "Unification of disjunctive feature descriptions is important for efficient unification-based parsing.", "labels": [], "entities": [{"text": "unification-based parsing", "start_pos": 75, "end_pos": 100, "type": "TASK", "confidence": 0.8353787362575531}]}, {"text": "This paper presents constraint projection, anew method for unification of disjunctive feature structures represented by logical constraints.", "labels": [], "entities": [{"text": "constraint projection", "start_pos": 20, "end_pos": 41, "type": "TASK", "confidence": 0.6937885731458664}, {"text": "unification of disjunctive feature structures represented by logical constraints", "start_pos": 59, "end_pos": 139, "type": "TASK", "confidence": 0.7719974517822266}]}, {"text": "Constraint projection is a generalization of constraint unification, and is more efficient because constraint projection has a mechanism for abandoning information irrelevant to a goal specified by a list of variables.", "labels": [], "entities": [{"text": "Constraint projection", "start_pos": 0, "end_pos": 21, "type": "TASK", "confidence": 0.8436034917831421}, {"text": "constraint unification", "start_pos": 45, "end_pos": 67, "type": "TASK", "confidence": 0.7293239384889603}, {"text": "constraint projection", "start_pos": 99, "end_pos": 120, "type": "TASK", "confidence": 0.7535213828086853}]}], "introductionContent": [{"text": "Unification is a central operation in recent computational linguistic research.", "labels": [], "entities": []}, {"text": "Much work on syntactic theory and natural language parsing is based on unification because unification-based approaches have many advantages over other syntactic and computational theories.", "labels": [], "entities": [{"text": "syntactic theory", "start_pos": 13, "end_pos": 29, "type": "TASK", "confidence": 0.7940901219844818}, {"text": "natural language parsing", "start_pos": 34, "end_pos": 58, "type": "TASK", "confidence": 0.6485181550184885}]}, {"text": "Unificationbased formalisms make it easy to write a grammar.", "labels": [], "entities": []}, {"text": "In particular, they allow rules and lexicon to be written declaratively and do not need transformations.", "labels": [], "entities": []}, {"text": "Some problems remain, however.", "labels": [], "entities": []}, {"text": "One of the main problems is the computational inefficiency of the unification of disjunctive feature structures.", "labels": [], "entities": [{"text": "unification of disjunctive feature structures", "start_pos": 66, "end_pos": 111, "type": "TASK", "confidence": 0.807530677318573}]}, {"text": "Functional unification grammar (FUG)) uses disjunctive feature structures for economical representation of lexical items.", "labels": [], "entities": [{"text": "Functional unification grammar (FUG))", "start_pos": 0, "end_pos": 37, "type": "TASK", "confidence": 0.8802441656589508}]}, {"text": "Using disjunctive feature structures reduces the number of lexical items.", "labels": [], "entities": []}, {"text": "However, if disjunctive feature structures were expanded to disjunctive normal form (DNF) 1 as in definite clause grammar and Kay's parser, unification would take exponential time in the number of disjuncts.", "labels": [], "entities": []}, {"text": "Avoiding unnecessary expansion of disjunction is important for efficient disjunctive unification. and have tackled this problem and proposed unification methods for disjunctive feature descriptions.", "labels": [], "entities": [{"text": "disjunctive unification.", "start_pos": 73, "end_pos": 97, "type": "TASK", "confidence": 0.8182509243488312}]}, {"text": "~DNF has a form \u00a2bt Vq~ V\u00a23 V.-.", "labels": [], "entities": []}, {"text": "Vq~n, where \u00a2i includes no disjunctions.", "labels": [], "entities": []}, {"text": "These works are based on graph unification rather than on term unification.", "labels": [], "entities": [{"text": "graph unification", "start_pos": 25, "end_pos": 42, "type": "TASK", "confidence": 0.7414664328098297}]}, {"text": "Graph unification has the advantage that the number of arguments is free and arguments are selected by labels so that it is easy to write a grammar and lexicon.", "labels": [], "entities": [{"text": "Graph unification", "start_pos": 0, "end_pos": 17, "type": "TASK", "confidence": 0.9065981209278107}]}, {"text": "Graph unification, however, has two disadvantages: it takes excessive time to search fora specified feature and it requires much copying.", "labels": [], "entities": [{"text": "Graph unification", "start_pos": 0, "end_pos": 17, "type": "TASK", "confidence": 0.9160486459732056}]}, {"text": "We adopt term unification for these reasons.", "labels": [], "entities": [{"text": "term unification", "start_pos": 9, "end_pos": 25, "type": "TASK", "confidence": 0.6737722456455231}]}, {"text": "Although have mentioned that their algorithm is applicable to term unification as well as graph unification, this method would lose term unification's advantage of not requiring so much copying.", "labels": [], "entities": [{"text": "term unification", "start_pos": 62, "end_pos": 78, "type": "TASK", "confidence": 0.7026521265506744}, {"text": "graph unification", "start_pos": 90, "end_pos": 107, "type": "TASK", "confidence": 0.7364533394575119}, {"text": "term unification", "start_pos": 132, "end_pos": 148, "type": "TASK", "confidence": 0.7011432498693466}]}, {"text": "On the contrary, constraint unification (CU) (), a disjunctive unification method, makes full use of term unification advantages.", "labels": [], "entities": [{"text": "constraint unification", "start_pos": 17, "end_pos": 39, "type": "TASK", "confidence": 0.6976729035377502}]}, {"text": "In CU, disjunctive feature structures are represented by logical constraints, particularly by Horn clauses, and unification is regarded as a constraint satisfaction problem.", "labels": [], "entities": []}, {"text": "Furthermore, solving a constraint satisfaction problem is identical to transforming a constraint into an equivalent and satisfiable constraint.", "labels": [], "entities": []}, {"text": "CU unifies feature structures by transforming the constraints on them.", "labels": [], "entities": []}, {"text": "The basic idea of CU is to transform constraints in a demand-driven way; that is, to transform only those constraints which may not be satisfiable.", "labels": [], "entities": []}, {"text": "This is why CU is efficient and does not require excessive copying.", "labels": [], "entities": []}, {"text": "However, CU has a serious disadvantage.", "labels": [], "entities": [{"text": "CU", "start_pos": 9, "end_pos": 11, "type": "DATASET", "confidence": 0.5179738402366638}]}, {"text": "It does not have a mechanism for abandoning irrelevant information, so the number of arguments in constraint-terms (atomic formulas) becomes so large that transt'ormation takes much time.", "labels": [], "entities": []}, {"text": "Therefore, from the viewpoint of general natural language processing, although CU is suitable for processing logical constraints with small structures, it is not suitable for constraints with large structures.", "labels": [], "entities": []}, {"text": "This paper presents constraint projection (CP), another method for disjunctive unification.", "labels": [], "entities": [{"text": "constraint projection (CP)", "start_pos": 20, "end_pos": 46, "type": "TASK", "confidence": 0.7751634299755097}, {"text": "disjunctive unification", "start_pos": 67, "end_pos": 90, "type": "TASK", "confidence": 0.7776197493076324}]}, {"text": "The basic idea of CP is to abandon information irrelevant to goals.", "labels": [], "entities": []}, {"text": "For example, in bottom-up parsing, if grammar consists of local constraints as in contemporary unification-based formalisms, it is possible to abandon information about daughter nodes after the application of rules, because the feature structure of a mother node is determined only by the feature structures of its daughter nodes and phrase structure rules.", "labels": [], "entities": [{"text": "bottom-up parsing", "start_pos": 16, "end_pos": 33, "type": "TASK", "confidence": 0.6195761859416962}]}, {"text": "Since abandoning irrelevant information makes the resulting structure tighter, another application of phrase structure rules to it will be efficient.", "labels": [], "entities": []}, {"text": "We use the term projection in the sense that CP returns a projection of the input constraint on the specified variables.", "labels": [], "entities": []}, {"text": "We explain how to express disjunctive feature structures by logical constraints in Section 2.", "labels": [], "entities": []}, {"text": "Section 3 introduces CU and indicates its disadvantages.", "labels": [], "entities": [{"text": "CU", "start_pos": 21, "end_pos": 23, "type": "METRIC", "confidence": 0.5158588290214539}]}, {"text": "Section 4 explains the basic ideas and the algorithm of CP.", "labels": [], "entities": [{"text": "CP", "start_pos": 56, "end_pos": 58, "type": "TASK", "confidence": 0.9600200057029724}]}, {"text": "Section 5 presents some results of implementation and shows that adopting CP makes parsing efficient.", "labels": [], "entities": [{"text": "parsing", "start_pos": 83, "end_pos": 90, "type": "TASK", "confidence": 0.9775770306587219}]}], "datasetContent": [], "tableCaptions": []}