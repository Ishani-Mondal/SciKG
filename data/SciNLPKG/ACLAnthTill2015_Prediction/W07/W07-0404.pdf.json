{"title": [{"text": "Proceedings of SSST, NAACL-HLT 2007 / AMTA Workshop on Syntax and Structure in Statistical Factorization of Synchronous Context-Free Grammars in Linear Time", "labels": [], "entities": [{"text": "SSST, NAACL-HLT 2007 / AMTA Workshop", "start_pos": 15, "end_pos": 51, "type": "TASK", "confidence": 0.5938724407127925}]}], "abstractContent": [{"text": "Factoring a Synchronous Context-Free Grammar into an equivalent grammar with a smaller number of nonterminals in each rule enables synchronous parsing algorithms of lower complexity.", "labels": [], "entities": []}, {"text": "The problem can be formalized as searching for the tree-decomposition of a given permutation with the minimal branching factor.", "labels": [], "entities": []}, {"text": "In this paper, by modifying the algorithm of Uno and Yagiura (2000) for the closely related problem of finding all common intervals of two permutations, we achieve a linear time algorithm for the permutation factor-ization problem.", "labels": [], "entities": []}, {"text": "We also use the algorithm to analyze the maximum SCFG rule length needed to cover hand-aligned data from various language pairs.", "labels": [], "entities": []}], "introductionContent": [{"text": "A number of recent syntax-based approaches to statistical machine translation make use of Synchronous Context Free Grammar (SCFG) as the underlying model of translational equivalence.", "labels": [], "entities": [{"text": "statistical machine translation", "start_pos": 46, "end_pos": 77, "type": "TASK", "confidence": 0.6455136835575104}, {"text": "translational equivalence", "start_pos": 157, "end_pos": 182, "type": "TASK", "confidence": 0.8902741074562073}]}, {"text": "Wu (1997)'s Inversion Transduction Grammar, as well as tree-transformation models of translation such as,, and all fall into this category.", "labels": [], "entities": [{"text": "Inversion Transduction Grammar", "start_pos": 12, "end_pos": 42, "type": "TASK", "confidence": 0.8270604610443115}]}, {"text": "A crucial question for efficient computation in approaches based on SCFG is the length of the grammar rules.", "labels": [], "entities": [{"text": "length", "start_pos": 80, "end_pos": 86, "type": "METRIC", "confidence": 0.9875454306602478}]}, {"text": "Grammars with longer rules can represent a larger set of reorderings between languages, but also require greater computational complexity for word alignment algorithms based on synchronous parsing).", "labels": [], "entities": [{"text": "word alignment", "start_pos": 142, "end_pos": 156, "type": "TASK", "confidence": 0.7598194777965546}]}, {"text": "Grammar rules extracted from large parallel corpora by systems such as can be quite large, and argue that complex rules are necessary by analyzing the coverage of gold-standard word alignments from different language pairs by various grammars.", "labels": [], "entities": []}, {"text": "However, parsing complexity depends not only on rule length, but also on the specific permutations represented by the individual rules.", "labels": [], "entities": [{"text": "parsing", "start_pos": 9, "end_pos": 16, "type": "TASK", "confidence": 0.9740362763404846}]}, {"text": "It maybe possible to factor an SCFG with maximum rule length n into a simpler grammar with a maximum of k nonterminals in anyone rule, if not all n!", "labels": [], "entities": []}, {"text": "permutations appear in the rules.", "labels": [], "entities": []}, {"text": "discuss methods for binarizing SCFGs, ignoring the nonbinarizable grammars; in Section 2 we discuss the generalized problem of factoring to k-ary grammars for any k and formalize the problem as permutation factorization in Section 3.", "labels": [], "entities": []}, {"text": "In Section 4, we describe an O(k \u00b7 n) left-toright shift-reduce algorithm for analyzing permutations that can be k-arized.", "labels": [], "entities": [{"text": "O", "start_pos": 29, "end_pos": 30, "type": "METRIC", "confidence": 0.9369435906410217}]}, {"text": "Its time complexity becomes O(n 2 ) when k is not specified beforehand and the minimal k is to be discovered.", "labels": [], "entities": [{"text": "O", "start_pos": 28, "end_pos": 29, "type": "METRIC", "confidence": 0.9928521513938904}]}, {"text": "Instead of linearly shifting in one number at a time,  employ a balanced binary tree as the control structure, producing an algorithm similar in spirit to merge-sort with a reduced time complexity of O(n log n).", "labels": [], "entities": []}, {"text": "However, both algorithms rely on reduction tests on emerging spans which involve redundancies with the spans that have already been tested.", "labels": [], "entities": []}, {"text": "describe a clever algorithm for the problem of finding all common intervals of two permutations in time O(n + K), where K is the number of common intervals, which can itself be \u2126(n 2 ).", "labels": [], "entities": []}, {"text": "In Section 5, we adapt their approach to the problem of factoring SCFGs, and show that, given this problem definition, running time can be improved to O(n), the optimum given the time needed to read the input permutation.", "labels": [], "entities": [{"text": "O", "start_pos": 151, "end_pos": 152, "type": "METRIC", "confidence": 0.9959169030189514}]}, {"text": "The methodology in measures the complexity of word alignment using the number of gaps that are necessary for their synchronous parser which allows discontinuous spans to succeed in parsing.", "labels": [], "entities": [{"text": "word alignment", "start_pos": 46, "end_pos": 60, "type": "TASK", "confidence": 0.7558369338512421}]}, {"text": "In Section 6, we provide a more direct measurement using the minimal branching factor yielded by the permutation factorization algorithm.", "labels": [], "entities": []}], "datasetContent": [{"text": "We apply the factorization algorithm to analyzing word alignments in this section.", "labels": [], "entities": [{"text": "word alignments", "start_pos": 50, "end_pos": 65, "type": "TASK", "confidence": 0.6759265512228012}]}, {"text": "indicate the necessity of introducing discontinuous spans for synchronous parsing to match up with human-annotated word alignment data.", "labels": [], "entities": [{"text": "word alignment", "start_pos": 115, "end_pos": 129, "type": "TASK", "confidence": 0.6932259052991867}]}, {"text": "The number of discontinuous spans reflects the structural complexity of the synchronous rules that are involved in building the synchronous trees for the given alignments.", "labels": [], "entities": []}, {"text": "However, the more direct and detailed analysis would be on the branching factors of the synchronous trees for the aligned data.", "labels": [], "entities": []}, {"text": "Since human-aligned data has many-to-one word links, it is necessary to modify the alignments into one-to-one.", "labels": [], "entities": []}, {"text": "treat many-toone word links disjunctively in their synchronous parser.", "labels": [], "entities": []}, {"text": "We also commit to one of the many-one links by extracting a maximum match () from the bipartite graph of the alignment.", "labels": [], "entities": []}, {"text": "In other words, we abstract away the alternative links in the given alignment while capturing the backbone using the maximum number of word links.", "labels": [], "entities": []}, {"text": "We use the same alignment data for the five language pairs Chinese/English, Romanian/English, Hindi/English, Spanish/English, and French/English ().", "labels": [], "entities": []}, {"text": "In, we report the number of sentences that are k-ary parsable but not k \u2212 1-ary parsable for increasing k's.", "labels": [], "entities": []}, {"text": "Our analysis reveals that the permutations that are accountable for non-ITG alignments include higher order permutations such as (3, 1, 5, 2, 4), albeit sparsely seen.", "labels": [], "entities": []}, {"text": "We also look at the number of terminals the nonbinary synchronous nodes can cover.", "labels": [], "entities": []}, {"text": "We are interested in doing so, because this can tell us how general these unfriendly rules are.) did a similar analysis on the English-English bitext.", "labels": [], "entities": []}, {"text": "They found out the majority of non-ITG parsable cases are not local in the sense that phrases of length up to 10 are not helpful in covering the gaps.", "labels": [], "entities": []}, {"text": "We analyzed the translation data for the five language pairs instead.", "labels": [], "entities": []}, {"text": "The rightmost column in shows that only a tiny percent of the non-ITG cases are significant in the sense that we cannot deal with them through phrases or tree-flattening within windows of size 10.: Evolution of u(x, y), l(x, y), and f (x, y) as y goes from 2 to 7 for the permutation (5, 7, 4, 6, 3, 1, 2).", "labels": [], "entities": []}, {"text": "We use * under the x-axis to indicate the x * 's that are pivots in the algorithm.", "labels": [], "entities": []}, {"text": "Useless x's are crossed out.", "labels": [], "entities": []}, {"text": "x's that contribute to reductions are marked with either ( on its left or ) on its right.", "labels": [], "entities": []}, {"text": "For the f function, we use solid boxes to plot the values of remaining x's on the list but also show the other f values for completeness.", "labels": [], "entities": []}], "tableCaptions": [{"text": " Table 1: The execution trace of the shift-reduce  parser on the input permutation 5, 7, 4, 6, 3, 1, 2.", "labels": [], "entities": []}, {"text": " Table 2: Distribution of branching factors for synchronous trees on various language pairs.", "labels": [], "entities": []}]}