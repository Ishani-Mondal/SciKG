{"title": [{"text": "Modular and Efficient Top-Down Parsing for Ambiguous Left-Recursive Grammars", "labels": [], "entities": []}], "abstractContent": [{"text": "In functional and logic programming, parsers can be built as modular executable specifications of grammars, using parser combinators and definite clause grammars respectively.", "labels": [], "entities": []}, {"text": "These techniques are based on top-down backtracking search.", "labels": [], "entities": []}, {"text": "Commonly used implementations are inefficient for ambiguous languages, cannot accommodate left-recursive grammars, and require exponential space to represent parse trees for highly ambiguous input.", "labels": [], "entities": []}, {"text": "Memoization is known to improve efficiency, and work by other researchers has had some success in accommodating left recursion.", "labels": [], "entities": [{"text": "Memoization", "start_pos": 0, "end_pos": 11, "type": "TASK", "confidence": 0.8478781580924988}]}, {"text": "This paper combines aspects of previous approaches and presents a method by which parsers can be built as modular and efficient executable specifications of ambiguous grammars containing unconstrained left recursion.", "labels": [], "entities": []}], "introductionContent": [{"text": "Top-down parsers can be built as a set of mutuallyrecursive processes.", "labels": [], "entities": []}, {"text": "Such implementations are modular in the sense that parsers for terminals and simple non-terminals can be built and tested first.", "labels": [], "entities": []}, {"text": "Subsequently, parsers for more complex non-terminals can be constructed and tested., and discuss this and other advantages of top-down parsing.", "labels": [], "entities": []}, {"text": "In functional and logic programming, top-down parsers can be built using parser combinators (e.g. see Hutton 1992 fora discussion of the origins of parser combinators, and Frost 2006 fora discussion of their use in natural-language processing) and definite clause grammars (DCGs) respectively.", "labels": [], "entities": []}, {"text": "For example, consider the following grammar, in which s stands for sentence, np for nounphrase, vp for verbphrase, and det for determiner: A set of parsers for this grammar can be constructed in the Haskell functional programming language as follows, where term, 'orelse', and 'thenS' are appropriately-defined higher-order functions called parser combinators.", "labels": [], "entities": []}, {"text": "(Note that backquotes surround infix functions in Haskell).", "labels": [], "entities": []}, {"text": "Note that the parsers are written directly in the programming language, in code which is similar in structure to the rules of the grammar.", "labels": [], "entities": []}, {"text": "As such, the implementation can bethought of as an executable specification with all of the associated advantages.", "labels": [], "entities": []}, {"text": "In particular, this approach facilitates modular piecewise construction and testing of component parsers.", "labels": [], "entities": []}, {"text": "It also allows parsers to be defined to return semantic values directly instead of intermediate parse results, and parsers to be parameterized in order to accommodate context-sensitive lan-guages (e.g.).", "labels": [], "entities": []}, {"text": "Also, in functional programming, the type checker can be used to catch errors in parsers attributed with semantic actions.", "labels": [], "entities": []}, {"text": "Parser combinators and DCGs have been used extensively in applications such as prototyping of compilers, and the creation of natural language interfaces to databases, search engines, and web pages, where complex and varied semantic actions are closely integrated with syntactic processing.", "labels": [], "entities": []}, {"text": "However, both techniques are based on top-down recursive descent search with backtracking.", "labels": [], "entities": []}, {"text": "Commonly used implementations have exponential complexity for ambiguous languages, cannot handle leftrecursion, and do not produce compact representations of parse trees.", "labels": [], "entities": []}, {"text": "(Note, a left-recursive grammar is one in which a non-terminal p derives an expansion p ..", "labels": [], "entities": []}, {"text": "headed with a p either directly or indirectly.", "labels": [], "entities": []}, {"text": "Application of a parser for such a grammar results in infinite descent.)", "labels": [], "entities": []}, {"text": "These shortcomings limit the use of parser combinators and DCGs especially in natural-language processing.", "labels": [], "entities": []}, {"text": "The problem of exponential time complexity in top-down parsers constructed as sets of mutuallyrecursive functions has been solved by who uses memotables to achieve polynomial complexity.", "labels": [], "entities": []}, {"text": "Norvig's technique is similar to the use of dynamic programming and state sets in Earley's algorithm, and tables in the CYK algorithm of Cocke, Younger and Kasami.", "labels": [], "entities": []}, {"text": "The basic idea in Norvig's approach is that when a parser is applied to the input, the result is stored in a memotable for subsequent reuse if the same parser is ever reapplied to the same input.", "labels": [], "entities": []}, {"text": "In the context of parser combinators, Norvig's approach can be implemented using a function memoize to selectively \"memoize\" parsers.", "labels": [], "entities": []}, {"text": "In some applications, the problem of leftrecursion can be overcome by transforming the grammar to a weakly equivalent non-left-recursive form.", "labels": [], "entities": []}, {"text": "(i.e. to a grammar which derives the same set of sentences).", "labels": [], "entities": []}, {"text": "Early methods of doing this resulted in grammars that are significantly larger than the original grammars.", "labels": [], "entities": []}, {"text": "This problem of grammar size has been solved by who developed a method, based on a left-corner grammar transformation, which produces non-left recursive grammars that are not much larger than the originals.", "labels": [], "entities": []}, {"text": "However, although converting a grammar to a weaklyequivalent form is appropriate in some applications (such as speech recognition) it is not appropriate in other applications.", "labels": [], "entities": [{"text": "speech recognition", "start_pos": 111, "end_pos": 129, "type": "TASK", "confidence": 0.812399685382843}]}, {"text": "According to converting a grammar to non-left recursive form makes it harder to translate expressions containing left-associative operators.", "labels": [], "entities": []}, {"text": "Also, in NLP it is easier to integrate semantic actions with parsing when both leftmost and rightmost parses of ambiguous input are being generated.", "labels": [], "entities": []}, {"text": "For example, consider the first of the following grammar rules: np ::= noun | np conj np conj ::= \"and\" | \"or\" noun ::= \"jim\" | \"su\" | \"ali\" and its non-left-recursive weakly equivalent form: np ::= noun np' np' ::= conj np np' | empty The non-left-recursive form loses the leftmost parses generated by the left-recursive form.", "labels": [], "entities": []}, {"text": "Integrating semantic actions with the non-left-recursive rule in order to achieve the two correct interpretations of input such as [\"john\", \"and\", \"su\", \"or\", \"ali\"] is significantly harder than with the left-recursive form.", "labels": [], "entities": []}, {"text": "Several researchers have recognized the importance of accommodating left-recursive grammars in top-down parsing, in general and in the context of parser combinators and DCGs in particular, and have proposed various solutions.", "labels": [], "entities": []}, {"text": "That work is described in detail in section 3.", "labels": [], "entities": []}, {"text": "In this paper, we integrate Norvig's technique with aspects of existing techniques for dealing with left recursion.", "labels": [], "entities": []}, {"text": "In particular: a) we make use of the length of the remaining input as does, b) we keep a record of how many times each parser is applied to each input position in away that is similar to the use of cancellation sets by, c) we integrate memoization with a technique for dealing with left recursion as does Johnson, and d) we store \"left-recursion counts\" in the memotable, and encapsulate the memoization process in a programming construct called a monad, as suggested by.", "labels": [], "entities": []}, {"text": "Our method includes anew technique for accommodating indirect left recursion which ensures correct reuse of stored results created through curtailment of left-recursive parsers.", "labels": [], "entities": []}, {"text": "We also modify the memoization process so that the memotable represents the potentially exponential number of parse trees in a compact polynomial sized form using a technique derived from the chart parsing methods of and.", "labels": [], "entities": [{"text": "chart parsing", "start_pos": 192, "end_pos": 205, "type": "TASK", "confidence": 0.7820484936237335}]}, {"text": "As an example use of our method, consider the following ambiguous left-recursive grammar from in which pp stands for prepositional phrase, and prep for preposition.", "labels": [], "entities": []}, {"text": "This grammar is left recursive in the rules for sand np.", "labels": [], "entities": []}, {"text": "Experimental results using larger grammars are given later.", "labels": [], "entities": []}, {"text": "It is a compact representation of the parse trees corresponding to the several ways in which the whole input can be parsed as a sentence, and the many ways in which subsequences of it can be parsed as nounphrases etc.", "labels": [], "entities": []}, {"text": "We discuss this representation in more detail in subsection 4.4.", "labels": [], "entities": []}, {"text": "Our method has two disadvantages: a) it has O(n 4 ) time complexity, for ambiguous grammars, compared with O(n 3 ) for Earley-style parsers, and b) it requires the length of the input to be known before parsing can commence.", "labels": [], "entities": [{"text": "O(n 4 ) time complexity", "start_pos": 44, "end_pos": 67, "type": "METRIC", "confidence": 0.887433545930045}, {"text": "O", "start_pos": 107, "end_pos": 108, "type": "METRIC", "confidence": 0.9731221795082092}]}, {"text": "Our method maintains all of the advantages of top-down parsing and parser combinators discussed earlier.", "labels": [], "entities": []}, {"text": "In addition, our method accommodates arbitrary context-free grammars, terminates correctly and correctly reuses results generated by direct and indirect left recursive rules.", "labels": [], "entities": []}, {"text": "It parses ambiguous languages in polynomial time and creates polynomialsized representations of parse trees.", "labels": [], "entities": []}, {"text": "In many applications the advantages of our approach will outweigh the disadvantages.", "labels": [], "entities": []}, {"text": "In particular, the additional time required for parsing will not be a major factor in the overall time required when semantic processing, especially of ambiguous input, is taken into account.", "labels": [], "entities": [{"text": "parsing", "start_pos": 48, "end_pos": 55, "type": "TASK", "confidence": 0.9785823822021484}]}, {"text": "We begin with some background material, showing how our approach relates to previous work by others.", "labels": [], "entities": []}, {"text": "We follow that with a detailed description of our method.", "labels": [], "entities": []}, {"text": "Sections 5, 6, and 7 contain informal proofs of termination and complexity, and a brief description of a Haskell implementation of our algorithm.", "labels": [], "entities": []}, {"text": "Complete proofs and the Haskell code are available from any of the authors.", "labels": [], "entities": [{"text": "Haskell code", "start_pos": 24, "end_pos": 36, "type": "DATASET", "confidence": 0.824561208486557}]}, {"text": "We tested our implementation on four naturallanguage grammars from, and on four abstract highly-ambiguous grammars.", "labels": [], "entities": []}, {"text": "The results, which are presented in section 8, indicate that our method is viable for many applications, especially those for which parser combinators and definite clause grammars are particularly well-suited.", "labels": [], "entities": []}, {"text": "We present our approach with respect to parser combinators.", "labels": [], "entities": []}, {"text": "However, our method can also be implemented in other languages which support recursion and dynamic data structures.", "labels": [], "entities": []}], "datasetContent": [{"text": "In order to provide evidence of the low-order polynomial costs and scalability of our method, we conducted a limited evaluation with respect to four practical natural-language grammars used by Tomita () when comparing his algorithm with Earley's, and four variants of an abstract highly ambiguous grammar from.", "labels": [], "entities": []}, {"text": "Our Haskell program was compiled using the Glasgow Haskell Compiler 6.6 (the code has not yet been tuned to obtain the best performance from this patform).", "labels": [], "entities": [{"text": "Glasgow Haskell Compiler 6.6", "start_pos": 43, "end_pos": 71, "type": "DATASET", "confidence": 0.9805824309587479}]}, {"text": "We used a 3GHz/1GB PC in our experiments.", "labels": [], "entities": []}], "tableCaptions": []}