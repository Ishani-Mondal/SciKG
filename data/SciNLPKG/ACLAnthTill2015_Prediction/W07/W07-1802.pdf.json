{"title": [], "abstractContent": [{"text": "We present an algorithm for converting Grammatical Framework grammars (Ranta, 2004) into the Regulus unification-based framework (Rayner et al., 2006).", "labels": [], "entities": [{"text": "Regulus unification-based", "start_pos": 93, "end_pos": 118, "type": "TASK", "confidence": 0.6775343716144562}]}, {"text": "The main purpose is to take advantage of the Regulus-to-Nuance compiler for generating optimized speech recognition grammars.", "labels": [], "entities": [{"text": "generating optimized speech recognition grammars", "start_pos": 76, "end_pos": 124, "type": "TASK", "confidence": 0.7016648530960083}]}, {"text": "But there is also a theoretical interest in knowing how similar the two grammar formalisms are.", "labels": [], "entities": []}, {"text": "Since Grammatical Framework is more expressive than Regulus, the resulting Regu-lus grammars can be overgenerating.", "labels": [], "entities": [{"text": "Regulus", "start_pos": 52, "end_pos": 59, "type": "DATASET", "confidence": 0.917612612247467}]}, {"text": "We therefore describe a subclass of Grammatical Framework for which the algorithm results in an equivalent Regulus grammar.", "labels": [], "entities": []}, {"text": "1 Background In this section we describe the grammar formalism Grammatical Framework (GF), and discuss its expressive power and the present options for creating speech recognition grammars (SRGs).", "labels": [], "entities": [{"text": "speech recognition grammars (SRGs)", "start_pos": 161, "end_pos": 195, "type": "TASK", "confidence": 0.809272954861323}]}, {"text": "The main problem is that the size of the grammar can explode when inflectional parameters are expanded.", "labels": [], "entities": []}, {"text": "In this paper we try to solve this problem by converting to a formalism for which there is an optimized SRG compiler.", "labels": [], "entities": []}, {"text": "This formalism is Regulus, which is described together with its SRG compiler.", "labels": [], "entities": [{"text": "Regulus", "start_pos": 18, "end_pos": 25, "type": "DATASET", "confidence": 0.79349684715271}, {"text": "SRG compiler", "start_pos": 64, "end_pos": 76, "type": "DATASET", "confidence": 0.8927842676639557}]}, {"text": "The formal details are left out of the descriptions in this section and can instead be found in section 2.", "labels": [], "entities": []}, {"text": "In section 3 the conversion algorithm is presented in detail, and in section 4 there is a short discussion.", "labels": [], "entities": [{"text": "conversion", "start_pos": 17, "end_pos": 27, "type": "TASK", "confidence": 0.9721945524215698}]}, {"text": "1.1 Grammatical Framework Grammatical Framework (Ranta, 2004) is a grammar formalism based on type theory.", "labels": [], "entities": []}, {"text": "The main feature is the separation of abstract and concrete syntax , which makes it very suitable for writing multilingual grammars.", "labels": [], "entities": []}, {"text": "A rich module system also facilitates grammar writing as an engineering task, by reusing common grammars.", "labels": [], "entities": [{"text": "grammar writing", "start_pos": 38, "end_pos": 53, "type": "TASK", "confidence": 0.8194190859794617}]}, {"text": "1.1.1 Separating abstract and concrete syntax The main idea of GF is the separation of abstract and concrete syntax, a distinction which is shared with several other grammar formalisms such as Abstract Categorial Grammars (de Groote, 2001), Lambda Grammar (Muskens, 2003) and Higher Order Grammar (Pollard, 2004).", "labels": [], "entities": []}, {"text": "The abstract part of a grammar defines a set of abstract syntactic structures , called abstract terms or trees; and the concrete part defines a relation between abstract structures and concrete structures.", "labels": [], "entities": []}, {"text": "GF has a linearization perspective to grammar writing, where the relation between abstract and concrete is viewed as a mapping from abstract to concrete structures, called linearization terms.", "labels": [], "entities": [{"text": "grammar writing", "start_pos": 38, "end_pos": 53, "type": "TASK", "confidence": 0.7883701920509338}]}, {"text": "In some cases the mapping can be partial or even many-valued.", "labels": [], "entities": []}, {"text": "Although not exploited in many well-known grammar formalisms, a clear separation between abstract and concrete syntax gives some advantages.", "labels": [], "entities": []}, {"text": "High-level language descriptions: When describing the abstract syntax, the grammar writer can choose not to care about language specific details , such as inflection and word order.", "labels": [], "entities": []}, {"text": "Multilingual grammars: It is possible to define different concrete syntaxes for one particular 9 abstract syntax.", "labels": [], "entities": []}, {"text": "Multilingual grammars can be used as a model for interlingua translation, but also to simplify localization of language technology applications.", "labels": [], "entities": [{"text": "interlingua translation", "start_pos": 49, "end_pos": 72, "type": "TASK", "confidence": 0.8012641966342926}]}, {"text": "Resource grammars: The abstract syntax of one grammar can be used as a concrete syntax of another grammar.", "labels": [], "entities": []}, {"text": "This makes it possible to implement grammar resources to be used in several different application domains.", "labels": [], "entities": []}], "introductionContent": [], "datasetContent": [], "tableCaptions": []}