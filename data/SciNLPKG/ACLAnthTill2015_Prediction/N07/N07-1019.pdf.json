{"title": [], "abstractContent": [{"text": "We relate the problem of finding the best application of a Synchronous Context-Free Grammar (SCFG) rule during parsing to a Markov Random Field.", "labels": [], "entities": []}, {"text": "This representation allows us to use the theory of expander graphs to show that the complexity of SCFG parsing of an input sentence of length N is \u2126(N cn), fora grammar with maximum rule length n and some constant c.", "labels": [], "entities": [{"text": "SCFG parsing of an input sentence", "start_pos": 98, "end_pos": 131, "type": "TASK", "confidence": 0.8687751293182373}]}, {"text": "This improves on the previous best result of \u2126(N c \u221a n).", "labels": [], "entities": []}], "introductionContent": [{"text": "Recent interest in syntax-based methods for statistical machine translation has lead to work in parsing algorithms for synchronous context-free grammars (SCFGs).", "labels": [], "entities": [{"text": "statistical machine translation", "start_pos": 44, "end_pos": 75, "type": "TASK", "confidence": 0.739043653011322}, {"text": "parsing algorithms for synchronous context-free grammars (SCFGs)", "start_pos": 96, "end_pos": 160, "type": "TASK", "confidence": 0.6348468528853523}]}, {"text": "Generally, parsing complexity depends on the length of the longest rule in the grammar, but the exact nature of this relationship has only recently begun to be explored.", "labels": [], "entities": [{"text": "parsing", "start_pos": 11, "end_pos": 18, "type": "TASK", "confidence": 0.9630418419837952}]}, {"text": "It has been known since the early days of automata theory) that the languages of string pairs generated by asynchronous grammar can be arranged in an infinite hierarchy, with each rule size \u2265 4 producing languages not possible with grammars restricted to smaller rules.", "labels": [], "entities": []}, {"text": "For any grammar with maximum rule size n, a fairly straightforward dynamic programming strategy yields an O(N n+4 ) algorithm for parsing sentences of length N . However, this is often not the best achievable complexity, and the exact bounds of the best possible algorithms are not known.", "labels": [], "entities": []}, {"text": "showed that a permutation can be defined for any length n such that tabular parsing strategies must take at least \u2126(N c \u221a n ), that is, the exponent of the algorithm is proportional to the square root of the rule length.", "labels": [], "entities": [{"text": "tabular parsing", "start_pos": 68, "end_pos": 83, "type": "TASK", "confidence": 0.8180921375751495}]}, {"text": "In this paper, we improve this result, showing that in the worst case the exponent grows linearly with the rule length.", "labels": [], "entities": []}, {"text": "Using a probabilistic argument, we show that the number of easily parsable permutations grows slowly enough that most permutations must be difficult, whereby difficult we mean that the exponent in the complexity is greater than a constant factor times the rule length.", "labels": [], "entities": []}, {"text": "Thus, not only do there exist permutations that have complexity higher than the square root case of, but in fact the probability that a randomly chosen permutation will have higher complexity approaches one as the rule length grows.", "labels": [], "entities": []}, {"text": "Our approach is to first relate the problem of finding an efficient parsing algorithm to finding the treewidth of a graph derived from the SCFG rule's permutation.", "labels": [], "entities": []}, {"text": "We then show that this class of graphs are expander graphs, which in turn means that the treewidth grows linearly with the graph size.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": []}