{"title": [{"text": "Transition-based Dependency DAG Parsing Using Dynamic Oracles", "labels": [], "entities": [{"text": "Transition-based Dependency DAG Parsing", "start_pos": 0, "end_pos": 39, "type": "TASK", "confidence": 0.5274636596441269}]}], "abstractContent": [{"text": "In most of the dependency parsing studies , dependency relations within a sentence are often presented as a tree structure.", "labels": [], "entities": [{"text": "dependency parsing", "start_pos": 15, "end_pos": 33, "type": "TASK", "confidence": 0.8877744972705841}]}, {"text": "Whilst the tree structure is sufficient to represent the surface relations, deep dependencies which may result to multi-headed relations require more general dependency structures, namely Directed Acyclic Graphs (DAGs).", "labels": [], "entities": []}, {"text": "This study proposes anew dependency DAG parsing approach which uses a dynamic oracle within a shift-reduce transition-based parsing framework.", "labels": [], "entities": [{"text": "dependency DAG parsing", "start_pos": 25, "end_pos": 47, "type": "TASK", "confidence": 0.6284247636795044}]}, {"text": "Although there is still room for improvement on performance with more feature engineering , we already obtain competitive performances compared to static oracles as a result of our initial experiments conducted on the ITU-METU-Sabanc\u0131 Turkish Tree-bank (IMST).", "labels": [], "entities": [{"text": "ITU-METU-Sabanc\u0131 Turkish Tree-bank (IMST)", "start_pos": 218, "end_pos": 259, "type": "DATASET", "confidence": 0.9253996511300405}]}], "introductionContent": [{"text": "Syntactic parsing is the process of determining the grammatical structure of a sentence as conforming to the grammatical rules of the relevant natural language.", "labels": [], "entities": [{"text": "Syntactic parsing", "start_pos": 0, "end_pos": 17, "type": "TASK", "confidence": 0.9274876117706299}]}, {"text": "The structure of the sentence is determined according to the grammar formalism that the parser is built upon.", "labels": [], "entities": []}, {"text": "Phrase structure parsers, also known as constituency parsers, parse a sentence by splitting it into its smaller constituents.", "labels": [], "entities": [{"text": "Phrase structure parsers", "start_pos": 0, "end_pos": 24, "type": "TASK", "confidence": 0.8659743269284567}, {"text": "constituency parsers", "start_pos": 40, "end_pos": 60, "type": "TASK", "confidence": 0.6557942181825638}]}, {"text": "On the other hand, in dependency parsers, the structure of the sentence is represented as dependency trees consisting of directed dependency links between a dependent and ahead word.", "labels": [], "entities": []}, {"text": "Data-driven dependency parsing frameworks have gained increasing popularity in recent years and been used in a wide range of applications such as machine translation), textual entailment () and question answering ().", "labels": [], "entities": [{"text": "Data-driven dependency parsing", "start_pos": 0, "end_pos": 30, "type": "TASK", "confidence": 0.6249692440032959}, {"text": "machine translation", "start_pos": 146, "end_pos": 165, "type": "TASK", "confidence": 0.8054080009460449}, {"text": "textual entailment", "start_pos": 168, "end_pos": 186, "type": "TASK", "confidence": 0.7445749640464783}, {"text": "question answering", "start_pos": 194, "end_pos": 212, "type": "TASK", "confidence": 0.9253077507019043}]}, {"text": "Most data-driven dependency parsers achieve state-of-the art parsing performances with a language agnostic approach on the different syntactic structures of different languages).", "labels": [], "entities": [{"text": "dependency parsers", "start_pos": 17, "end_pos": 35, "type": "TASK", "confidence": 0.6852609515190125}]}, {"text": "Modern data-driven dependency parsers can be categorized into two groups: graph-based and transitionbased parsers.", "labels": [], "entities": []}, {"text": "Graph-based parsers rely on the global optimization of models aiming to find spanning trees over dependency graphs.", "labels": [], "entities": []}, {"text": "On the other hand, transition-based parsers work basically with greedy local decisions that are deterministically selected by oracles, which are generic machine learning models trained to make decisions about the next transition action.", "labels": [], "entities": []}, {"text": "Ina recent study, propose anew approach on transition-based parsing that aims to provide global learning instead of greedy local decisions.", "labels": [], "entities": [{"text": "transition-based parsing", "start_pos": 43, "end_pos": 67, "type": "TASK", "confidence": 0.617455005645752}]}, {"text": "Despite the high performances of both graphbased and transition-based dependency parsers, these are generally bounded by the constraint that each dependent may not have multiple heads.", "labels": [], "entities": []}, {"text": "Therefore, the resulting parsing output is a tree where words correspond to nodes and dependency relations correspond to edges.", "labels": [], "entities": []}, {"text": "Although dependency trees yield satisfactory performances, they are inadequate in capturing dependencies at different levels of semantic interpretations or more complicated linguistic phenomena (e.g. relative clauses, anaphoric references) which could result in multi-head dependencies together with existing surface dependency relations.", "labels": [], "entities": []}, {"text": "An example is given in which is taken from the Turkish IMST.", "labels": [], "entities": [{"text": "Turkish IMST", "start_pos": 47, "end_pos": 59, "type": "DATASET", "confidence": 0.7895879745483398}]}, {"text": "In, the dependent token \"Umut\" depends on more than one head token with SUBJECT relations: 1) the verb \"kos\u00b8makkos\u00b8mak\" (to run) and 2) the verb \"d\u00fcsd\u00fcs\u00b8mek\" (to fall).", "labels": [], "entities": []}, {"text": "Adding a second relation (emphasized with a dash-dotted line in the figure) to the token \"Umut\" breaks the condition that each token may have at most one head, and renders existing dependency tree parsers incompatible for this setup.", "labels": [], "entities": []}, {"text": "It is also worth mentioning that the deep dependencies in the IMST are not discriminated from surface dependencies by the use of different labels.", "labels": [], "entities": [{"text": "IMST", "start_pos": 62, "end_pos": 66, "type": "DATASET", "confidence": 0.7666085362434387}]}, {"text": "In this paper, for the first time in the literature, we investigate the impact of using dynamic oracles for parsing multi-head dependency structures by extending the approach of.", "labels": [], "entities": [{"text": "parsing multi-head dependency structures", "start_pos": 108, "end_pos": 148, "type": "TASK", "confidence": 0.848107635974884}]}, {"text": "We provide comparisons with the replication of the basic shift-reduce DAG parsing algorithm of and a first time implementation of their proposed arceager parsing algorithm.", "labels": [], "entities": [{"text": "DAG parsing", "start_pos": 70, "end_pos": 81, "type": "TASK", "confidence": 0.6291514933109283}, {"text": "arceager parsing", "start_pos": 145, "end_pos": 161, "type": "TASK", "confidence": 0.478037565946579}]}, {"text": "The remainder of the paper first gives a background information about the topic, then introduces the DAG parsing framework and the proposed algorithms together with experiments and results.", "labels": [], "entities": [{"text": "DAG parsing", "start_pos": 101, "end_pos": 112, "type": "TASK", "confidence": 0.7170701175928116}]}], "datasetContent": [{"text": "In order to apply the specified DAG parsing algorithm to non-projective sentences, a pseudoprojective transformation operation is applied to the IMST.", "labels": [], "entities": [{"text": "DAG parsing", "start_pos": 32, "end_pos": 43, "type": "TASK", "confidence": 0.7205932438373566}, {"text": "IMST", "start_pos": 145, "end_pos": 149, "type": "DATASET", "confidence": 0.9176563024520874}]}, {"text": "For that aim, we apply Head scheme 2 described by.", "labels": [], "entities": []}, {"text": "Moreover, before the application of this pseudo-projective transformation, the cyclic dependency paths are handled as described by, by reversing the shortest arc within the cyclic dependency path until no cyclic path remains.", "labels": [], "entities": []}, {"text": "99.3% precision and 99.2% recall are acquired on IMST by applying the pseudo-projective transformation and detransformation operations.", "labels": [], "entities": [{"text": "precision", "start_pos": 6, "end_pos": 15, "type": "METRIC", "confidence": 0.999593198299408}, {"text": "recall", "start_pos": 26, "end_pos": 32, "type": "METRIC", "confidence": 0.9997170567512512}, {"text": "IMST", "start_pos": 49, "end_pos": 53, "type": "DATASET", "confidence": 0.8433256149291992}]}, {"text": "As a learning component, we follow the work of and use a Maximum Entropy model for the classification with the greedy search algorithm.", "labels": [], "entities": []}, {"text": "For the dynamic oracle experiment, we use an averaged perceptron algorithm iterating 15 times over the training data.", "labels": [], "entities": []}, {"text": "The following features are used in all of the experiments: \u2022 The POS tag, lemma and morphological features of the top 3 tokens on the stack and the first 3 tokens in the buffer.", "labels": [], "entities": []}, {"text": "\u2022 The POS tag and dependency relations of the rightmost and leftmost modifiers of the top 2 items on the stack.", "labels": [], "entities": [{"text": "POS tag", "start_pos": 6, "end_pos": 13, "type": "METRIC", "confidence": 0.8566785454750061}]}, {"text": "\u2022 The number of heads and dependents of the top item of the stack and the first item of the buffer.", "labels": [], "entities": []}, {"text": "\u2022 The dependency relations of the top of the stack.", "labels": [], "entities": []}, {"text": "\u2022 Whether the top 2 tokens on the stack have a dependency relation between them or not.", "labels": [], "entities": []}, {"text": "\u2022 Whether the top token of the stack and the first of the buffer have a dependency relation between them or not, and if so the direction and the type of the relation.", "labels": [], "entities": []}, {"text": "\u2022 Combination of the surface form of the top token of the stack and its number of left and right modifiers.", "labels": [], "entities": []}, {"text": "\u2022 Combination of the surface form of the first token of the buffer and its number of left and right modifiers.", "labels": [], "entities": []}, {"text": "\u2022 The surface forms and POS tags of heads of the top token of the stack and the first token of the buffer.", "labels": [], "entities": []}, {"text": "\u2022 The previous two parsing actions.", "labels": [], "entities": [{"text": "parsing", "start_pos": 19, "end_pos": 26, "type": "TASK", "confidence": 0.9692217111587524}]}, {"text": "For training and evaluation purposes, we use the IMST with ten-fold cross validation.", "labels": [], "entities": [{"text": "IMST", "start_pos": 49, "end_pos": 53, "type": "DATASET", "confidence": 0.7011245489120483}]}, {"text": "Experiment results are given in., the static arc-eager DAG implementation for Turkish performs slightly worse than the arc-standard algorithm.", "labels": [], "entities": []}, {"text": "This is not surprising in the light of previous studies reporting that the arc standard algorithm performs better in tree parsing due to the smaller number of classes to be learned by the oracle.", "labels": [], "entities": [{"text": "tree parsing", "start_pos": 117, "end_pos": 129, "type": "TASK", "confidence": 0.7291565537452698}]}, {"text": "However, the proposed multi-head arc-eager algorithm with dynamic oracle (referred to as Dynamic-Eager) yields the best precision, recall and F1 scores among the three experiments.", "labels": [], "entities": [{"text": "precision", "start_pos": 120, "end_pos": 129, "type": "METRIC", "confidence": 0.9995998740196228}, {"text": "recall", "start_pos": 131, "end_pos": 137, "type": "METRIC", "confidence": 0.9987635612487793}, {"text": "F1", "start_pos": 142, "end_pos": 144, "type": "METRIC", "confidence": 0.9995629191398621}]}, {"text": "In this study, although there is still room for improvement on performance with more feature engineering, we obtain better results on Turkish IMST treebank between static and dynamic oracles with our newly proposed method for parsing DAGs.", "labels": [], "entities": [{"text": "Turkish IMST treebank", "start_pos": 134, "end_pos": 155, "type": "DATASET", "confidence": 0.6941621502240499}, {"text": "parsing DAGs", "start_pos": 226, "end_pos": 238, "type": "TASK", "confidence": 0.8505622148513794}]}, {"text": "This encourages us to test our system with different languages as future work with the expectation that the ameliorations will be much higher than the reported ones in the single-head scenario.", "labels": [], "entities": [{"text": "ameliorations", "start_pos": 108, "end_pos": 121, "type": "METRIC", "confidence": 0.9688419699668884}]}], "tableCaptions": [{"text": " Table 1: Unlabeled scores of experiments with  using IMST.", "labels": [], "entities": []}]}