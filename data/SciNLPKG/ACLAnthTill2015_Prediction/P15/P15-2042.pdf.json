{"title": [{"text": "An Efficient Dynamic Oracle for Unrestricted Non-Projective Parsing", "labels": [], "entities": [{"text": "Unrestricted Non-Projective Parsing", "start_pos": 32, "end_pos": 67, "type": "TASK", "confidence": 0.6126868824164072}]}], "abstractContent": [{"text": "We define a dynamic oracle for the Cov-ington non-projective dependency parser.", "labels": [], "entities": []}, {"text": "This is not only the first dynamic oracle that supports arbitrary non-projectivity, but also considerably more efficient (O(n)) than the only existing oracle with restricted non-projectivity support.", "labels": [], "entities": []}, {"text": "Experiments show that training with the dynamic oracle significantly improves parsing accuracy over the static oracle baseline on a wide range of treebanks.", "labels": [], "entities": [{"text": "parsing", "start_pos": 78, "end_pos": 85, "type": "TASK", "confidence": 0.9588941931724548}, {"text": "accuracy", "start_pos": 86, "end_pos": 94, "type": "METRIC", "confidence": 0.9515888690948486}]}], "introductionContent": [{"text": "Greedy transition-based dependency parsers build analyses for sentences incrementally by following a sequence of transitions defined by an automaton, using a scoring model to choose the best transition to take at each state.", "labels": [], "entities": []}, {"text": "While this kind of parsers have become very popular, as they achieve competitive accuracy with especially fast parsing times; their raw accuracy is still behind that of slower alternatives like transitionbased parsers that use beam search (.", "labels": [], "entities": [{"text": "accuracy", "start_pos": 81, "end_pos": 89, "type": "METRIC", "confidence": 0.9969057440757751}, {"text": "accuracy", "start_pos": 136, "end_pos": 144, "type": "METRIC", "confidence": 0.9881354570388794}]}, {"text": "For this reason, a current research challenge is to improve the accuracy of greedy transition-based parsers as much as possible without sacrificing efficiency.", "labels": [], "entities": [{"text": "accuracy", "start_pos": 64, "end_pos": 72, "type": "METRIC", "confidence": 0.9989787340164185}]}, {"text": "A relevant recent advance in this direction is the introduction of dynamic oracles, an improvement in the training procedure of greedy parsers that can boost their accuracy without any impact on parsing speed.", "labels": [], "entities": [{"text": "accuracy", "start_pos": 164, "end_pos": 172, "type": "METRIC", "confidence": 0.9968834519386292}]}, {"text": "An oracle is a training component that selects the best transition(s) to take at a given configuration, using knowledge about the gold tree.", "labels": [], "entities": []}, {"text": "Traditionally, transition-based parsers were trained to follow a so-called static oracle, which is only defined on the configurations of a canonical computation that generates the gold tree, returning the next transition in said computation.", "labels": [], "entities": []}, {"text": "In contrast, dynamic oracles are non-deterministic (not limited to one sequence, but supporting all the possible computations leading to the gold tree), and complete (also defined for configurations where the gold tree is unreachable, choosing the transition(s) that lead to a tree with minimum error).", "labels": [], "entities": []}, {"text": "This extra robustness in training provides higher parsing accuracy.", "labels": [], "entities": [{"text": "parsing", "start_pos": 50, "end_pos": 57, "type": "TASK", "confidence": 0.9725524187088013}, {"text": "accuracy", "start_pos": 58, "end_pos": 66, "type": "METRIC", "confidence": 0.9502132534980774}]}, {"text": "However, defining a usable dynamic oracle fora given parser is non-trivial in general, due to the need of calculating the loss of each configuration, i.e., the minimum Hamming loss to the gold tree from a tree reachable from that configuration.", "labels": [], "entities": []}, {"text": "While it is always easy to do this in exponential time by simulating all possible computations in the algorithm to obtain all reachable trees, it is not always clear how to achieve this calculation in polynomial time.", "labels": [], "entities": []}, {"text": "At the moment, this problem has been solved for several projective parsers exploiting either arc-decomposability) or tabularization of computations ().", "labels": [], "entities": []}, {"text": "However, for parsers that can handle crossing arcs, the only known dynamic oracle ( has been defined fora variant of the parser by Attardi (2006) that supports a restricted set of nonprojective trees.", "labels": [], "entities": []}, {"text": "To our knowledge, no dynamic oracles are known for any transition-based parser that can handle unrestricted non-projectivity.", "labels": [], "entities": []}, {"text": "In this paper, we define such an oracle for the Covington non-projective parser, which can handle arbitrary non-projective dependency trees.", "labels": [], "entities": []}, {"text": "As this algorithm is not arc-decomposable and its tabularization is NP-hard), we do not use the existing techniques to define dynamic oracles, but a reasoning specific to this parser.", "labels": [], "entities": []}, {"text": "It is worth noting that, apart from being the first dynamic oracle supporting unrestricted nonprojectivity, our oracle is very efficient, solving the loss calculation in O(n).", "labels": [], "entities": []}, {"text": "In contrast, the restricted non-projective oracle of has O(n 8 ) time complexity.", "labels": [], "entities": []}, {"text": "The rest of the paper is organized as follows: after a quick outline of Covington's parser in Sect.", "labels": [], "entities": [{"text": "Covington's parser in Sect", "start_pos": 72, "end_pos": 98, "type": "DATASET", "confidence": 0.7703850030899048}]}, {"text": "2, we present the oracle and prove its correctness in Sect.", "labels": [], "entities": []}, {"text": "3. Experiments are reported in Sect.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": [{"text": " Table 2: Parsing accuracy (UAS and LAS, in- cluding punctuation) of Covington non-projective  parser with static (s-Covington) and dynamic (d- Covington) oracles on CoNLL-XI (first block) and  CoNLL-X (second block) datasets. For each lan- guage, we run five experiments with the same  setup but different seeds and report the averaged  accuracy. Best results for each language are shown  in boldface. Statistically significant improvements  (\u03b1 = .05) (Yeh, 2000) are marked with  *  .", "labels": [], "entities": [{"text": "accuracy", "start_pos": 18, "end_pos": 26, "type": "METRIC", "confidence": 0.9072903394699097}, {"text": "accuracy", "start_pos": 338, "end_pos": 346, "type": "METRIC", "confidence": 0.9937421679496765}]}]}