{"title": [{"text": "Inherently Reversible Grammars, Logic Programming and Computability", "labels": [], "entities": []}], "abstractContent": [{"text": "This paper attempts to clarify two distinct notions of \"reversibility\": (i) Uniformity of implementation of parsing and generation, and (it) reversibil-ity as an inherent (or intrinsic) property of grammars.", "labels": [], "entities": []}, {"text": "On the one hand, we explain why grammars specified as definite programs (or the various related \"unification grammars\") lead to uniformity of implementation.", "labels": [], "entities": []}, {"text": "On the other hand, we define different intrinsic reversibility properties for such grammars-the most important being finite reversibility, which says that both parsing and generation are finitely enumerable (see text)-and give examples and counterexamples of grammars which possessor do not possess these intrinsic properties.", "labels": [], "entities": []}, {"text": "We also show that, under a certain \"moderation\" condition on linguistic description, finite enumer-ability of parsing is equivalent to finite enumerabil-ity of generation.", "labels": [], "entities": []}], "introductionContent": [{"text": "From the linguist's point of view, a grammar is a formal device which defines a recursively enumerable set of well-formed linguistic structures, each having, among other aspects, a phonological content (or, when dealing with written text, a string content) and a semantic content.", "labels": [], "entities": []}, {"text": "Such a device is completely neutral as regards its uses for parsing (recovering semantic content from string content) or generation (recovering string content from semantic content).", "labels": [], "entities": []}, {"text": "From the computational linguist's point of view, on the other hand, the problem is how to implement such a grammar both as a parsing program and as a generation program, in such away that these programs exactly reflect the content of the grammar.", "labels": [], "entities": []}, {"text": "This we will call the reversibility problem.", "labels": [], "entities": []}, {"text": "Let us assume, for specificity, that the grammar has been presented as a definite program (a Prolog program)J Then the reversibility problem has a simple solution: use a complete interpreter for definite programs--for instance a top-down interpreter having a breadth-first search procedure2--and directly use the grammar as the program both for parsing and for generation.", "labels": [], "entities": []}, {"text": "In the parsing mode, for any given string x, the program will enumerate all semantics Yl,Y2,...", "labels": [], "entities": []}, {"text": "assigned to it by the grammar, and similarly, in the generation mode, for any given semantics y, the program will enumerate all semantics xl, x2,.., assigned to it by the grammar.", "labels": [], "entities": []}, {"text": "This is a striking property of definite programs: they are reversible in the sense that they naturally lead to uniformity of implementation of the parsing and generation modes (see \u00a74).", "labels": [], "entities": []}, {"text": "So the reversibility problem is solved, and we can spend the next few years skimming through Fodor's (not Jerry's) guides in travel bookstores?", "labels": [], "entities": []}, {"text": "First, the standard depth-first interpreter for definite programs is an incomplete one, and this problem must be circumvented in someway.", "labels": [], "entities": []}, {"text": "Second, and more crucially, even when using a complete interpreter, parsing (and similarly generation) does not in general terminate: the program may well enumerate Yl,Y2,...", "labels": [], "entities": []}, {"text": "This is even true if, in fact, there are only a finite number of solutions Yl,Y2,..., Yk, or even, in the extreme case, no solution at all: the program may not be \"aware\" that it has at some point already exhausted all the solutions that it will eventually 1We could have made some other choice, for instance some unification grammar formalism.", "labels": [], "entities": [{"text": "unification grammar formalism", "start_pos": 314, "end_pos": 343, "type": "TASK", "confidence": 0.8773507475852966}]}, {"text": "The advantage of using definite programs in the present discussion is that they embody the whole unification paradigm in its purest form, that unification of terms is conceptually simpler (and less prone to misunderstandings) than unification of DAGs, and that the denotational and operational semantics of definite programs have been thoroughly studied.", "labels": [], "entities": []}, {"text": "2See e.g. and section \u00a72.1.3.", "labels": [], "entities": []}, {"text": "See also in this volume fora related approach.", "labels": [], "entities": []}, {"text": "find, and goon eternally looking for new solutions.", "labels": [], "entities": []}, {"text": "The source of this problem can be more or less severe: It may simply be due to the grarnmar's implementation as,a certain program, or it maybe intrinsic to the grammar.", "labels": [], "entities": []}, {"text": "If it is not intrinsic to the grammar, one may attempt some kind of program transformation on the grammar--for qnstance a local transformation as goal reordering in clause bodies, or a global transformation as left-recursion elimination 3 --in order 'to get a parsing program which displays a finite behavior.", "labels": [], "entities": []}, {"text": "4 If such a transformation is possible in principle, we say that, intrinsically, the grammar has a finitely enumerable parsing problem.", "labels": [], "entities": []}, {"text": "5 One.example of a class of grammars which respect this crucial condition is provided by offline-parsable DCGs, once compiled as definite programs (see).", "labels": [], "entities": []}, {"text": "6 We have limited the former discussion to the case of parsing.", "labels": [], "entities": [{"text": "parsing", "start_pos": 55, "end_pos": 62, "type": "TASK", "confidence": 0.9800392985343933}]}, {"text": "The case of generation is treated in a parallel fashion, and one can similarly define the conditions in which a grammar is said to have an intrinsically finitely enumerable generation problem.", "labels": [], "entities": []}, {"text": "When a grammar is such that it has a finitely enumerable parsing problem and a finitely enumerable generation problem, we call the grammar inherently finitely reversible.", "labels": [], "entities": []}, {"text": "When this is the; case, it is by definition possible to find a program Pp for parsing and a (not necessarily identical) program Pa for generation such that, for any string z, Pp enumerates all associated semantics y and terminates, and, for any semantics y, Pg enumerates all associated strings z and terminates.", "labels": [], "entities": []}, {"text": "Inherent finite reversibility is the concept which, in my opinion, permit us to capture formally the intuitive notion that a certain grammar is, or is not, \"reversible\".", "labels": [], "entities": []}, {"text": "3Or more generally, any transformation exploiting theorerns provable of the: grammar.", "labels": [], "entities": []}, {"text": "Another instance of this technique is provided by the addition of conservative guides in, which \"strengthen\" the grammar on the basis of properties inferable from \" ' its form.", "labels": [], "entities": []}, {"text": "4 Another popular approach is to use a special-purpose interpreter, exploiting[ properties of the grammar known a priori. and use this approach in the case of generation (see below).", "labels": [], "entities": []}, {"text": ": 5The description is simplified; see \u00a73 for the exact definition.", "labels": [], "entities": []}, {"text": "\u00b0See also fora discussion of oifttine-parsability in the context of generation.", "labels": [], "entities": []}, {"text": "where the the P,Pi are predicate symbols and the Ti, T/j are terms over a certain Herbrand universe of ground terms H.", "labels": [], "entities": []}, {"text": "We will suppose that, among the predicates p defined by P, one, r, is privileged and plays the role of the \"main predicate\" in the program.", "labels": [], "entities": []}, {"text": "We will assume that r is of arity one.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": []}