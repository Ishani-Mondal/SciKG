{"title": [{"text": "COMPILING TRACE & UNIFICATION GRAMMAR FOR PARSING AND GENERATION", "labels": [], "entities": [{"text": "TRACE", "start_pos": 10, "end_pos": 15, "type": "METRIC", "confidence": 0.7294281125068665}, {"text": "GRAMMAR FOR", "start_pos": 30, "end_pos": 41, "type": "METRIC", "confidence": 0.7541052103042603}, {"text": "PARSING", "start_pos": 42, "end_pos": 49, "type": "METRIC", "confidence": 0.6274236440658569}]}], "abstractContent": [], "introductionContent": [{"text": "During the last years there has been a growing interest in NL systems that can be used for both parsing and generation.", "labels": [], "entities": [{"text": "parsing and generation", "start_pos": 96, "end_pos": 118, "type": "TASK", "confidence": 0.694163958231608}]}, {"text": "The invention of unification grammar that allows fora declarative description of language made it possible to use the same grammar for both tasks.", "labels": [], "entities": [{"text": "unification grammar", "start_pos": 17, "end_pos": 36, "type": "TASK", "confidence": 0.901241809129715}]}, {"text": "The main goal of a grammar then is to describe a relation between normalized (semantic) representations and language strings.", "labels": [], "entities": []}, {"text": "A grammar that can be used in both directions is called \"reversible\".", "labels": [], "entities": []}, {"text": "We can distinguish three levels of reversibility.", "labels": [], "entities": []}, {"text": "On the first level, not only the same grammar is used for parsing and generation, but also the interpreter for parsing and generation is reversible.", "labels": [], "entities": [{"text": "parsing and generation", "start_pos": 58, "end_pos": 80, "type": "TASK", "confidence": 0.723488986492157}, {"text": "parsing and generation", "start_pos": 111, "end_pos": 133, "type": "TASK", "confidence": 0.7898315191268921}]}, {"text": "This approach is taken in.", "labels": [], "entities": []}, {"text": "Besides elegance the approach has the advantage that the reversibility is guaranteed.", "labels": [], "entities": []}, {"text": "Further advantages are mentioned in.", "labels": [], "entities": []}, {"text": "As a disadvantage, it is yet unclear whether and how these systems can be made efficient.", "labels": [], "entities": []}, {"text": "On the second level we find systems where the same reversible grammar is processed by two different interpreters, one for parsing, one for generation.", "labels": [], "entities": []}, {"text": "The advantage of these systems is that the grammar can be changed and tested easily, which helps to shorten the development cycle.", "labels": [], "entities": []}, {"text": "The disadvantage again is that grammar interpreters are usually too slow to be used in realistic systems.", "labels": [], "entities": []}, {"text": "On the third level we finally find systems, where the linguistic description is given in a reversible declarative grammar.", "labels": [], "entities": []}, {"text": "This grammar is then compiled into two different forms, one being usefull only for parsing, the other only for generation.", "labels": [], "entities": []}, {"text": "Whereas here we have to face the disadvantage that compiling can take sometime and therefore prolongs the development cycle, the advantage lies in the efficient processing that can be achieved with compiled grammars. and Strzalkowski/Peng (1990) describe a compiler that transforms a grammar originally written for parsing into an efficient generator.", "labels": [], "entities": []}, {"text": "In the follwing section I will present a system of the third type and show by means of which compiling methods a grammar written in a perspicious formalism, TRACE AND UNIFICATION GRAMMAR (TUG) can be transformed to fast parsers and generators.", "labels": [], "entities": [{"text": "TRACE AND UNIFICATION GRAMMAR (TUG)", "start_pos": 157, "end_pos": 192, "type": "METRIC", "confidence": 0.7509643605777195}]}, {"text": "The proposed compilers and their modular architecture have the further advantage that most of their parts can be used also for other formalisms than the one described, e.g. DCGS.", "labels": [], "entities": [{"text": "DCGS", "start_pos": 173, "end_pos": 177, "type": "DATASET", "confidence": 0.9005582332611084}]}, {"text": "The whole system is part of a polyfunctional linguistic processor for German called LINGUISTIC KERNEL PROCESSOR (LKP).", "labels": [], "entities": [{"text": "LINGUISTIC KERNEL", "start_pos": 84, "end_pos": 101, "type": "METRIC", "confidence": 0.8157319724559784}]}, {"text": "The LKP contains a grammar of German with broad coverage.", "labels": [], "entities": []}, {"text": "The grammar describes the relation between a subset of German and a subset of QLF, the intermediate semantic form that is used in the Care Language Engine of SRI Cambridge (Alshawi 1990).", "labels": [], "entities": [{"text": "Care Language Engine of SRI Cambridge (Alshawi 1990)", "start_pos": 134, "end_pos": 186, "type": "DATASET", "confidence": 0.7987184226512909}]}, {"text": "The LKP has been implemented in PROLOG.", "labels": [], "entities": [{"text": "PROLOG", "start_pos": 32, "end_pos": 38, "type": "DATASET", "confidence": 0.7341723442077637}]}, {"text": "Parsing and Generation of a sentence up to 15 words normally takes between 1 and 10 seconds, with a strong tendency to the lower bound.", "labels": [], "entities": [{"text": "Parsing and Generation of a sentence", "start_pos": 0, "end_pos": 36, "type": "TASK", "confidence": 0.8508704900741577}]}], "datasetContent": [], "tableCaptions": []}