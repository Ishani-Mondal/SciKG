{"title": [{"text": "Optimal k-arization of Synchronous Tree-Adjoining Grammar", "labels": [], "entities": []}], "abstractContent": [{"text": "Synchronous Tree-Adjoining Grammar (STAG) is a promising formalism for syntax-aware machine translation and simultaneous computation of natural-language syntax and semantics.", "labels": [], "entities": [{"text": "Synchronous Tree-Adjoining Grammar (STAG)", "start_pos": 0, "end_pos": 41, "type": "TASK", "confidence": 0.7326874037583669}, {"text": "syntax-aware machine translation", "start_pos": 71, "end_pos": 103, "type": "TASK", "confidence": 0.6954692403475443}]}, {"text": "Current research in both of these areas is actively pursuing its incorporation.", "labels": [], "entities": [{"text": "incorporation", "start_pos": 65, "end_pos": 78, "type": "TASK", "confidence": 0.9803081750869751}]}, {"text": "However, STAG parsing is known to be NP-hard due to the potential for intertwined correspondences between the linked nonter-minal symbols in the elementary structures.", "labels": [], "entities": [{"text": "STAG parsing", "start_pos": 9, "end_pos": 21, "type": "TASK", "confidence": 0.9636426568031311}]}, {"text": "Given a particular grammar, the polynomial degree of efficient STAG parsing algorithms depends directly on the rank of the grammar: the maximum number of correspondences that appear within a single elementary structure.", "labels": [], "entities": [{"text": "STAG parsing", "start_pos": 63, "end_pos": 75, "type": "TASK", "confidence": 0.9570630490779877}]}, {"text": "In this paper we present a compile-time algorithm for transforming a STAG into a strongly-equivalent STAG that optimally minimizes the rank, k, across the grammar.", "labels": [], "entities": []}, {"text": "The algorithm performs in O(|G| + |Y | \u00b7 L 3 G) time where LG is the maximum number of links in any single synchronous tree pair in the grammar and Y is the set of synchronous tree pairs of G.", "labels": [], "entities": [{"text": "O", "start_pos": 26, "end_pos": 27, "type": "METRIC", "confidence": 0.9817282557487488}]}], "introductionContent": [{"text": "Tree-adjoining grammar is a widely used formalism in natural-language processing due to its mildlycontext-sensitive expressivity, its ability to naturally capture natural-language argument substitution (via its substitution operation) and optional modification (via its adjunction operation), and the existence of efficient algorithms for processing it.", "labels": [], "entities": []}, {"text": "Recently, the desire to incorporate syntax-awareness into machine translation systems has generated interest in the application of synchronous tree-adjoining grammar (STAG) to this problem).", "labels": [], "entities": [{"text": "machine translation", "start_pos": 58, "end_pos": 77, "type": "TASK", "confidence": 0.7062773555517197}]}, {"text": "Ina parallel development, interest in incorporating semantic computation into the TAG framework has led to the use of STAG for this purpose).", "labels": [], "entities": []}, {"text": "Although STAG does not increase the expressivity of the underlying formalisms, STAG parsing is known to be NPhard due to the potential for intertwined correspondences between the linked nonterminal symbols in the elementary structures.", "labels": [], "entities": [{"text": "STAG parsing", "start_pos": 79, "end_pos": 91, "type": "TASK", "confidence": 0.9247680902481079}]}, {"text": "Without efficient algorithms for processing it, its potential for use in machine translation and TAG semantics systems is limited.", "labels": [], "entities": [{"text": "machine translation", "start_pos": 73, "end_pos": 92, "type": "TASK", "confidence": 0.8097208440303802}, {"text": "TAG semantics", "start_pos": 97, "end_pos": 110, "type": "TASK", "confidence": 0.9111125767230988}]}, {"text": "Given a particular grammar, the polynomial degree of efficient STAG parsing algorithms depends directly on the rank of the grammar: the maximum number of correspondences that appear within a single elementary structure.", "labels": [], "entities": [{"text": "STAG parsing", "start_pos": 63, "end_pos": 75, "type": "TASK", "confidence": 0.9570630490779877}]}, {"text": "This is illustrated by the tree pairs given in in which no two numbered links maybe isolated.", "labels": [], "entities": []}, {"text": "(By \"isolated\", we mean that the links can be contained in a fragment of the tree that contains no other links and dominates only one branch not contained in the fragment. A precise definition is given in section 3.)", "labels": [], "entities": []}, {"text": "An analogous problem has long been known to exist for synchronous context-free grammars (SCFG).", "labels": [], "entities": []}, {"text": "The task of producing efficient parsers for SCFG has recently been addressed by binarization or k-arization of SCFG grammars that produce equivalent grammars in which the rank, k, has been minimized (Zhang w \ud97b\udf59 x \ud97b\udf59 \u03b3 1 : \u03b3 2 : \u03b3 3 :: Example of intertwined links that cannot be binarized.", "labels": [], "entities": []}, {"text": "No two links can be isolated in both trees in a tree pair.", "labels": [], "entities": []}, {"text": "Note that in tree pair \u03b3 1 , any set of three links maybe isolated while in tree pair \u03b3 2 , no group of fewer than four links maybe isolated.", "labels": [], "entities": []}, {"text": "In \u03b3 3 no group of links smaller than four maybe isolated. and).", "labels": [], "entities": []}, {"text": "The methods for k-arization of SCFG cannot be directly applied to STAG because of the additional complexity introduced by the expressivity-increasing adjunction operation of TAG.", "labels": [], "entities": [{"text": "STAG", "start_pos": 66, "end_pos": 70, "type": "TASK", "confidence": 0.593140184879303}]}, {"text": "In SCFG, where substitution is the only available operation and the depth of elementary structures is limited to one, the k-arization problem reduces to analysis of permutations of strings of nonterminal symbols.", "labels": [], "entities": []}, {"text": "In STAG, however, the arbitrary depth of the elementary structures and the lack of restriction to contiguous strings of nonterminals introduced by adjunction substantially complicate the task.", "labels": [], "entities": [{"text": "STAG", "start_pos": 3, "end_pos": 7, "type": "TASK", "confidence": 0.8883609771728516}]}, {"text": "In this paper we offer the first algorithm addressing this problem for the STAG case.", "labels": [], "entities": [{"text": "STAG", "start_pos": 75, "end_pos": 79, "type": "TASK", "confidence": 0.95618736743927}]}, {"text": "We present a compile-time algorithm for transforming a STAG into a strongly-equivalent STAG that optimally minimizes k across the grammar.", "labels": [], "entities": []}, {"text": "This is a critical minimization because k is the feature of the grammar that appears in the exponent of the complexity of parsing algorithms for STAG.", "labels": [], "entities": []}, {"text": "Following the method of, an STAG parser can be implemented with complexity O(n 4\u00b7(k+1) \u00b7 |G|).", "labels": [], "entities": [{"text": "STAG parser", "start_pos": 28, "end_pos": 39, "type": "TASK", "confidence": 0.8358123302459717}]}, {"text": "By minimizing k, the worst-case complexity of a parser instantiated fora particular grammar is optimized.", "labels": [], "entities": []}, {"text": "The karization algorithm performs in O(|G| + |Y | \u00b7 L 3 G ) time where LG is the maximum number of links in any single synchronous tree pair in the grammar and Y is the set of synchronous tree pairs of G.", "labels": [], "entities": [{"text": "O", "start_pos": 37, "end_pos": 38, "type": "METRIC", "confidence": 0.9702861309051514}]}, {"text": "By comparison, a baseline algorithm performing exhaustive search requires The remainder of the paper proceeds as follows.", "labels": [], "entities": []}, {"text": "In section 2 we provide a brief introduction to the STAG formalism.", "labels": [], "entities": [{"text": "STAG formalism", "start_pos": 52, "end_pos": 66, "type": "TASK", "confidence": 0.9133065938949585}]}, {"text": "We present the k-arization algorithm in section 3 and an analysis of its complexity in section 4.", "labels": [], "entities": []}, {"text": "We prove the correctness of the algorithm in section 5.", "labels": [], "entities": []}, {"text": "n 3 : n 5 :: A synchronous tree pair containing fragments \u03b1 L = \u03b3 L (n 1 , n 2 ) and \u03b1 R = \u03b3 R (n 3 ).", "labels": [], "entities": []}, {"text": "Since links(n 1 , n 2 ) = links(n 3 ) = { 2 , 4 , 5 }, we can define synchronous fragment \u03b1 = \u03b1 L , \u03b1 R . Note also that node n 3 is a maximal node and node n 5 is not.", "labels": [], "entities": []}, {"text": "\u03c3(n 1 ) = 2 5 5 3 3 2 4 4 ; \u03c3(n 3 ) = 2 5 5 4 4 2 .", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": []}