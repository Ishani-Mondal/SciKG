{"title": [], "abstractContent": [{"text": "Previous work for encoding Optimality Theory grammars as finite-state transducers has included two prominent approaches: the so-called 'counting' method where constraint violations are counted and filtered out to some set limit of approximability in a finite-state system, and the 'matching' method, where constraint violations in alternative strings are matched through violation alignment in order to remove suboptimal candidates.", "labels": [], "entities": [{"text": "encoding Optimality Theory grammars", "start_pos": 18, "end_pos": 53, "type": "TASK", "confidence": 0.7589263692498207}]}, {"text": "In this paper we extend the matching approach to show how not only markedness constraints, but also faithfulness constraints and the interaction of the two types of constraints can be captured by the matching method.", "labels": [], "entities": []}, {"text": "This often produces exact and small FST representations for OT grammars which we illustrate with two practical example grammars.", "labels": [], "entities": [{"text": "FST", "start_pos": 36, "end_pos": 39, "type": "TASK", "confidence": 0.8544475436210632}, {"text": "OT grammars", "start_pos": 60, "end_pos": 71, "type": "TASK", "confidence": 0.8822414577007294}]}, {"text": "We also provide anew proof of nonregularity of simple OT grammars .", "labels": [], "entities": []}], "introductionContent": [{"text": "The possibility of representing Optimality Theory (OT) grammars as computational models and finite-state transducers, in particular, has been widely studied since the inception of the theory itself.", "labels": [], "entities": [{"text": "Optimality Theory (OT) grammars", "start_pos": 32, "end_pos": 63, "type": "TASK", "confidence": 0.7904218236605326}]}, {"text": "In particular, constructing an OT grammar step-by-step as the composition of a set of transducers, akin to rewrite rule composition in, has offered the attractive possibility of simultaneously modeling OT parsing and generation as a natural consequence of the bidirectionality of finite-state transducers.", "labels": [], "entities": [{"text": "OT parsing and generation", "start_pos": 202, "end_pos": 227, "type": "TASK", "confidence": 0.7952460050582886}]}, {"text": "Two main approaches have received attention as practical options for implementing OT with finite-state transducers: that of and.", "labels": [], "entities": [{"text": "OT", "start_pos": 82, "end_pos": 84, "type": "TASK", "confidence": 0.9783305525779724}]}, {"text": "Both ap-proaches model constraint interaction by constructing a GEN-transducer, which is subsequently composed with filtering transducers that mark violations of constraints, and remove suboptimal candidatescandidates that have received more violation marks than the optimal candidate, with the general template:", "labels": [], "entities": []}], "datasetContent": [{"text": "In order to clarify the main method used in this paper to model OT systems, we will briefly recapitulate the 'matching' approach to filter out suboptimal candidates, or candidates with more violation marks in a string representation, developed in.", "labels": [], "entities": [{"text": "OT", "start_pos": 64, "end_pos": 66, "type": "TASK", "confidence": 0.9754568338394165}]}, {"text": "As an illustrative grammar, let us consider a standard OT example of word-final obstruent devoicing-as in Dutch or German-achieved through the interaction of faithfulness and markedness constraints.", "labels": [], "entities": []}, {"text": "The constraints model the fact that underlyingly voiced obstruents surface as devoiced in word-final position, as in pad \u2192 pat.", "labels": [], "entities": []}, {"text": "A set of core constraints to illustrate this include: \u2022 * VF: a markedness constraint that disallows final voiced obstruents.", "labels": [], "entities": [{"text": "VF", "start_pos": 58, "end_pos": 60, "type": "METRIC", "confidence": 0.9854399561882019}]}, {"text": "\u2022 IDENTV: a faithfulness constraint that militates against change in voicing.", "labels": [], "entities": []}, {"text": "\u2022 VOP: a markedness constraint against voiced obstruents in general.", "labels": [], "entities": [{"text": "VOP", "start_pos": 2, "end_pos": 5, "type": "METRIC", "confidence": 0.9960395097732544}]}, {"text": "The interaction of these constraints to achieve devoicing can be illustrated by the following tableau.", "labels": [], "entities": []}, {"text": "4 The tableau above represents a kind of shorthand often given in the linguistic literature where, for the sake of conciseness, higher-ranked faithfulness constraints are omitted.", "labels": [], "entities": []}, {"text": "For example, there is nothing preventing the candidate bede to rank equally with bet, were it not for an implicit high-ranked DEPconstraint disallowing epenthesis.", "labels": [], "entities": []}, {"text": "As we are building a complete computational model with an unrestricted GEN, and no implicit assumptions, we need to add a few constraints not normally given when arguing about OT models.", "labels": [], "entities": []}, {"text": "These include: \u2022 DEP: a faithfulness constraint against epenthesis.", "labels": [], "entities": [{"text": "DEP", "start_pos": 17, "end_pos": 20, "type": "METRIC", "confidence": 0.9572208523750305}]}, {"text": "\u2022 MAX: a faithfulness constraint against deletion.", "labels": [], "entities": [{"text": "MAX", "start_pos": 2, "end_pos": 5, "type": "METRIC", "confidence": 0.8602155447006226}]}, {"text": "\u2022 IDENTPL: a faithfulness constraint against changes in place of articulation of segments.", "labels": [], "entities": [{"text": "IDENTPL", "start_pos": 2, "end_pos": 9, "type": "METRIC", "confidence": 0.7766839265823364}]}, {"text": "This is crucial to avoid e.g. bat or bap being equally ranked with bet in the above example.", "labels": [], "entities": []}, {"text": "5 Including these constraints explicitly allows us to rule out unwanted candidates that may otherwise rank equal with the candidate where word-final obstruents are devoiced, as illustrated in the following: Once we have settled for the representation of GEN, the basic faithfulness constraint markup transducers-whose job is to insert asterisks wherever violations occur-can be defined as follows: That is, DEP inserts a *-symbol after ( )-sequences, which is how GEN marks epenthesis.", "labels": [], "entities": []}, {"text": "Likewise, MAX-violations are identified by the sequence [ ], and IDENT-violations by a parenthesized segment followed by a bracketed segment.", "labels": [], "entities": []}, {"text": "To define the remaining markup transducers, we shall take advantage of some auxiliary template definitions, defined as functions: Here, Surf(X) in effect changes the language X so that it can match every possible surface encoding produced by GEN; for example, a surface sequence ab may look like[b], or [a](a), etc., since it may spring from various different underlying forms.", "labels": [], "entities": []}, {"text": "This is a useful auxiliary definition that will serve to identify markedness violations.", "labels": [], "entities": []}, {"text": "Likewise Change(X,Y) reflects the GEN representation of changing a segment X to Y needed to concisely identify changed segments.", "labels": [], "entities": [{"text": "Change", "start_pos": 9, "end_pos": 15, "type": "METRIC", "confidence": 0.934626579284668}]}, {"text": "Using the above we may now define the remaining violation markups needed.", "labels": [], "entities": []}, {"text": "The final remaining element fora complete implementation concerns the question of 'worsening' and its introduction into a chain of transducer composition.", "labels": [], "entities": []}, {"text": "To this end, we include a few more definitions: Here, AddViol is the basic worsening method discussed above whereby at least one violation mark is added.", "labels": [], "entities": []}, {"text": "However, because GEN adds markup to the underlying forms, we need to be a bit more flexible in our worsening procedure when matching up violations.", "labels": [], "entities": []}, {"text": "It maybe the case that two different competing surface forms have the same underlying form, but the violation marks will not align correctly because of interfering brackets.", "labels": [], "entities": []}, {"text": "Given two competing candidates with a different number of violations, for example (a)* and [a], we would like the latter to match the former after adding a violation mark since they both originate in the same underlying form a.", "labels": [], "entities": []}, {"text": "The way to achieve this is to undo the effect of GEN, and then redo GEN in every possible configuration before adding the violation marks.", "labels": [], "entities": []}, {"text": "The transducer Worsen, above, does this by a composition of the inverse GEN, followed by GEN, ignoring already existing violations.", "labels": [], "entities": [{"text": "GEN", "start_pos": 89, "end_pos": 92, "type": "METRIC", "confidence": 0.6574734449386597}]}, {"text": "For the above example, this leads to representations such as: We also define a Cleanup transducer that removes brackets and parts of the underlying form.", "labels": [], "entities": []}, {"text": "Now we are ready to compile the entire system into an FST.", "labels": [], "entities": [{"text": "FST", "start_pos": 54, "end_pos": 57, "type": "TASK", "confidence": 0.5808042287826538}]}, {"text": "To apply only GEN and the first constraint, for example, we can calculate: and likewise the entire grammar can be calculated by: This yields an FST of 6 states and 31 transitions (see)-it can be ascertained that the FST indeed does represent a relation where word-final voiced obstruents are always devoiced.", "labels": [], "entities": [{"text": "GEN", "start_pos": 14, "end_pos": 17, "type": "DATASET", "confidence": 0.6156347990036011}, {"text": "FST", "start_pos": 144, "end_pos": 147, "type": "METRIC", "confidence": 0.9123276472091675}, {"text": "FST", "start_pos": 216, "end_pos": 219, "type": "METRIC", "confidence": 0.5860897898674011}]}], "tableCaptions": []}