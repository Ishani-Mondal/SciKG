{"title": [{"text": "Conversion of Procedural Morphologies to Finite-State Morphologies: a Case Study of Arabic", "labels": [], "entities": [{"text": "Conversion of Procedural Morphologies", "start_pos": 0, "end_pos": 37, "type": "TASK", "confidence": 0.6235766410827637}]}], "abstractContent": [{"text": "In this paper we describe a conversion of the Buckwalter Morphological Analyzer for Arabic, originally written as a Perl-script, into a pure finite-state morphological ana-lyzer.", "labels": [], "entities": [{"text": "Buckwalter Morphological Analyzer", "start_pos": 46, "end_pos": 79, "type": "DATASET", "confidence": 0.9424781203269958}]}, {"text": "Representing a morphological ana-lyzer as a finite-state transducer (FST) confers many advantages overrunning a procedural affix-matching algorithm.", "labels": [], "entities": []}, {"text": "Apart from application speed, an FST representation immediately offers various possibilities to flexibly modify a grammar.", "labels": [], "entities": [{"text": "FST representation", "start_pos": 33, "end_pos": 51, "type": "TASK", "confidence": 0.8754596412181854}]}, {"text": "In the case of Arabic, this is illustrated through the addition of the ability to correctly parse partially vocalized forms without overgeneration, something not possible in the original analyzer, as well as to serve both as an analyzer and a generator.", "labels": [], "entities": []}], "introductionContent": [{"text": "Many lexicon-driven morphological analysis systems rely on a general strategy of breaking down input words into constituent parts by consulting customized lexicons and rules designed fora particular language.", "labels": [], "entities": []}, {"text": "The constraints imposed by the lexica designed are then implemented as program code that handles co-occurrence restrictions and analysis of possible orthographic variants, finally producing a parse of the input word.", "labels": [], "entities": []}, {"text": "Some systems designed along these lines are meant for general use, such as the hunspell tool () which allows users to specify lexicons and constraints, while others are language-dependent, such as the Buckwalter Arabic Morphological Analyzer (BAMA)).", "labels": [], "entities": [{"text": "Buckwalter Arabic Morphological Analyzer (BAMA))", "start_pos": 201, "end_pos": 249, "type": "DATASET", "confidence": 0.8982839839799064}]}, {"text": "In this paper we examine the possibility of converting such morphological analysis tools to FSTs that perform the same task.", "labels": [], "entities": []}, {"text": "As a case study, we have chosen to implement a one-to-one faithful conversion of the Buckwalter Arabic analyzer into a finitestate representation using the foma finite state compiler, while also adding some extensions to the original analyzer.", "labels": [], "entities": [{"text": "Buckwalter Arabic analyzer", "start_pos": 85, "end_pos": 111, "type": "DATASET", "confidence": 0.9392679929733276}]}, {"text": "These are useful extensions which are difficult to add to the original Perl-based analyzer because of its procedural nature, but very straightforward to perform in a finite-state environment using standard design techniques.", "labels": [], "entities": []}, {"text": "There are several advantages to representing morphological analyzers as FSTs, as is well noted in the literature.", "labels": [], "entities": [{"text": "FSTs", "start_pos": 72, "end_pos": 76, "type": "TASK", "confidence": 0.6379347443580627}]}, {"text": "Here, in addition to documenting the conversion, we shall also discuss and give examples of the flexibility, extensibility, and speed of application which results from using a finite-state representation of a morphology.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": []}