{"title": [], "abstractContent": [{"text": "While in Computer Science, grammar engineering has led to the development of various tools for checking grammar coherence, completion , under-and over-generation, in Natural Langage Processing, most approaches developed to improve a grammar have focused on detecting under-generation and to a much lesser extent, over-generation.", "labels": [], "entities": [{"text": "completion", "start_pos": 123, "end_pos": 133, "type": "METRIC", "confidence": 0.9700043201446533}]}, {"text": "We argue that generation can be exploited to address other issues that are relevant to grammar engineering such as in particular, detecting grammar incompleteness, identifying sources of over-generation and analysing the linguistic coverage of the grammar.", "labels": [], "entities": []}, {"text": "We present an algorithm that implements these functionalities and we report on experiments using this algorithm to analyse a Feature-Based Lexicalised Tree Adjoining Grammar consisting of roughly 1500 elementary trees.", "labels": [], "entities": []}], "introductionContent": [{"text": "Grammar engineering, the task of developing large scale computational grammars, is known to be error prone.", "labels": [], "entities": [{"text": "Grammar engineering", "start_pos": 0, "end_pos": 19, "type": "TASK", "confidence": 0.8790895342826843}]}, {"text": "As the grammar grows, the interactions between the rules and the lexicon become increasingly complex and the generative power of the grammar becomes increasingly difficult for the grammar writer to predict.", "labels": [], "entities": []}, {"text": "While in Computer Science, grammar engineering has led to the development of various tools for checking grammar coherence, completion, underand over-generation (), in Natural Langage Processing, most approaches developed to improve a grammar have focused on detecting under-generation (that is cases where the grammar and/or the lexicon fails to provide an analysis fora given, grammatical, input) and to a lesser degree over-generation.", "labels": [], "entities": [{"text": "completion", "start_pos": 123, "end_pos": 133, "type": "METRIC", "confidence": 0.9624954462051392}]}, {"text": "In this paper, we argue that generation can be exploited to address other issues that are relevant to grammar engineering.", "labels": [], "entities": [{"text": "grammar engineering", "start_pos": 102, "end_pos": 121, "type": "TASK", "confidence": 0.8570312857627869}]}, {"text": "In particular, we claim that it can be used to: \u2022 Check grammar completeness: for each grammar rule, is it possible to derive a syntactically complete tree ? That is, can each grammar rule be used to derive a constituent.", "labels": [], "entities": []}, {"text": "\u2022 Analyse generation and over-generation: given some time/recursion upper bounds, what does the grammar generate?", "labels": [], "entities": [{"text": "Analyse generation", "start_pos": 2, "end_pos": 20, "type": "TASK", "confidence": 0.889451414346695}]}, {"text": "How much of the output is over-generation?", "labels": [], "entities": []}, {"text": "Which linguistic constructions present in a language are covered by the grammar?", "labels": [], "entities": []}, {"text": "We present a generation algorithm called GRADE (GRAmmar DEbugger) that permits addressing these issues.", "labels": [], "entities": [{"text": "GRADE", "start_pos": 41, "end_pos": 46, "type": "METRIC", "confidence": 0.9848985075950623}]}, {"text": "In essence, this algorithm implements a top-down grammar traversal guided with semantic constraints and controlled by various parameterisable constraints designed to ensure termination and linguistic control.", "labels": [], "entities": []}, {"text": "The GRADE algorithm can be applied to any generative grammar i.e., any grammar which uses a start symbol and a set of production rules to generate the sentences of the language described by that grammar.", "labels": [], "entities": [{"text": "GRADE", "start_pos": 4, "end_pos": 9, "type": "METRIC", "confidence": 0.7962501645088196}]}, {"text": "We present both an abstract description of this algorithm and a concrete implementation which takes advantage of Definite Clause Grammars to implement grammar traversal.", "labels": [], "entities": []}, {"text": "We then present the results of several experiments where we use the GRADE algorithm to examine the output of SEM-TAG, a Feature-Based Lexicalised Tree Adjoining Grammar (FB-LTAG) for French.", "labels": [], "entities": [{"text": "GRADE", "start_pos": 68, "end_pos": 73, "type": "METRIC", "confidence": 0.967247724533081}]}, {"text": "The paper is structured as follows.", "labels": [], "entities": []}, {"text": "Section 2 summarises related work.", "labels": [], "entities": []}, {"text": "Section 3 presents the GRADE algorithm.", "labels": [], "entities": [{"text": "GRADE", "start_pos": 23, "end_pos": 28, "type": "METRIC", "confidence": 0.7007023692131042}]}, {"text": "Section 4 introduces the grammar used for testing and describes an implementation of GRADE for FB-LTAG.", "labels": [], "entities": [{"text": "GRADE", "start_pos": 85, "end_pos": 90, "type": "METRIC", "confidence": 0.7693644762039185}, {"text": "FB-LTAG", "start_pos": 95, "end_pos": 102, "type": "DATASET", "confidence": 0.9550564289093018}]}, {"text": "Section 5 presents the results obtained by applying the GRADE algorithm to SEMTAG.", "labels": [], "entities": [{"text": "GRADE", "start_pos": 56, "end_pos": 61, "type": "METRIC", "confidence": 0.9572024941444397}, {"text": "SEMTAG", "start_pos": 75, "end_pos": 81, "type": "DATASET", "confidence": 0.7993332147598267}]}, {"text": "We show that it helps (i) to detect sources of grammar incompleteness (i.e., rules that do not lead to a complete derivation) and (ii) to identify overgeneration and analyse linguistic coverage.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": [{"text": " Table 1: Checking for Gaps in the Grammar", "labels": [], "entities": []}]}