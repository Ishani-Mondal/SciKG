{"title": [{"text": "Refining the Design of a Contracting Finite-State Dependency Parser", "labels": [], "entities": [{"text": "Refining", "start_pos": 0, "end_pos": 8, "type": "TASK", "confidence": 0.957883358001709}]}], "abstractContent": [{"text": "This work complements a parallel paper of anew finite-state dependency parser architecture (Yli-Jyr\u00e4, 2012) by a proposal fora linguistically elaborated morphology-syntax interface and its finite-state implementation.", "labels": [], "entities": [{"text": "finite-state dependency parser architecture (Yli-Jyr\u00e4, 2012)", "start_pos": 47, "end_pos": 107, "type": "TASK", "confidence": 0.7218517992231581}]}, {"text": "The proposed interface extends Gaifman's (1965) classical dependency rule formalism by separating lexical word forms and morphological categories from syntactic categories.", "labels": [], "entities": []}, {"text": "The separation lets the linguist take advantage of the morphological features in order to reduce the number of dependency rules and to make them lexically selective.", "labels": [], "entities": []}, {"text": "In addition, the relative functional specificity of parse trees gives rise to a measure of parse quality.", "labels": [], "entities": []}, {"text": "By filtering worse parses out from the parse forest using finite-state techniques, the best parses are saved.", "labels": [], "entities": []}, {"text": "Finally, we present a synthesis of strict grammar parsing and robust text parsing by connecting fragmental parses into trees with additional linear successor links.", "labels": [], "entities": [{"text": "strict grammar parsing", "start_pos": 35, "end_pos": 57, "type": "TASK", "confidence": 0.6577349801858267}, {"text": "text parsing", "start_pos": 69, "end_pos": 81, "type": "TASK", "confidence": 0.7614817023277283}]}], "introductionContent": [{"text": "Finite-state dependency parsing aims to combine dependency syntax and finite-state automata into a single elegant system.", "labels": [], "entities": [{"text": "Finite-state dependency parsing", "start_pos": 0, "end_pos": 31, "type": "TASK", "confidence": 0.6633465588092804}]}, {"text": "Deterministic systems such as) are fast but susceptible to gardenpath type errors although some ambiguity is encoded in the output.", "labels": [], "entities": []}, {"text": "Some other systems such as) carryout full projective dependency parsing while being much slower, especially if the syntactic ambiguity is high.", "labels": [], "entities": [{"text": "projective dependency parsing", "start_pos": 42, "end_pos": 71, "type": "TASK", "confidence": 0.7014807860056559}]}, {"text": "In the worst case, the size of the minimal finite-state automaton storing the forest is exponentially larger than the sentence: an 80-word sentence has potentially 1.1 \u00d7 10 62 unrooted unlabeled dependency trees that are stored \"compactly\" into a finite-state lattice that requires at least 2.4 \u00d7 10 24 states, see in.", "labels": [], "entities": []}, {"text": "A truly compact representation of the parse forest is provided by an interesting new extended finitestate parsing architecture) that first recognizes the grammatical sentences in quadratic time and space if the nested dependencies are limited by a constant (in cubic time if the length of the sentence limits the nesting).", "labels": [], "entities": []}, {"text": "The new system) replaces the additive and the intersecting) validation of dependency links with reductive validation that gradually contracts the dependencies until the whole tree has been reduced into a trivial one.", "labels": [], "entities": []}, {"text": "The idea of the contractions is illustrated in Example 1.", "labels": [], "entities": [{"text": "Example", "start_pos": 47, "end_pos": 54, "type": "DATASET", "confidence": 0.7988429069519043}]}, {"text": "In practice, our parser operates on bracketed trees (i.e., strings), but the effect will be similar.", "labels": [], "entities": []}, {"text": "Despite being non-deterministic and efficient, there are two important requirements that are not fulfilled by the core of the new architecture): 1.", "labels": [], "entities": []}, {"text": "A mature finite-state dependency parser must be robust.", "labels": [], "entities": []}, {"text": "The outputs should not be restricted to complete grammatical parses.", "labels": [], "entities": []}, {"text": "For example, Oflazer (2003) builds fragmental parses but later drops those fragmental parses for which there are alternative parses with fewer fragments.", "labels": [], "entities": [{"text": "Oflazer (2003)", "start_pos": 13, "end_pos": 27, "type": "DATASET", "confidence": 0.9261609315872192}]}, {"text": "However, his approach handles only gap-free bottom-up fragments and optimizes the number of fragments by a counting method whose capacity is limited.", "labels": [], "entities": []}, {"text": "2. Besides robustness, a wide-coverage parser should be able to assign reasonably wellmotivated syntactic categories to every word in the input.", "labels": [], "entities": []}, {"text": "This amounts to having a morphological guesser and an adequate morphologysyntax interface.", "labels": [], "entities": []}, {"text": "Most prior work trivializes the complexity of the interface, being comparable to legacy formalism that is mathematically elegant but based on wordform lists.", "labels": [], "entities": []}, {"text": "A good interface formalism is provided, e.g., by Constraint Grammar parsers ( where syntactic rules can refer to morphological features.", "labels": [], "entities": [{"text": "Constraint Grammar parsers", "start_pos": 49, "end_pos": 75, "type": "TASK", "confidence": 0.6887389024098715}]}, {"text": "Oflazer (2003) tests morphological features in complicated regular expressions.", "labels": [], "entities": []}, {"text": "The state complexity of the combination of such expressions is, however, a potential problem if many more rules would be added to the system.", "labels": [], "entities": []}, {"text": "This paper makes two main contributions: 1.", "labels": [], "entities": []}, {"text": "It adapts Gaifman's elegant formalism to the requirements of morphologically rich languages.", "labels": [], "entities": []}, {"text": "With the adapted formalism, grammar writing becomes easier.", "labels": [], "entities": [{"text": "grammar writing", "start_pos": 28, "end_pos": 43, "type": "TASK", "confidence": 0.9027808904647827}]}, {"text": "However, efficient implementation of the rule lookup becomes inherently trickier because testing several morphological conditions in parallel increases the size of the finite-state automata.", "labels": [], "entities": []}, {"text": "Fortunately, the new formalism comes with an efficient implementation that keeps the finite-state representation of the rule set as elegant as possible.", "labels": [], "entities": []}, {"text": "2. The paper introduces a linguistically motivated ranking for complete trees.", "labels": [], "entities": []}, {"text": "According to it, a tree is better than another tree if a larger proportion of its dependency links is motivated by the linguistic rules.", "labels": [], "entities": []}, {"text": "In contrast to, our method counts the number of links needed to connect the fragments into a spanning tree.", "labels": [], "entities": []}, {"text": "Moreover, since such additional links are indeed included in the parses, the ranking method turns a grammar parser into a robust text parser.", "labels": [], "entities": []}, {"text": "The paper is structured as follows.", "labels": [], "entities": []}, {"text": "The next section will give an overview of the new parser architecture.", "labels": [], "entities": []}, {"text": "After it, we present the new morphology-syntax interface in Section 3 and the parse ranking method in Section 4.", "labels": [], "entities": []}, {"text": "The paper ends with theoretical evaluation and discussion about the proposed formalism in Section 5.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": []}