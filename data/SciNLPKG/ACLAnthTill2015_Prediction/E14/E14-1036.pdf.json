{"title": [], "abstractContent": [{"text": "We propose the design of deterministic constituent parsers that choose parser actions according to the probabilities of parses of a given probabilistic context-free grammar.", "labels": [], "entities": []}, {"text": "One of these deterministically constructs a parse structure while postponing commitment to labels.", "labels": [], "entities": []}, {"text": "We investigate theoretical time complexities and report experiments.", "labels": [], "entities": []}], "introductionContent": [], "datasetContent": [{"text": "We used the WSJ treebank from OntoNotes 4.0 (), with Sections 2-21 for training and the 2228 sentences of up to 40 words from Section 23 for testing.", "labels": [], "entities": [{"text": "WSJ treebank from OntoNotes 4.0", "start_pos": 12, "end_pos": 43, "type": "DATASET", "confidence": 0.9005075454711914}]}, {"text": "Grammars with different sizes, and in the required binary form, were extracted by using the tools from the Berkeley parser (), with between 1 and 6 splitmerge cycles.", "labels": [], "entities": []}, {"text": "These tools offer a framework for handling unknown words, which we have adopted.", "labels": [], "entities": []}, {"text": "The implementation of the parsing algorithms is in C++, running on a desktop with four 3.1GHz Intel Core i5 CPUs.", "labels": [], "entities": [{"text": "parsing", "start_pos": 26, "end_pos": 33, "type": "TASK", "confidence": 0.9799495339393616}]}, {"text": "The main algorithm is that of Appendix C, with lookahead k between 1 and 3, also in combination with structural determinism (Appendix B), which is indicated hereby sd.", "labels": [], "entities": []}, {"text": "The variant that consults the stack down to bounded depth n (Appendix D) will only be reported fork = 1 and n = 5.", "labels": [], "entities": [{"text": "Appendix D)", "start_pos": 61, "end_pos": 72, "type": "METRIC", "confidence": 0.9544471104939779}, {"text": "fork", "start_pos": 95, "end_pos": 99, "type": "METRIC", "confidence": 0.978242814540863}]}, {"text": "Bracketing recall, precision and F-measure, are computed using evalb, with settings as in, except that punctuation was deleted.", "labels": [], "entities": [{"text": "Bracketing", "start_pos": 0, "end_pos": 10, "type": "METRIC", "confidence": 0.9573841094970703}, {"text": "recall", "start_pos": 11, "end_pos": 17, "type": "METRIC", "confidence": 0.8611034750938416}, {"text": "precision", "start_pos": 19, "end_pos": 28, "type": "METRIC", "confidence": 0.9996261596679688}, {"text": "F-measure", "start_pos": 33, "end_pos": 42, "type": "METRIC", "confidence": 0.9988927245140076}]}, {"text": "1 A nonterminal B in the stack may occur in a small number of rules of the form A \u2192 BC.", "labels": [], "entities": []}, {"text": "The C of one such rule is needed next in order to allow a reduction.", "labels": [], "entities": [{"text": "C", "start_pos": 4, "end_pos": 5, "type": "METRIC", "confidence": 0.9578035473823547}]}, {"text": "If future input does not deliver this C, then parsing may fail.", "labels": [], "entities": [{"text": "parsing", "start_pos": 46, "end_pos": 53, "type": "TASK", "confidence": 0.9783198237419128}]}, {"text": "This problem becomes more severe as nonterminals become more specific, which is what happens with an increase of the number of split-merge cycles.", "labels": [], "entities": []}, {"text": "Even more failures are introduced by removing the ability to consult the complete stack, which explains the poor results in the case of k = 1, n = 5; lower values of n lead to even more failures, and higher values further increase the running time.", "labels": [], "entities": []}, {"text": "That the running time exceeds that of k = 1 is explained by the fact that with the variant from Appendix D, every pop or push requires a complete recomputation of all function values.", "labels": [], "entities": []}, {"text": "Parse failures can be almost completely eliminated however by choosing higher values of k and by using structural determinism.", "labels": [], "entities": [{"text": "Parse", "start_pos": 0, "end_pos": 5, "type": "TASK", "confidence": 0.6925688982009888}]}, {"text": "A combination thereof leads to high accuracy, not far below that of the Viterbi parses.", "labels": [], "entities": [{"text": "accuracy", "start_pos": 36, "end_pos": 44, "type": "METRIC", "confidence": 0.9994452595710754}]}, {"text": "Note that one cannot expect the accuracy of our deterministic parsers to exceed that of Viterbi parses.", "labels": [], "entities": [{"text": "accuracy", "start_pos": 32, "end_pos": 40, "type": "METRIC", "confidence": 0.999470055103302}]}, {"text": "Both rely on the same model (a PCFG), but the first is forced to make local decisions without access to the input string that follows the bounded lookahead.", "labels": [], "entities": []}], "tableCaptions": [{"text": " Table 1: Total time required (seconds), number of parse failures, recall, precision, F-measure, for deter- ministic parsing, compared to the Viterbi parses as computed with the Berkeley parser.", "labels": [], "entities": [{"text": "Total time required", "start_pos": 10, "end_pos": 29, "type": "METRIC", "confidence": 0.961272656917572}, {"text": "recall", "start_pos": 67, "end_pos": 73, "type": "METRIC", "confidence": 0.9995496869087219}, {"text": "precision", "start_pos": 75, "end_pos": 84, "type": "METRIC", "confidence": 0.9997281432151794}, {"text": "F-measure", "start_pos": 86, "end_pos": 95, "type": "METRIC", "confidence": 0.9993300437927246}, {"text": "deter- ministic parsing", "start_pos": 101, "end_pos": 124, "type": "TASK", "confidence": 0.738072894513607}]}]}