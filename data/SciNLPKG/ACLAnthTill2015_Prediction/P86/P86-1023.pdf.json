{"title": [{"text": "Morph~lo~leal Decomposition and 5tress Assignment for Speech Synthesis", "labels": [], "entities": [{"text": "Synthesis", "start_pos": 61, "end_pos": 70, "type": "TASK", "confidence": 0.75507652759552}]}], "abstractContent": [{"text": "1. Background A speech synthesizer is a machine that inputs a stream of text and outputs a speech signal.", "labels": [], "entities": []}, {"text": "This paper will discuss a small piece of how words are converted to phonemes.", "labels": [], "entities": []}, {"text": "Text 1 Intonation Phrases 1 WORDS ! PHONEMES ! Lpe Dyads + Prosodics ! Speech Typically words are converted to phonemes in one of two ways: either by looking the words up in a dictionary (with possibly some limited morphological analysis), or by sounding the words out from their spelling using basic principles.", "labels": [], "entities": []}, {"text": "\u2022 Dictionary Lookup \u2022 Letter to Sound Both appt~oaches have their advantages and disadvantages; dictionary lookup fails for unknown words (e.g., proper nouns) and letter to sound rules fail for irregular words, which are all too common in English.", "labels": [], "entities": []}, {"text": "Most speech synthesizers adopt a hybrid strategy, using the dictionary when possible and turning to letter to sound rules for the rest.", "labels": [], "entities": []}, {"text": "I discussed letter to sound rules at the last meeting of the ACL [Church]; this paper will report on some new dictionary lookup approaches, with an emphasis on morphology.", "labels": [], "entities": [{"text": "ACL [Church]", "start_pos": 61, "end_pos": 73, "type": "DATASET", "confidence": 0.793847844004631}]}, {"text": "Morphological decomposition is used to reduce the size of the dictionary and to increase coverage.", "labels": [], "entities": [{"text": "Morphological decomposition", "start_pos": 0, "end_pos": 27, "type": "TASK", "confidence": 0.832336962223053}, {"text": "coverage", "start_pos": 89, "end_pos": 97, "type": "METRIC", "confidence": 0.981992244720459}]}, {"text": "Instead of storing all possible words, the system can store just a lexicon of morphemes and save a factor of 10 [Jon Allen (personal communication)] in storage.", "labels": [], "entities": []}, {"text": "Now when the system is given a word and asked to determine is pronunciation, the system decomposes the word into known morphemes, looks up the pronunciation of each of the pieces and combines the results.", "labels": [], "entities": []}, {"text": "2. MITalk Decomp The best known morphological decomposition system is the Decomp module in the MITalk sysnthesizer [Allen et. al.].", "labels": [], "entities": [{"text": "MITalk", "start_pos": 3, "end_pos": 9, "type": "DATASET", "confidence": 0.9558234810829163}]}, {"text": "This system attempted to parse an input word such as formally into morphemes: form,-al and-ly.", "labels": [], "entities": []}, {"text": "It was assumed that morphemes are concatenated together (like \"beads on a string\") according to the finite state grammar shown below: The types of morphemes were: 1. 2. 3. Prefixes (pref): UNtie, PERmit, REduce Suffixes a.", "labels": [], "entities": [{"text": "UNtie", "start_pos": 189, "end_pos": 194, "type": "METRIC", "confidence": 0.8624035716056824}, {"text": "PERmit", "start_pos": 196, "end_pos": 202, "type": "METRIC", "confidence": 0.9750350713729858}, {"text": "REduce", "start_pos": 204, "end_pos": 210, "type": "METRIC", "confidence": 0.9608568549156189}]}, {"text": "Derivational (derv): laxiTY, existENCE, softNESS, kingDOM b.", "labels": [], "entities": [{"text": "kingDOM", "start_pos": 50, "end_pos": 57, "type": "METRIC", "confidence": 0.8481177687644958}]}, {"text": "Inflectional (infl): boatiNG, toastED, coatS, roanS\" Roots a.", "labels": [], "entities": []}, {"text": "Free (root): stay, squeeze, large b.", "labels": [], "entities": []}, {"text": "Absolute (absl): the, than, but c.", "labels": [], "entities": [{"text": "Absolute (absl)", "start_pos": 0, "end_pos": 15, "type": "METRIC", "confidence": 0.8838061541318893}]}, {"text": "Left-Bound (lbrt): rePEL, conCEIVE d.", "labels": [], "entities": [{"text": "rePEL", "start_pos": 19, "end_pos": 24, "type": "METRIC", "confidence": 0.9765197038650513}, {"text": "conCEIVE", "start_pos": 26, "end_pos": 34, "type": "METRIC", "confidence": 0.9718894362449646}]}, {"text": "Right-Bound (rbrt): CRIMINal, TOLERance e.", "labels": [], "entities": [{"text": "CRIMINal", "start_pos": 20, "end_pos": 28, "type": "METRIC", "confidence": 0.9373727440834045}, {"text": "TOLERance", "start_pos": 30, "end_pos": 39, "type": "METRIC", "confidence": 0.9952397346496582}]}, {"text": "Strong (root): women, rang Costs were placed on the arcs to alleviate overgeneration.", "labels": [], "entities": [{"text": "Costs", "start_pos": 27, "end_pos": 32, "type": "METRIC", "confidence": 0.9628466367721558}]}, {"text": "Note that the grammar produces quite a number of spurious analyses.", "labels": [], "entities": []}, {"text": "For example, not only would formally be analyzed as formal -ly but it would also be analyzed as formally and formal -ly.", "labels": [], "entities": []}, {"text": "The cost mechanism blocks these spurious analyses by assigning compounding a higher cost than suffixation and therefore favoring the desired analysis.", "labels": [], "entities": []}, {"text": "Although the cost mechanism handles a large number of cases, it would be better to aim toward a tighter grammar of morphology which did not overgenerate so badly.", "labels": [], "entities": []}], "introductionContent": [], "datasetContent": [], "tableCaptions": []}