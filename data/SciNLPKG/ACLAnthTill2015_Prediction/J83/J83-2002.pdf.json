{"title": [], "abstractContent": [{"text": "Logic grammars are grammars expressible in predicate logic.", "labels": [], "entities": []}, {"text": "Implemented in the programming language Prolog, logic grammar systems have proved to be a good basis for natural language processing.", "labels": [], "entities": [{"text": "natural language processing", "start_pos": 105, "end_pos": 132, "type": "TASK", "confidence": 0.655873586734136}]}, {"text": "One of the most difficult constructions for natural language grammars to treat is coordination (construction with conjunctions like 'and').", "labels": [], "entities": []}, {"text": "This paper describes a logic grammar formalism, modifier structure grammars (MSGs), together with an interpreter written in Prolog, which can handle coordination (and other natural language constructions) in a reasonable and general way.", "labels": [], "entities": [{"text": "Prolog", "start_pos": 124, "end_pos": 130, "type": "DATASET", "confidence": 0.931037187576294}]}, {"text": "The system produces both syntactic analyses and logical forms, and problems of scoping for coordination and quantifiers are dealt with.", "labels": [], "entities": []}, {"text": "The MSG formalism seems of interest in its own right (perhaps even outside natural language processing) because the notions of syntactic structure and semantic interpretation are more constrained than in many previous systems (made more implicit in the formalism itself), so that less burden is put on the grammar writer.", "labels": [], "entities": [{"text": "semantic interpretation", "start_pos": 151, "end_pos": 174, "type": "TASK", "confidence": 0.7529758214950562}]}], "introductionContent": [{"text": "Since the development of the Prolog programming language, logic programming () has been applied in many different fields.", "labels": [], "entities": []}, {"text": "In natural language processing, useful grammar formalisms have been developed and incorporated in Prolog: metamorphosis grammars, due to, and extraposition grammars, defined by F.; definite clause grammars ( area special case of metamorphosis grammars.", "labels": [], "entities": [{"text": "Prolog", "start_pos": 98, "end_pos": 104, "type": "DATASET", "confidence": 0.903383731842041}]}, {"text": "The first sizable application of logic grammars was a Spanish/French-consultable database system by, which was later adapted to Portuguese tion as a \"metagrammatical\" construction, in the sense that metarules, general system operations, or \"secondpass\" operations such as transformations, are needed for its formulation.", "labels": [], "entities": []}, {"text": "Perhaps the most general and powerful metagrammatical device for handling coordination in computational linguistics has been the SYSCONJ facility for augmented transition networks (ATNs).", "labels": [], "entities": []}, {"text": "The ATN interpreter with this facility built into it can take an ATN that does not itself mention conjunctions at all, and will parse reduced coordinate constructions, which are of the form The result of the parse is this unreduced structure.", "labels": [], "entities": []}, {"text": "SYSCONJ accomplishes this by treating the conjunction as an interruption which causes the parser to backup in its history of the parse.", "labels": [], "entities": []}, {"text": "Before backing up, the current configuration (immediately before the interruption) is suspended for later merging.", "labels": [], "entities": []}, {"text": "The backing up is done to a point when the string X was being parsed (this defines X), and with this configuration the string Y is parsed.", "labels": [], "entities": []}, {"text": "The parsing of Y stops when a configuration is reached that can be merged with the suspended configuration, whereupon B is parsed.", "labels": [], "entities": [{"text": "parsing", "start_pos": 4, "end_pos": 11, "type": "TASK", "confidence": 0.9699611067771912}]}, {"text": "The choices made in this process can be deterministic or non-deterministic, and can be guided by syntactic or semantic heuristics.", "labels": [], "entities": []}, {"text": "There are some problems with SYSCONJ, however.", "labels": [], "entities": []}, {"text": "It suffers from inefficiency, due to the combinatorial explosion from all the choices it makes.", "labels": [], "entities": []}, {"text": "Because of this inefficiency, it in fact has not been used to a great extent in ATN parsing.", "labels": [], "entities": [{"text": "ATN parsing", "start_pos": 80, "end_pos": 91, "type": "TASK", "confidence": 0.8415862619876862}]}, {"text": "Another problem is that it does not handle embedded complex structures.", "labels": [], "entities": []}, {"text": "Furthermore, it is not clear to us that SYSCONJ offers a good basis for handling the scoping problems that arise for semantic interpretation when conjunctions interact with quantifiers (and other modifiers) in the sentence.", "labels": [], "entities": [{"text": "semantic interpretation", "start_pos": 117, "end_pos": 140, "type": "TASK", "confidence": 0.7228922843933105}]}, {"text": "This latter problem is discussed in detail below.", "labels": [], "entities": []}, {"text": "In this paper we present a system for handling coordination in logic grammars.", "labels": [], "entities": [{"text": "handling coordination in logic grammars", "start_pos": 38, "end_pos": 77, "type": "TASK", "confidence": 0.6659389853477478}]}, {"text": "The system consists of three things: (1) anew formalism for logic grammars, which we call modifier structure grammars (MSGs), (2) an interpreter (or parser) for MSGs that takes all the responsibility for the syntactic aspects of coordination (as with SYSCONJ), and (3) a semantic interpretation component that produces logical forms from the output of the parser and deals with scoping problems for coordination.", "labels": [], "entities": []}, {"text": "The whole system is implemented in.", "labels": [], "entities": []}, {"text": "Coordination has of course received some treatment in standard logic grammars by the writing of specific grammar rules.", "labels": [], "entities": []}, {"text": "The most extensive treatment of this sort that we know of is in, which also deals with ellipsis.", "labels": [], "entities": []}, {"text": "However, we are aware of no general, metagrammatical treatment of coordination in logic grammars previous to ours.", "labels": [], "entities": []}, {"text": "Modifier structure grammars, described in detail in Section 2, are true logic grammars, in that they can be translated (compiled) directly into Horn clause systems, the program format for Prolog.", "labels": [], "entities": []}, {"text": "In fact, the treatment of extraposition in MSGs is based on F. extraposition grammars (XGs), and MSGs can be compiled into XGs (which in turn can be compiled into Horn clause systems).", "labels": [], "entities": []}, {"text": "A new element in MSGs is that the formation of analysis structures of sentences has been made largely implicit in the grammar formalism.", "labels": [], "entities": [{"text": "MSGs", "start_pos": 17, "end_pos": 21, "type": "TASK", "confidence": 0.9365930557250977}]}, {"text": "For previous logic grammar formalisms, the formation of analyses is entirely the responsibility of the grammar writer.", "labels": [], "entities": []}, {"text": "Compiling MSGs into XGs consists in making this formation of analyses explicit.", "labels": [], "entities": []}, {"text": "Although MSGs can be compiled into XGs, it seems difficult to do this in away that treats coordination automatically (it appears to require more metalogical facilities than are currently available in Prolog systems).", "labels": [], "entities": []}, {"text": "Therefore, we are using an interpreter for MSGs (written in Prolog).", "labels": [], "entities": [{"text": "Prolog", "start_pos": 60, "end_pos": 66, "type": "DATASET", "confidence": 0.9527519345283508}]}, {"text": "For MSGs, the analysis structure associated (by the sYstem) with a sentence is called the modifier structure (MS) of the sentence.", "labels": [], "entities": []}, {"text": "This structure can be considered an annotated phrase structure tree, and in fact the name \"modifier structure grammar\" is intended to be parallel to \"phrase structure grammar\".", "labels": [], "entities": []}, {"text": "If extraposition and coordination are neglected, there is a context-free phrase structure grammar underlying an MSG; and the MS trees are indeed derivation trees for this underlying grammar, but with extra information attached to the nodes.", "labels": [], "entities": []}, {"text": "In an MS tree, each node contains not only syntactic information but also a term called a semantic item (supplied in the grammar), which determines the node's contribution to the logical form of the sentence.", "labels": [], "entities": []}, {"text": "This contribution is for the node alone, and does not refer to the daughters of the node, as in the approach of.", "labels": [], "entities": []}, {"text": "Through their semantic items, the daughters of anode act as modifiers of the node, in a fairly traditional sense made precise below -hence the term \"modifier structure\".", "labels": [], "entities": []}, {"text": "The notion of modifier structure used here and the semantic interpretation component, which depends on it, are much the same as in previous work by McCord, especially the latter paper.", "labels": [], "entities": [{"text": "semantic interpretation", "start_pos": 51, "end_pos": 74, "type": "TASK", "confidence": 0.6985275894403458}]}, {"text": "But new elements are the notion of MSG (making modifier structure implicit in the grammar), the MSG interpreter, with its treatment of coordination, and the specific rules for semantic interpretation of coordination.", "labels": [], "entities": []}, {"text": "The MSG interpreter is described in Section 3.", "labels": [], "entities": []}, {"text": "As indicated above, the interpreter completely handles the syntax of coordination.", "labels": [], "entities": []}, {"text": "The MSG grammar itself should not mention conjunctions at all.", "labels": [], "entities": [{"text": "MSG grammar", "start_pos": 4, "end_pos": 15, "type": "DATASET", "confidence": 0.8408521115779877}]}, {"text": "The interpreter has a general facility for treating certain words as demons, and conjunctions are handled in this way.", "labels": [], "entities": []}, {"text": "When a conjunction demon appears in a sentence A X conj Y B, a process is set off which in outline is like SYSCONJ, in that backing up is done in the parse history in order to parse Y parallel to X, and B is parsed by merger with the state interrupted by the conjunction.", "labels": [], "entities": []}, {"text": "However, our system has the following interesting features: (1) The MSG interpreter manipulates stacks in such away that embedded coordination (and coordination of more than two elements) and interactions with extraposition are handled.", "labels": [], "entities": []}, {"text": "(Examples are given in the Appendix.)", "labels": [], "entities": [{"text": "Appendix", "start_pos": 27, "end_pos": 35, "type": "DATASET", "confidence": 0.5931270122528076}]}, {"text": "(2) The interpreter produces a modifier structure for the sentence A X conj Y B which remains close to the surface form, as opposed to the unreduced structure A X B conj A Y B (but it does show all the pertinent semantic relations through unification of variables).", "labels": [], "entities": []}, {"text": "Not expanding to the unreduced form is important for keeping the modifier relationships straight, in particular, getting the right quantifier scoping.", "labels": [], "entities": []}, {"text": "Our system analyzes the sentence Each man drove a car through and completely demolished a glass window, producing the logical form This logical form would be difficult to recover from the unreduced structure, because the quantified noun phrases are repeated in the unreduced structure, and the logical form that corresponds most naturally to the unreduced structure is not logically equivalent to the above logical form.", "labels": [], "entities": []}, {"text": "(3) In general, the use of modifier structures and the associated semantic interpretation component permits a good treatment of scoping problems involving coordination.", "labels": [], "entities": []}, {"text": "(4) The system seems reasonably efficient.", "labels": [], "entities": []}, {"text": "For example, the analysis of the example sentence under (2) above (including syntactic analysis and semantic interpretation) was done in 177 milliseconds.", "labels": [], "entities": [{"text": "semantic interpretation", "start_pos": 100, "end_pos": 123, "type": "TASK", "confidence": 0.7205587029457092}]}, {"text": "The reader can examine analysis times for other examples in the Appendix.", "labels": [], "entities": []}, {"text": "One reason for the efficiency is just that the system is formulated as a logic programming system, and especially that it uses Prolog-10, with its compiler.", "labels": [], "entities": [{"text": "Prolog-10", "start_pos": 127, "end_pos": 136, "type": "DATASET", "confidence": 0.9122275114059448}]}, {"text": "Another reason presumably lies in the details of the MSG interpreter.", "labels": [], "entities": [{"text": "MSG interpreter", "start_pos": 53, "end_pos": 68, "type": "DATASET", "confidence": 0.8493398427963257}]}, {"text": "For example, the interpreter does not save the complete history of the parse, so that the backing up necessary for coordination does not examine as much.", "labels": [], "entities": []}, {"text": "(5) The code for the system seems short, and most of it is listed in this paper.", "labels": [], "entities": []}, {"text": "The semantic interpretation component is described in Section 4, but not incomplete detail since it is taken in the main from.", "labels": [], "entities": [{"text": "semantic interpretation", "start_pos": 4, "end_pos": 27, "type": "TASK", "confidence": 0.7527188956737518}]}, {"text": "Emphasis is on the new aspects involving semantic interpretation of coordinate modifiers.", "labels": [], "entities": [{"text": "semantic interpretation of coordinate modifiers", "start_pos": 41, "end_pos": 88, "type": "TASK", "confidence": 0.8297328770160675}]}, {"text": "Semantic interpretation of a modifier structure tree is done in two stages.", "labels": [], "entities": []}, {"text": "The first stage, called reshaping, deals heuristically with the well-known scoping problem, which arises because of the discrepancies that can exist between (surface) syntactic relations and intended semantic relations.", "labels": [], "entities": []}, {"text": "Reshaping is a transformation of the syntactic MS tree into another MS tree with the (hopefully) correct modifier relations.", "labels": [], "entities": []}, {"text": "The second stage takes the reshaped tree and translates it into logical form.", "labels": [], "entities": []}, {"text": "The modifiers actually do their work of modification in this second stage, through their semantic items.", "labels": [], "entities": []}, {"text": "As an example of the effects of reshaping on coordinate structures involving quantifiers, the sentence Section 5 of the paper presents a short discussion of possible improvements for the system, and Section 6 consists of concluding remarks.", "labels": [], "entities": []}, {"text": "The Appendix to the paper contains a listing of most of the system, a sample MSG, and sample parses.", "labels": [], "entities": []}, {"text": "The reader may wish to examine the sample parses at this point.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": []}