{"title": [], "abstractContent": [{"text": "This paper describes a classical logic for attribute-value (or feature description) languages which ate used in urfification grammar to describe a certain kind of linguistic object commonly called attribute-value structure (or feature structure).", "labels": [], "entities": [{"text": "urfification grammar", "start_pos": 112, "end_pos": 132, "type": "TASK", "confidence": 0.8025574088096619}]}, {"text": "Tile algorithm which is used for deciding satisfiability of a feature description is based on a restricted deductive closure construction for sets of literals (atomic formulas and negated atomic formulas).", "labels": [], "entities": []}, {"text": "In contrast to the Kasper/Rounds approach (cf. [Kasper/Rounds 90]), we can handle cyclicity, without the need for the introduction of complexity norms, as in [Johnson 88J and [Beierle/Pletat 88].", "labels": [], "entities": []}, {"text": "The deductive closure construction is the direct proof-theoretic correlate of the congruence closure algorithm (cf. [Nelson/Oppen 80]), if it were used in attribute-value languages for testing satisfiability of finite sets of literals.", "labels": [], "entities": [{"text": "deductive closure construction", "start_pos": 4, "end_pos": 34, "type": "TASK", "confidence": 0.7106985847155253}]}], "introductionContent": [{"text": "This paper describes a classical logic for attribute-value (or feature description) languages which are used in unification grammar to describe a certain kind of linguistic object commonly called attribute-value structure (or fcz~ture structure).", "labels": [], "entities": [{"text": "unification grammar", "start_pos": 112, "end_pos": 131, "type": "TASK", "confidence": 0.9410316050052643}]}, {"text": "I Note that the terms arc h)rnlcd without using brackets.", "labels": [], "entities": []}, {"text": "(Since all function symbols are unary, the introduction of brackets would So, in the following attribute-value languages are regarded & quantifier-free sublanguages of classical first order language~ with equality whose (nonlogical) symbols are given by a set o\" unary partial function symbols (attributes) and a set of constants.", "labels": [], "entities": []}, {"text": "The logical vocabulary includes all propositional connectives; negation is interpreted (:lassically.", "labels": [], "entities": []}, {"text": "2 For quantifier-free attribute-value languages L we give an axiomatic or IIilbert type system ll\u00b0v which simply results from an ordinary first order system (with partial function symbols), if its language were restricted to the vocabulary of L.", "labels": [], "entities": []}, {"text": "According to requirements of tile applications, axioms for the constantconsistency, constant/complex-consistency and acyclicity can be added to force these properties for the feature structures (models).", "labels": [], "entities": []}, {"text": "For deciding consistency (or satisfiability) of a feature description, we assume .first, that the conjunction of the formulas ill,the feature dc'scription is converted to disjunctive normal form.", "labels": [], "entities": [{"text": "consistency", "start_pos": 13, "end_pos": 24, "type": "METRIC", "confidence": 0.9072667360305786}]}, {"text": "Since a formula in disjunctive normal form is consis.", "labels": [], "entities": []}, {"text": "tent, ill\" at least one of its disjuncts is consistent, we only need all algorithm for.deciding consistency of finite sets of literals (atomic formulas or negated atomic formulas) S.", "labels": [], "entities": []}, {"text": "In contrast to the reduction algorithms which normalize a set S accord.", "labels": [], "entities": []}, {"text": "ing to a complexity norm in a sequence of norm decreasing rewrite steps 3 wc use a restricted deductive closure algorithm for deciding the consistency of sets of literMs.", "labels": [], "entities": []}, {"text": "4 The restriction results from the fact that it is sufficient for deciding the consistency of S to consider proofs of equations from ,.q with a certain subterm property.", "labels": [], "entities": [{"text": "consistency", "start_pos": 79, "end_pos": 90, "type": "METRIC", "confidence": 0.9891288876533508}]}, {"text": "For tile closure construction only those equations are derived from S whose terms are subterms of the terms occurring in the formulas of S.", "labels": [], "entities": [{"text": "tile closure construction", "start_pos": 4, "end_pos": 29, "type": "TASK", "confidence": 0.8756194114685059}]}, {"text": "This guarantees that the construction terminates with a finite set of literals.", "labels": [], "entities": []}, {"text": "The adequacy of this subterm property restriction, which was already shown for the number theoretic calculus K in by, is a necessary condition for the development of more efficient Cut-free Gentzen type systems for attributenot improve tile readability essentially.)", "labels": [], "entities": []}, {"text": "Therefore we write e.g. PRED SUBJa instead of PRED(SUBJ(a) Moreover, this closure construction is the direct prooI.", "labels": [], "entities": []}, {"text": "theoretic correlate of the congruence closure algorithm (cf. [Nelaon/Oppen 80]), if it were used for testing satisffability of finite sets of literals in HOt,.", "labels": [], "entities": []}, {"text": "As it is shown there, the congruence closure algorithm can bc used to test consistency if the terms of the equations are represented as labeled graphs and the equations as a relation on the nodes of that graph.", "labels": [], "entities": [{"text": "congruence closure", "start_pos": 26, "end_pos": 44, "type": "TASK", "confidence": 0.7256676405668259}]}, {"text": "O~ the basis of the algorithm for deciding satlsfiability of finite sets o| formulas we then show the completeness and decidability of//~t,.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": []}