{"title": [{"text": "Non-Projective Dependency Parsing in Expected Linear Time", "labels": [], "entities": [{"text": "Non-Projective Dependency Parsing", "start_pos": 0, "end_pos": 33, "type": "TASK", "confidence": 0.45455695192019147}]}], "abstractContent": [{"text": "We present a novel transition system for dependency parsing, which constructs arcs only between adjacent words but can parse arbitrary non-projective trees by swapping the order of words in the input.", "labels": [], "entities": [{"text": "dependency parsing", "start_pos": 41, "end_pos": 59, "type": "TASK", "confidence": 0.8513916730880737}]}, {"text": "Adding the swapping operation changes the time complexity for deterministic parsing from linear to quadratic in the worst case, but empirical estimates based on treebank data show that the expected running time is in fact linear for the range of data attested in the corpora.", "labels": [], "entities": [{"text": "deterministic parsing", "start_pos": 62, "end_pos": 83, "type": "TASK", "confidence": 0.589994877576828}]}, {"text": "Evaluation on data from five languages shows state-of-the-art accuracy, with especially good results for the labeled exact match score.", "labels": [], "entities": [{"text": "accuracy", "start_pos": 62, "end_pos": 70, "type": "METRIC", "confidence": 0.9996402263641357}, {"text": "exact match score", "start_pos": 117, "end_pos": 134, "type": "METRIC", "confidence": 0.8151920239130656}]}], "introductionContent": [{"text": "Syntactic parsing using dependency structures has become a standard technique in natural language processing with many different parsing models, in particular data-driven models that can be trained on syntactically annotated corpora.", "labels": [], "entities": [{"text": "Syntactic parsing", "start_pos": 0, "end_pos": 17, "type": "TASK", "confidence": 0.931085616350174}]}, {"text": "A hallmark of many of these models is that they can be implemented very efficiently.", "labels": [], "entities": []}, {"text": "Thus, transition-based parsers normally run in linear or quadratic time, using greedy deterministic search or fixed-width beam search (;, and graph-based models support exact inference in at most cubic time, which is efficient enough to make global discriminative training practically feasible).", "labels": [], "entities": []}, {"text": "However, one problem that still has not found a satisfactory solution in data-driven dependency parsing is the treatment of discontinuous syntactic constructions, usually modeled by non-projective dependency trees, as illustrated in.", "labels": [], "entities": [{"text": "dependency parsing", "start_pos": 85, "end_pos": 103, "type": "TASK", "confidence": 0.764021635055542}]}, {"text": "Ina projective dependency tree, the yield of every subtree is a contiguous substring of the sentence.", "labels": [], "entities": []}, {"text": "This is not the case for the tree in, where the subtrees rooted at node 2 (hearing) and node 4 (scheduled) both have discontinuous yields.", "labels": [], "entities": []}, {"text": "Allowing non-projective trees generally makes parsing computationally harder.", "labels": [], "entities": [{"text": "parsing computationally", "start_pos": 46, "end_pos": 69, "type": "TASK", "confidence": 0.87425297498703}]}, {"text": "Exact inference for parsing models that allow non-projective trees is NP hard, except under very restricted independence assumptions.", "labels": [], "entities": [{"text": "parsing", "start_pos": 20, "end_pos": 27, "type": "TASK", "confidence": 0.9651700854301453}]}, {"text": "There is recent work on algorithms that can cope with important subsets of all nonprojective trees in polynomial time (), but the time complexity is at best O(n 6 ), which can be problematic in practical applications.", "labels": [], "entities": []}, {"text": "Even the best algorithms for deterministic parsing run in quadratic time, rather than linear, unless restricted to a subset of non-projective structures as in and.", "labels": [], "entities": [{"text": "deterministic parsing", "start_pos": 29, "end_pos": 50, "type": "TASK", "confidence": 0.5293949246406555}]}, {"text": "But allowing non-projective dependency trees also makes parsing empirically harder, because it requires that we model relations between nonadjacent structures over potentially unbounded distances, which often has a negative impact on parsing accuracy.", "labels": [], "entities": [{"text": "parsing", "start_pos": 56, "end_pos": 63, "type": "TASK", "confidence": 0.9798966646194458}, {"text": "parsing", "start_pos": 234, "end_pos": 241, "type": "TASK", "confidence": 0.9638931751251221}, {"text": "accuracy", "start_pos": 242, "end_pos": 250, "type": "METRIC", "confidence": 0.8379165530204773}]}, {"text": "On the other hand, it is hardly possible to ignore non-projective structures completely, given that 25% or more of the sentences in some languages cannot be given a linguistically adequate analysis without invoking non-projective structures;.", "labels": [], "entities": []}, {"text": "Current approaches to data-driven dependency parsing typically use one of two strategies to deal with non-projective trees (unless they ignore them completely).", "labels": [], "entities": [{"text": "dependency parsing", "start_pos": 34, "end_pos": 52, "type": "TASK", "confidence": 0.6901531964540482}]}, {"text": "Either they employ a non-standard parsing algorithm that can combine non-adjacent substructures, or they try to recover non- ? \u00a7 \u00a4 P: Dependency tree for an English sentence (non-projective).", "labels": [], "entities": []}, {"text": "projective dependencies by post-processing the output of a strictly projective parser).", "labels": [], "entities": []}, {"text": "In this paper, we will adopt a different strategy, suggested in recent work by Nivre (2008b) and, and propose an algorithm that only combines adjacent substructures but derives non-projective trees by reordering the input words.", "labels": [], "entities": []}, {"text": "The rest of the paper is structured as follows.", "labels": [], "entities": []}, {"text": "In Section 2, we define the formal representations needed and introduce the framework of transitionbased dependency parsing.", "labels": [], "entities": [{"text": "transitionbased dependency parsing", "start_pos": 89, "end_pos": 123, "type": "TASK", "confidence": 0.6012742320696512}]}, {"text": "In Section 3, we first define a minimal transition system and explain how it can be used to perform projective dependency parsing in linear time; we then extend the system with a single transition for swapping the order of words in the input and demonstrate that the extended system can be used to parse unrestricted dependency trees with a time complexity that is quadratic in the worst case but still linear in the best case.", "labels": [], "entities": [{"text": "projective dependency parsing", "start_pos": 100, "end_pos": 129, "type": "TASK", "confidence": 0.67281041542689}, {"text": "parse unrestricted dependency trees", "start_pos": 298, "end_pos": 333, "type": "TASK", "confidence": 0.8362759053707123}]}, {"text": "In Section 4, we present experiments indicating that the expected running time of the new system on naturally occurring data is in fact linear and that the system achieves state-ofthe-art parsing accuracy.", "labels": [], "entities": [{"text": "accuracy", "start_pos": 196, "end_pos": 204, "type": "METRIC", "confidence": 0.9026776552200317}]}, {"text": "We discuss related work in Section 5 and conclude in Section 6.", "labels": [], "entities": []}], "datasetContent": [{"text": "Our experiments are based on five data sets from the CoNLL-X shared task: Arabic, Czech, Danish, Slovene, and Turkish ().", "labels": [], "entities": []}, {"text": "These languages have been selected because the data come from genuine dependency treebanks, whereas all the other data sets are based on some kind of conversion from another type of representation, which could potentially distort the distribution of different types of structures in the data.", "labels": [], "entities": []}], "tableCaptions": [{"text": " Table 1: Labeled accuracy; AS = attachment score (non-projective arcs in brackets); EM = exact match.", "labels": [], "entities": [{"text": "accuracy", "start_pos": 18, "end_pos": 26, "type": "METRIC", "confidence": 0.9664661288261414}, {"text": "AS", "start_pos": 28, "end_pos": 30, "type": "METRIC", "confidence": 0.9976193308830261}, {"text": "attachment score", "start_pos": 33, "end_pos": 49, "type": "METRIC", "confidence": 0.9651281237602234}, {"text": "EM", "start_pos": 85, "end_pos": 87, "type": "METRIC", "confidence": 0.9983431100845337}, {"text": "exact match", "start_pos": 90, "end_pos": 101, "type": "METRIC", "confidence": 0.9252412915229797}]}]}