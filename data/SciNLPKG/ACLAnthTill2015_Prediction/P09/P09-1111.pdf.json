{"title": [{"text": "An Optimal-Time Binarization Algorithm for Linear Context-Free Rewriting Systems with Fan-Out Two", "labels": [], "entities": []}], "abstractContent": [{"text": "Linear context-free rewriting systems (LCFRSs) are grammar formalisms with the capability of modeling discontinu-ous constituents.", "labels": [], "entities": []}, {"text": "Many applications use LCFRSs where the fan-out (a measure of the discontinuity of phrases) is not allowed to be greater than 2.", "labels": [], "entities": []}, {"text": "We present an efficient algorithm for transforming LCFRS with fan-out at most 2 into a binary form, whenever this is possible.", "labels": [], "entities": []}, {"text": "This results in asymptotical run-time improvement for known parsing algorithms for this class.", "labels": [], "entities": []}], "introductionContent": [{"text": "Since its early years, the computational linguistics field has devoted much effort to the development of formal systems for modeling the syntax of natural language.", "labels": [], "entities": [{"text": "computational linguistics", "start_pos": 27, "end_pos": 52, "type": "TASK", "confidence": 0.7499293982982635}]}, {"text": "There has been a considerable interest in rewriting systems that enlarge the generative power of context-free grammars, still remaining far below the power of the class of contextsensitive grammars; see () for discussion.", "labels": [], "entities": []}, {"text": "Following this line, have introduced a formalism called linear context-free rewriting systems (LCFRSs) that has received much attention in later years by the community.", "labels": [], "entities": []}, {"text": "LCFRSs allow the derivation of tuples of strings, 1 i.e., discontinuous phrases, that turnout to be very useful in modeling languages with relatively free word order.", "labels": [], "entities": []}, {"text": "This feature has recently been used for mapping non-projective dependency grammars into discontinuous phrase structures ( . Furthermore, LCFRSs also implement so-called synchronous rewriting, up to some bounded degree, and have recently been exploited, in some syntactic variant, in syntax-based machine translation as well as in the modeling of syntax-semantic interface).", "labels": [], "entities": [{"text": "machine translation", "start_pos": 296, "end_pos": 315, "type": "TASK", "confidence": 0.7120059281587601}]}, {"text": "The maximum number f of tuple components that can be generated by an LCFRS G is called the fan-out of G, and the maximum number r of nonterminals in the right-hand side of a production is called the rank of G.", "labels": [], "entities": []}, {"text": "As an example, contextfree grammars are LCFRSs with f = 1 and r given by the maximum length of a production right-hand side.", "labels": [], "entities": []}, {"text": "Tree adjoining grammars, or TAG for short, can be viewed as a special kind of LCFRS with f = 2, since each elementary tree generates two strings, and r given by the maximum number of adjunction sites in an elementary tree.", "labels": [], "entities": []}, {"text": "Several parsing algorithms for LCFRS or equivalent formalisms are found in the literature; see for instance).", "labels": [], "entities": []}, {"text": "All of these algorithms work in time O(|G| \u00b7 |w| f \u00b7(r+1) ).", "labels": [], "entities": []}, {"text": "Parsing time is then exponential in the input grammar size, since |G| depends on both f and r.", "labels": [], "entities": [{"text": "Parsing time", "start_pos": 0, "end_pos": 12, "type": "METRIC", "confidence": 0.8202254176139832}]}, {"text": "In the development of efficient algorithms for parsing based on LCFRS the crucial goal is therefore to optimize the term f \u00b7 (r + 1).", "labels": [], "entities": [{"text": "parsing", "start_pos": 47, "end_pos": 54, "type": "TASK", "confidence": 0.974332332611084}]}, {"text": "In practical natural language processing applications the fan-out of the grammar is typically bounded by some small number.", "labels": [], "entities": []}, {"text": "As an example, in the case of discontinuous parsing discussed above, we have f = 2 for most practical cases.", "labels": [], "entities": [{"text": "discontinuous parsing", "start_pos": 30, "end_pos": 51, "type": "TASK", "confidence": 0.5135544687509537}]}, {"text": "On the contrary, LCFRS productions with a relatively large number of nonterminals are usually observed in real data.", "labels": [], "entities": []}, {"text": "The reduction of the rank of a LCFRS, called binarization, is a process very similar to the reduction of a context-free grammar into Chomsky normal form.", "labels": [], "entities": []}, {"text": "While in the special case of CFG and TAG this can always be achieved, binarization of an LCFRS requires, in the general case, an increase in the fan-out of the grammar much larger than the achieved reduction in the rank.", "labels": [], "entities": [{"text": "CFG", "start_pos": 29, "end_pos": 32, "type": "DATASET", "confidence": 0.9376926422119141}]}, {"text": "Worst cases and some lower bounds have been discussed in (.", "labels": [], "entities": []}, {"text": "Nonetheless, in many cases of interest binarization of an LCFRS can be carried out without any extra increase in the fan-out.", "labels": [], "entities": [{"text": "LCFRS", "start_pos": 58, "end_pos": 63, "type": "DATASET", "confidence": 0.7404536008834839}]}, {"text": "As an example, in the case where f = 2, binarization of a LCFRS would result in parsing time of O(|G| \u00b7 |w| 6 ).", "labels": [], "entities": []}, {"text": "With the motivation of parsing efficiency, much research has been recently devoted to the design of efficient algorithms for rank reduction, in cases in which this can be carried out at no extra increase in the fan-out.", "labels": [], "entities": [{"text": "parsing", "start_pos": 23, "end_pos": 30, "type": "TASK", "confidence": 0.9904205799102783}, {"text": "rank reduction", "start_pos": 125, "end_pos": 139, "type": "TASK", "confidence": 0.7054106891155243}]}, {"text": "() reports a general binarization algorithm for LCFRS.", "labels": [], "entities": []}, {"text": "In the case where f = 2, this algorithm works in time O(|p| 7 ), where p is the input production.", "labels": [], "entities": []}, {"text": "A more efficient algorithm is presented in, working in time O(|p|) in case off = 2.", "labels": [], "entities": [{"text": "O", "start_pos": 60, "end_pos": 61, "type": "METRIC", "confidence": 0.9475509524345398}]}, {"text": "However, this algorithm works fora restricted typology of productions, and does not coverall cases in which some binarization is possible.", "labels": [], "entities": []}, {"text": "Other linear time algorithms for rank reduction are found in the literature (), but they are restricted to the case of synchronous context-free grammars, a strict subclass of the LCFRS with f = 2.", "labels": [], "entities": [{"text": "rank reduction", "start_pos": 33, "end_pos": 47, "type": "TASK", "confidence": 0.7211642861366272}]}, {"text": "In this paper we focus our attention on LCFRS with a fan-out of two.", "labels": [], "entities": [{"text": "LCFRS", "start_pos": 40, "end_pos": 45, "type": "DATASET", "confidence": 0.603726327419281}]}, {"text": "We improve upon all of the above mentioned results, by providing an algorithm that computes a binarization of an LCFRS production in all cases in which this is possible and works in time.", "labels": [], "entities": []}, {"text": "This is an optimal result in terms of time complexity, since \u0398(|p|) is also the size of any output binarization of an LCFRS production.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": []}