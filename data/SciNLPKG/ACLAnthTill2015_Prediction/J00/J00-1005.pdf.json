{"title": [{"text": "Treatment of Epsilon Moves in Subset Construction", "labels": [], "entities": [{"text": "Subset Construction", "start_pos": 30, "end_pos": 49, "type": "TASK", "confidence": 0.8108103275299072}]}], "abstractContent": [{"text": "The paper discusses the problem of determinizing finite-state automata containing large numbers of c-moves.", "labels": [], "entities": []}, {"text": "Experiments with finite-state approximations of natural language grammars often give rise to very large automata with a very large number of c-moves.", "labels": [], "entities": []}, {"text": "The paper identifies and compares a number of subset construction algorithms that treat c-moves.", "labels": [], "entities": []}, {"text": "Experiments have been performed which indicate that the algorithms differ considerably in practice, both with respect to the size of the resulting deterministic automaton, and with respect to practical efficiency.", "labels": [], "entities": []}, {"text": "Furthermore, the experiments suggest that the average number of ~-moves per state can be used to predict which algorithm is likely to be the fastest fora given input automaton.", "labels": [], "entities": []}], "introductionContent": [], "datasetContent": [{"text": "Two sets of experiments have been performed.", "labels": [], "entities": []}, {"text": "In the first set of experiments, random automata are generated according to a number of criteria based on.", "labels": [], "entities": []}, {"text": "In the second set of experiments, results are provided fora number of (much larger) automata that surfaced during actual development work on finite-state approximation techniques.", "labels": [], "entities": []}, {"text": "Here, we report on a number of experiments for randomly generated automata.", "labels": [], "entities": []}, {"text": "Following, the absolute transition density of an automaton is defined as the number of transitions divided by the square of the number of states multiplied by the number of symbols (i.e., the number of transitions divided by the maximum number of \"possible\" transitions, or, in other words, the probability that a possible transition in fact exists).", "labels": [], "entities": []}, {"text": "Deterministic transition density is the number of transitions divided by the number of states multiplied by the number of symbols (i.e., the ratio of the number of transitions and the maximum number of \"possible\" transitions in a deterministic machine).", "labels": [], "entities": []}, {"text": "In both of these definitions, the number of transitions should be understood as the number of nonduplicate transitions that do not lead to a sink state.", "labels": [], "entities": []}, {"text": "A sink state is a state from which there exists no sequence of transitions to a final state.", "labels": [], "entities": []}, {"text": "In the randomly generated automata, states are accessible and co-accessible by construction; sink states and associated transitions are not represented.", "labels": [], "entities": []}, {"text": "shows that deterministic transition density is a reliable measure for the difficulty of subset construction.", "labels": [], "entities": [{"text": "subset construction", "start_pos": 88, "end_pos": 107, "type": "TASK", "confidence": 0.7690612971782684}]}, {"text": "Exponential blow-up can be expected for input automata with deterministic transition density of around 2. 6 He concludes (page 66): randomly generated automata exhibit the maximum execution time, and the maximum number of states, at an approximate deterministic density of 2.", "labels": [], "entities": []}, {"text": "Most of the area under the curve occurs within 0.5 and 2.5 deterministic density--this is the area in which subset construction is expensive.", "labels": [], "entities": []}, {"text": "For a given NFA, we can compute the expected numbers of states and transitions in the corresponding DFA, produced by subset construction, from the deterministic density of the NFA.", "labels": [], "entities": []}, {"text": "In addition, this functional relationship gives rise to a Poisson-like curve with its peak approximately at a deterministic density of 2.", "labels": [], "entities": []}, {"text": "A number of automata were generated randomly, according to the number of states, symbols, and transitions.", "labels": [], "entities": []}, {"text": "For the first experiment, automata were generated consisting of 15 symbols, 25 states, and various densities (and no c-moves).", "labels": [], "entities": []}, {"text": "The results are summarized in.", "labels": [], "entities": []}, {"text": "CPU-time was measured on a HP 9000/785 machine running HP-UX 10.20.", "labels": [], "entities": []}, {"text": "Note that our timings do not include the start-up of the Prolog engine, nor the time required for garbage collection.", "labels": [], "entities": [{"text": "timings", "start_pos": 14, "end_pos": 21, "type": "METRIC", "confidence": 0.9738266468048096}, {"text": "Prolog engine", "start_pos": 57, "end_pos": 70, "type": "DATASET", "confidence": 0.9373742341995239}, {"text": "garbage collection", "start_pos": 98, "end_pos": 116, "type": "TASK", "confidence": 0.7107578963041306}]}, {"text": "In order to establish that the differences we obtain later are genuinely due to differences in the underlying algorithm, and not due to \"accidental\" implementation details, we have compared our implementation with the determinizer of AT&T's FSM utilities (Mohri, Pereira, and Riley 1998).", "labels": [], "entities": []}, {"text": "For automata without e-moves, we establish that FSM normally is faster: for automata with very small transition densities, FSM is up to four times as fast; for automata with larger densities, the results are similar.", "labels": [], "entities": [{"text": "FSM", "start_pos": 48, "end_pos": 51, "type": "METRIC", "confidence": 0.9028589725494385}, {"text": "FSM", "start_pos": 123, "end_pos": 126, "type": "METRIC", "confidence": 0.9957218170166016}]}, {"text": "A new concept called absolute jump density is introduced to specify the number of c-moves.", "labels": [], "entities": []}, {"text": "It is defined as the number of e-moves divided by the square of the number of states (i.e., the probability that an c-move exists fora given pair of states).", "labels": [], "entities": []}, {"text": "Furthermore, deterministic jump density is the number of e-moves divided by the number of states (i.e., the average number of e-moves that leave a given state).", "labels": [], "entities": []}, {"text": "In order to measure the differences between the three implementations, a number of automata have been generated consisting of 15 states and 15 symbols, using various transition densities between 0.01 and 0.3 (for larger densities, the automata tend to collapse to an automaton for ~.*).", "labels": [], "entities": []}, {"text": "For each of these transition densities, deterministic jump densities were chosen in the range 0 to 2.5 (again, for larger values, the automata tend to collapse).", "labels": [], "entities": []}, {"text": "In, the outcomes of these experiments are summarized by listing the average amount of CPU-time required per deterministic jump density (for each of the algorithms), using automata with 15, 20, 25, and 100 states, respectively.", "labels": [], "entities": []}, {"text": "Thus, every dot represents the average for determinizing a number of different input automata with various absolute transition densities and the same deterministic jump density.", "labels": [], "entities": []}, {"text": "The striking aspect of these experiments is that the integrated per subset and per state variants are much more efficient for larger deterministic jump densities.", "labels": [], "entities": []}, {"text": "The per graph t is typically the fastest algorithm of the nonintegrated versions.", "labels": [], "entities": []}, {"text": "However, in these experiments all states in the input are co-accessible by construction; and moreover, all states in the input are final states.", "labels": [], "entities": []}, {"text": "Therefore, the advantages of the pergraph t'c algorithm could not be observed here.", "labels": [], "entities": []}, {"text": "The turning point is a deterministic jump density of around 0.8: for smaller densities the per graph t is typically slightly faster; for larger densities the per state algorithm is much faster.", "labels": [], "entities": []}, {"text": "For densities beyond 1.5, the per subset algorithm tends to perform better than the per state algorithm.", "labels": [], "entities": []}, {"text": "Interestingly, this generalization is supported by the experiments on automata generated by approximation techniques (although the results for randomly generated automata are more consistent than the results for \"real\" examples).", "labels": [], "entities": []}, {"text": "Average amount of CPU-time versus deterministic jump density for each of the algorithms, and FSM.", "labels": [], "entities": [{"text": "FSM", "start_pos": 93, "end_pos": 96, "type": "METRIC", "confidence": 0.9958847165107727}]}, {"text": "Input automata have 100 states.", "labels": [], "entities": []}, {"text": "Absolute transition densities: 0.001-0.0035.", "labels": [], "entities": [{"text": "Absolute", "start_pos": 0, "end_pos": 8, "type": "METRIC", "confidence": 0.9847050905227661}]}, {"text": "Comparison with the FSM Library.", "labels": [], "entities": [{"text": "FSM Library", "start_pos": 20, "end_pos": 31, "type": "DATASET", "confidence": 0.9866589903831482}]}, {"text": "We also provide the results for AT&T's FSM library.", "labels": [], "entities": [{"text": "AT&T's FSM library", "start_pos": 32, "end_pos": 50, "type": "DATASET", "confidence": 0.8605983853340149}]}, {"text": "FSM is designed to treat weighted automata for very general weight sets.", "labels": [], "entities": [{"text": "FSM", "start_pos": 0, "end_pos": 3, "type": "TASK", "confidence": 0.46298855543136597}]}, {"text": "The initial implementation of the library consisted of an on-the-fly computation of the epsilon closures combined with determinization.", "labels": [], "entities": []}, {"text": "This was abandoned for two reasons: it could not be generalized to the case of general weight sets, and it was not outputting the intermediate epsilon-removed machine (which might be of interest in itself).", "labels": [], "entities": []}, {"text": "In the current version, c-moves must be removed before determinization is possible.", "labels": [], "entities": []}, {"text": "This mechanism thus is comparable to our per graph variant.", "labels": [], "entities": []}, {"text": "Apparently, FSM employs an algorithm equivalent to our per graph s,a.", "labels": [], "entities": [{"text": "FSM", "start_pos": 12, "end_pos": 15, "type": "TASK", "confidence": 0.7670697569847107}]}, {"text": "The resulting determinized machines are generally larger than the machines produced by our integrated variants and the variants that incorporate c-moves on the target side of transitions.", "labels": [], "entities": []}, {"text": "The timings below are obtained for the pipe fsmrmepsilon I fsmdeterminize This is somewhat unfair, since this includes the time to write and read the intermediate machine.", "labels": [], "entities": [{"text": "timings", "start_pos": 4, "end_pos": 11, "type": "METRIC", "confidence": 0.9760346412658691}]}, {"text": "Even so, it is interesting to note that the FSM library is a constant factor faster than our per graphS,a; for larger numbers of jumps the per state and per subset variants consistently beat the FSM library.", "labels": [], "entities": [{"text": "FSM", "start_pos": 44, "end_pos": 47, "type": "DATASET", "confidence": 0.6920737028121948}, {"text": "FSM library", "start_pos": 195, "end_pos": 206, "type": "DATASET", "confidence": 0.8907423317432404}]}, {"text": "Experiment: Automata Generated by Approximation Algorithms.", "labels": [], "entities": []}, {"text": "The automata used in the previous experiments were randomly generated.", "labels": [], "entities": []}, {"text": "However, it may well be that in practice the automata that are to be treated by the algorithm have typical properties not reflected in this test data.", "labels": [], "entities": []}, {"text": "For this reason, results are presented fora number of automata that were generated using approximation techniques for context-free grammars; in particular, for automata created by Nederhof, using the technique described in, and a small number of automata created using the technique of Pereira and Wright (1997) (as implemented by Nederhof).", "labels": [], "entities": []}, {"text": "We have restricted our attention to automata with at least 1,000 states in the input.", "labels": [], "entities": []}, {"text": "The automata typically contain lots of jumps.", "labels": [], "entities": []}, {"text": "Moreover, the number of states of the resulting automaton is often smaller than the number of states in the input automaton.", "labels": [], "entities": []}, {"text": "One of the most striking examples is the ygrim automaton consisting of 3,382 states and 9,124 jumps.", "labels": [], "entities": []}, {"text": "For this example, the per graph implementations ran out of memory (after along time), whereas the implementation of the per subset algorithm produced the determinized automaton (containing only 9 states) within a single CPU-second.", "labels": [], "entities": []}, {"text": "The FSM implementation took much longer for this example (whereas for many of the other examples it is faster than our implementations).", "labels": [], "entities": [{"text": "FSM", "start_pos": 4, "end_pos": 7, "type": "DATASET", "confidence": 0.5236930847167969}]}, {"text": "Note that this example has the highest ratio of number of jumps to number of states.", "labels": [], "entities": []}, {"text": "This confirms the observation that the per subset algorithm performs better on inputs with a high deterministic jump density.", "labels": [], "entities": []}], "tableCaptions": []}