{"title": [], "abstractContent": [{"text": "GF is a grammar formalism that has a powerful type system and module system, permitting a high level of abstraction and division of labour in grammar writing.", "labels": [], "entities": [{"text": "GF", "start_pos": 0, "end_pos": 2, "type": "DATASET", "confidence": 0.7898093461990356}]}, {"text": "GF is suited both for expert linguists, who appreciate its capacity of generalizations and conciseness, and for beginners, who benefit from its static type checker and, in particular, the GF Resource Grammar Library, which currently covers 12 languages.", "labels": [], "entities": [{"text": "GF", "start_pos": 0, "end_pos": 2, "type": "DATASET", "confidence": 0.9008734226226807}, {"text": "GF Resource Grammar Library", "start_pos": 188, "end_pos": 215, "type": "DATASET", "confidence": 0.8253646790981293}]}, {"text": "GF has a notion of multilingual grammars, enabling code sharing, linguistic generalizations, rapid development of translation systems, and painless porting of applications to new languages.", "labels": [], "entities": [{"text": "GF", "start_pos": 0, "end_pos": 2, "type": "DATASET", "confidence": 0.7951861619949341}, {"text": "linguistic generalizations", "start_pos": 65, "end_pos": 91, "type": "TASK", "confidence": 0.7225850820541382}]}], "introductionContent": [{"text": "Grammar implementation for natural languages is a challenge for both linguistics and engineering.", "labels": [], "entities": [{"text": "Grammar implementation", "start_pos": 0, "end_pos": 22, "type": "TASK", "confidence": 0.7543152868747711}]}, {"text": "The linguistic challenge is to master the complexities of languages so that all details are taken into account and work seamlessly together; if possible, the description should be concise and elegant, and capture the linguist's generalizations on the level of code.", "labels": [], "entities": []}, {"text": "The engineering challenge is to make the grammar scalable, reusable, and maintainable.", "labels": [], "entities": []}, {"text": "Too many grammars implemented in the history of computational linguistics have become obsolete, not only because of their poor maintainability, but also because of the decay of entire software and hardware platforms.", "labels": [], "entities": []}, {"text": "The first measure to betaken against the \"bit rot\" of grammars is to write them in well-defined formats that can be implemented independently of platform.", "labels": [], "entities": []}, {"text": "This requirement is more or less an axiom in programming language development: a * Now at Google Inc.", "labels": [], "entities": []}, {"text": "language must have syntax and semantics specifications that are independent of its first implementation; otherwise the first implementation risks to remain the only one.", "labels": [], "entities": []}, {"text": "Secondly, since grammar engineering is to a large extent software engineering, grammar formalisms should learn from programming language techniques that have been found useful in this respect.", "labels": [], "entities": [{"text": "grammar engineering", "start_pos": 16, "end_pos": 35, "type": "TASK", "confidence": 0.8442416489124298}]}, {"text": "Two such techniques are static type systems and module systems.", "labels": [], "entities": []}, {"text": "Since grammar formalism implementations are mostly descendants of Lisp and Prolog, they usually lack a static type system that finds errors at compile time.", "labels": [], "entities": []}, {"text": "Ina complex task like grammar writing, compile-time error detection is preferable to run-time debugging whenever possible.", "labels": [], "entities": [{"text": "grammar writing", "start_pos": 22, "end_pos": 37, "type": "TASK", "confidence": 0.8320182859897614}, {"text": "compile-time error detection", "start_pos": 39, "end_pos": 67, "type": "TASK", "confidence": 0.6165576080481211}]}, {"text": "As for modularity, traditional grammar formalisms again inherit from Lisp and Prolog low-level mechanisms like macros and file includes, which in modern languages like Java and ML have been replaced by advanced module systems akin in rigour to type systems.", "labels": [], "entities": []}, {"text": "Thirdly, as another lesson from software engineering, grammar writing should permit an increasing use of libraries, so that programmers can build on ealier code.", "labels": [], "entities": [{"text": "grammar writing", "start_pos": 54, "end_pos": 69, "type": "TASK", "confidence": 0.8311857879161835}]}, {"text": "Types and modules are essential for the management of libraries.", "labels": [], "entities": []}, {"text": "When anew language is developed, an effort is needed in creating libraries for the language, so that programmers can scale up to real-size tasks.", "labels": [], "entities": []}, {"text": "Fourthly, a grammar formalism should have a stable and efficient implementation that works on different platforms (hardware and operating systems).", "labels": [], "entities": []}, {"text": "Since grammars are often parts of larger language-processing systems (such as translation tools or dialogue systems), their interoperability with other components is an important issue.", "labels": [], "entities": []}, {"text": "The implementation should provide compilers to standard formats, such as databases and speech recognition language models.", "labels": [], "entities": []}, {"text": "In addition to interoperability, such compilers also help keeping the grammars alive even if the original grammar formalism ceases to exist.", "labels": [], "entities": []}, {"text": "Fifthly, grammar formalisms should have rich documentation; in particular, they should have accessible tutorials that do not demand the readers to be experts in a linguistic theory or in computer programming.", "labels": [], "entities": []}, {"text": "Also the libraries should be documented, preferably by automatically generated documentation in the style of JavaDoc, which is guaranteed to stay up to date.", "labels": [], "entities": []}, {"text": "Last but not least, a grammar formalism, as well its documentation, implementation, and standard libraries, should be freely available open-source software that anyone can use, inspect, modify, and improve.", "labels": [], "entities": []}, {"text": "In the domain of general-purpose programming, this is yet another growing trend; proprietary languages are being made open-source or at least free of charge.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": []}