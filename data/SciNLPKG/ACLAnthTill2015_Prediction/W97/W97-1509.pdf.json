{"title": [{"text": "Head-Driven Generation and Indexing in ALE", "labels": [], "entities": [{"text": "Head-Driven Generation", "start_pos": 0, "end_pos": 22, "type": "TASK", "confidence": 0.6619654595851898}, {"text": "ALE", "start_pos": 39, "end_pos": 42, "type": "TASK", "confidence": 0.40566936135292053}]}], "abstractContent": [{"text": "We present a method for compiling grammars into efficient code for head-driven generation in ALE.", "labels": [], "entities": [{"text": "head-driven generation", "start_pos": 67, "end_pos": 89, "type": "TASK", "confidence": 0.6819827854633331}]}, {"text": "Like other compilation techniques already used in ALE, this method integrates ALE's compiled code for logical operations with control-specific information from (SNMP90)'s algorithm along with user-defined directives to identify semantics-related substructures.", "labels": [], "entities": []}, {"text": "This combination provides far better performance than typical bi-directional feature-based parser/generators, while requiring a minimum of adjustment to the grammar signature itself, and a minimum of extra compilation.", "labels": [], "entities": []}, {"text": "1 Motivation Large-scale development systems for typed feature~ based grammars have typically oriented themselves towards parsing, either ignoring generation entirely (the usual case), or assuming that generation can be achieved for free by using a bi-directional control strategy with a semantically, rather than phono-logically, instantiated query.", "labels": [], "entities": []}, {"text": "In the latter case, the result has inevitably been a system which is unacceptably slow in both directions.", "labels": [], "entities": []}, {"text": "At the same time, several lower-level logical operations over typed feature structures, such as inferring a type from the existence of an appropriate feature, or the unification of two feature structures, are indeed common to both parsing and generation; and generators outside this logical domain, of course, can make no use of them.", "labels": [], "entities": [{"text": "parsing and generation", "start_pos": 231, "end_pos": 253, "type": "TASK", "confidence": 0.721768299738566}]}, {"text": "What is required is a system which provides a common pool of these operations optimized for this particular logic, while also providing modes of processing which are suited to the task at hand, namely parsing or generation.", "labels": [], "entities": [{"text": "parsing or generation", "start_pos": 201, "end_pos": 222, "type": "TASK", "confidence": 0.7425496280193329}]}, {"text": "This is exactly how the situation has developed in other areas of logic programming.", "labels": [], "entities": []}, {"text": "The Warren Abstract Machine and its various enhancements are now the de facto standard for Prolog compilation, for example; and with that standard come techniques for call stack management, heap data structures etc.; but this does not mean that all Prolog programs are created equal-the more sophisticated compilers use mode declarations in order to optimize particular programs to being called with certain argument instantiations.", "labels": [], "entities": [{"text": "Prolog compilation", "start_pos": 91, "end_pos": 109, "type": "TASK", "confidence": 0.7505506873130798}, {"text": "call stack management", "start_pos": 167, "end_pos": 188, "type": "TASK", "confidence": 0.6713579893112183}]}, {"text": "The Attribute Logic Engine (ALE,(CP94)) is a logic programming language based on typed feature structures, which can compile common logical operations like type inferencing and unification into efficient lower-level code.", "labels": [], "entities": []}, {"text": "ALE also compiles grammars themselves into lower-level instructions, rather than simply running an interpreter over them, which yields a substantial increase in efficiency.", "labels": [], "entities": [{"text": "ALE", "start_pos": 0, "end_pos": 3, "type": "DATASET", "confidence": 0.7406381964683533}]}, {"text": "For ALE, the question of efficient generation is then how to compile grammars for use in semantically-instantiated queries.", "labels": [], "entities": []}, {"text": "To date, however, ALE has fallen within the class of systems which have ignored generation entirely.", "labels": [], "entities": [{"text": "ALE", "start_pos": 18, "end_pos": 21, "type": "TASK", "confidence": 0.8615490198135376}]}, {"text": "Its only control strategies have been a built-in bottom-up chart parser, and the usual SLD-resolution strategy for its Prolog-like language.", "labels": [], "entities": []}], "introductionContent": [], "datasetContent": [], "tableCaptions": []}