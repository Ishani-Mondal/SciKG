{"title": [{"text": "The ConTroll System as Large Grammar Development Platform", "labels": [], "entities": []}], "abstractContent": [{"text": "ConTroll is a grammar development system which supports the implementation of current constraint-based theories.", "labels": [], "entities": []}, {"text": "It uses strongly typed feature structures as its principal data structure and offers definite relations, universal constraints, and lexical rules to express grammar constraints.", "labels": [], "entities": []}, {"text": "The aspects of ConTroll of relevance to the development of large grammars are discussed in detail.", "labels": [], "entities": []}, {"text": "The system is fully implemented and has been used as workbench to develop and test a large HPSG grammar.", "labels": [], "entities": [{"text": "HPSG grammar", "start_pos": 91, "end_pos": 103, "type": "DATASET", "confidence": 0.8804941475391388}]}], "introductionContent": [{"text": "ConTroll 1 developed out of the Troll system.", "labels": [], "entities": []}, {"text": "Troll is a phrase structure backbone system very similar to ALE, but it differs from that system in that it is based on the set theoretic logic: of rather than the information theoretic one of.", "labels": [], "entities": []}, {"text": "The practical effect of this is that Troll implements an exhaustive typing strategy which provides the stronger kind of inferencing over descriptions ( required by standard HPSG theories.", "labels": [], "entities": []}, {"text": "We begin with a brief overview of the ConTroll architecture as shown in before focusing on the aspects relevant to large scale grammar development.", "labels": [], "entities": [{"text": "large scale grammar development", "start_pos": 115, "end_pos": 146, "type": "TASK", "confidence": 0.6395587995648384}]}, {"text": "ConTroll supports two basic kinds of grammar constraints: universal implicational constraints *The authors are listed alphabetically.", "labels": [], "entities": []}, {"text": "1ConTroll was developed in the B4 project of the SFB 340, funded by the Deutsche Forschungsgemeinschaft (DFG).", "labels": [], "entities": [{"text": "SFB 340", "start_pos": 49, "end_pos": 56, "type": "DATASET", "confidence": 0.9091745316982269}]}, {"text": "The following people contributed to the development of the system: Dale Gerdemann and Erhard Hinrichs (project leaders), Bj6rn Airing, Natali Alt, Carsten Hess, John Griffith, Stephan Kepser, Guido Minnen, Gerald Penn, Oliver Suhre and Andreas Zahnert. with complex antecedents, and definite relations.", "labels": [], "entities": []}, {"text": "As an example of the first kind of constraint, consider the Head Feature Principle of HPSG.", "labels": [], "entities": [{"text": "HPSG", "start_pos": 86, "end_pos": 90, "type": "DATASET", "confidence": 0.9218809008598328}]}, {"text": "This universal constraint can be directly encoded in ConTroll as follows: phrase, dtrs :headed_struc ==> synsem: loc: cat :head: X, head_dtr : synsem : loc : cat :head: X.", "labels": [], "entities": []}, {"text": "The ConTroll system allows a direct implementation of HPSG grammars without forcing the grammar writer to introduce a phrase structure backbone or recode the theories as logic programs.", "labels": [], "entities": []}, {"text": "In addition, the availability of universal constraints in ConTroll also allows fora more modular encoding of traditional grammars using a relational backbone.", "labels": [], "entities": []}, {"text": "This is so since in a relational encoding all subcases need to be covered.", "labels": [], "entities": []}, {"text": "The universal constraints with complex antecedents, on the other hand, generalize overall occurrences of some data structure and can attach the constraint to the relevant subset.", "labels": [], "entities": []}, {"text": "Universal constraints are thus constraint-based in the intuitive sense: each structure which is not explicitly excluded is well-formed.", "labels": [], "entities": []}, {"text": "Internally, the complex antecedents of such universal constraints and the occurrences of negation are eliminated, which is possible due to the exhaustive typing we assume.", "labels": [], "entities": []}, {"text": "The resulting type constraints are then compiled into definite clauses using the method described in (.", "labels": [], "entities": []}, {"text": "The second kind of grammar constraints are ordinary definite clauses with feature term arguments.", "labels": [], "entities": []}, {"text": "The compiler detects places in which constrained types can occur and integrates the type constraints into the code by adding calls to the relational encoding of the universal constraints.", "labels": [], "entities": []}, {"text": "As described in (, the universal constraints are integrated in a lazy fashion, i.e. only in case the argument of a relation is specific enough to cause a conflict with a universal constraint does the compiler attach a call to the universal constraint.", "labels": [], "entities": []}, {"text": "Such lazy interpretation has a significant efficiency payoff, especially for large grammars, since it results in preferred processing of those constraints in the large constraint pool which are specific enough to fail.", "labels": [], "entities": []}, {"text": "Special mechanisms are included to allow the grammar writer to specify how the universal constraints and definite clauses are intended to interleave in processing).", "labels": [], "entities": []}, {"text": "Most importantly, the delay mechanism of ConTroll supports coroutining of both universal constraints and definite clauses, and it offers a variety of control statements to fine tune the execution strategy.", "labels": [], "entities": []}, {"text": "This is a prerequisite to efficient processing with constraint grammars.", "labels": [], "entities": []}, {"text": "For the rest of the paper, we will focus on those aspects of ConTroll, which directly address large scale grammar development: \u2022 A graphical user interface: ConTroll is the only system combining all of these features in one architecture.", "labels": [], "entities": []}, {"text": "TFS) also offered type constraints and relations and to our knowledge was the first working typed feature systems.", "labels": [], "entities": [{"text": "TFS", "start_pos": 0, "end_pos": 3, "type": "DATASET", "confidence": 0.863739550113678}]}, {"text": "However, it had some serious drawbacks.", "labels": [], "entities": []}, {"text": "TFS did not allow universal constraints with complex antecedents, but only type constraints.", "labels": [], "entities": [{"text": "TFS", "start_pos": 0, "end_pos": 3, "type": "DATASET", "confidence": 0.9371927380561829}]}, {"text": "And the system did not include a delay mechanism, so that it was often impossible to ensure termination or efficient processing.", "labels": [], "entities": []}, {"text": "ALE provides relations and type constraints (i.e., only types as antecedents), but their unfolding is neither lazy, nor can it be controlled by the user in anyway.", "labels": [], "entities": []}, {"text": "This can lead to severe termination problems with recursive constraints.", "labels": [], "entities": []}, {"text": "However, the ALE type constraints were designed to enhance the typing system, and not for recursive computation.", "labels": [], "entities": []}, {"text": "The definite clause part of our system is very similar to the one of cvF: both use delay statements and preferred execution of deterministic goals.", "labels": [], "entities": []}, {"text": "CUF, however, does not offer universal constraints.", "labels": [], "entities": [{"text": "CUF", "start_pos": 0, "end_pos": 3, "type": "DATASET", "confidence": 0.9599930047988892}]}], "datasetContent": [], "tableCaptions": []}