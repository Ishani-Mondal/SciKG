{"title": [], "abstractContent": [{"text": "We present an SCFG binarization algorithm that combines the strengths of early terminal matching on the source language side and early language model integration on the target language side.", "labels": [], "entities": [{"text": "SCFG binarization", "start_pos": 14, "end_pos": 31, "type": "TASK", "confidence": 0.7995583415031433}]}, {"text": "We also examine how different strategies of target-side terminal attachment during binarization can significantly affect translation quality.", "labels": [], "entities": []}], "introductionContent": [{"text": "Synchronous context-free grammars (SCFG) are behind most syntax-based machine translation models.", "labels": [], "entities": [{"text": "machine translation", "start_pos": 70, "end_pos": 89, "type": "TASK", "confidence": 0.696915477514267}]}, {"text": "Efficient machine translation decoding with an SCFG requires converting the grammar into a binarized form, either explicitly, as in synchronous binarization (), where virtual nonterminals are generated for binarization, or implicitly, as in Earley parsing, where dotted items are used.", "labels": [], "entities": [{"text": "machine translation decoding", "start_pos": 10, "end_pos": 38, "type": "TASK", "confidence": 0.750688374042511}]}, {"text": "Given a source-side binarized SCFG with terminal set T and nonterminal set N , the time complexity of decoding a sentence of length n with a m-gram language model is (): where K is the maximum number of right-hand-side nonterminals.", "labels": [], "entities": []}, {"text": "SCFG binarization serves two important goals: \u2022 Parsing complexity for unbinarized SCFG grows exponentially with the number of nonterminals on the right-hand side of grammar rules.", "labels": [], "entities": []}, {"text": "Binarization ensures cubic time decoding in terms of input sentence length.", "labels": [], "entities": []}, {"text": "\u2022 In machine translation, integrating language model states as early as possible is essential to reducing search errors.", "labels": [], "entities": [{"text": "machine translation", "start_pos": 5, "end_pos": 24, "type": "TASK", "confidence": 0.771467387676239}]}, {"text": "Synchronous binarization () enables the decoder to incorporate language model scores as soon as a binarized rule is applied.", "labels": [], "entities": []}, {"text": "In this paper, we examine a CYK-like synchronous binarization algorithm that integrates a novel criterion in a unified semiring parsing framework.", "labels": [], "entities": []}, {"text": "The criterion we present has explicit consideration of source-side terminals.", "labels": [], "entities": []}, {"text": "In general, terminals in a rule have a lower probability of being matched given a sentence, and therefore have the effect of \"anchoring\" a rule and limiting its possible application points.", "labels": [], "entities": []}, {"text": "formalized this concept as the scope of a rule.", "labels": [], "entities": []}, {"text": "A rule of scope of k can be parsed in O(n k ).", "labels": [], "entities": [{"text": "O", "start_pos": 38, "end_pos": 39, "type": "METRIC", "confidence": 0.962919294834137}]}, {"text": "The scope of a rule can be calculated by counting the number of adjacent nonterminal pairs and boundary nonterminals.", "labels": [], "entities": []}, {"text": "For example, has scope two.", "labels": [], "entities": []}, {"text": "Building on the concept of scope, we define a cost function that estimates the expected number of hyperedges to be built when a particular binarization tree is applied to unseen data.", "labels": [], "entities": []}, {"text": "This effectively puts hard-to-match derivations at the bottom of the binarization tree, which enables the decoder to decide early on whether an unbinarized rule can be built or not.", "labels": [], "entities": []}, {"text": "We also investigate a better way to handle targetside terminals during binarization.", "labels": [], "entities": []}, {"text": "In theory, different strategies should produce equivalent translation results.", "labels": [], "entities": []}, {"text": "However, because decoding always involves Other works investigating alternative binarization methods mostly focus on the effect of nonterminal sharing.", "labels": [], "entities": []}, {"text": "also proposed a CYKlike algorithm for synchronous binarization.", "labels": [], "entities": []}, {"text": "Apparently the lack of virtual nonterminal sharing in their decoder caused heavy competition between virtual nonterminals, and they created a cost function to \"diversify\" binarization trees, which is equivalent to minimizing nonterminal sharing.", "labels": [], "entities": []}, {"text": "used a greedy method to maximize virtual nonterminal sharing on the source side during the -LM parsing phase.", "labels": [], "entities": [{"text": "LM parsing phase", "start_pos": 92, "end_pos": 108, "type": "TASK", "confidence": 0.5986760358015696}]}, {"text": "They show that effective source-side binarization can improve the efficiency of parsing SCFG.", "labels": [], "entities": [{"text": "parsing SCFG", "start_pos": 80, "end_pos": 92, "type": "TASK", "confidence": 0.8304131627082825}]}, {"text": "However, their method works only on the source side, and synchronous binarization is put off to the +LM decoding phase.", "labels": [], "entities": []}, {"text": "Although these ideas all lead to faster decoding and reduced search errors, there can be conflicts in the constraints each of them has on the form of rules and accommodating all of them can be a challenge.", "labels": [], "entities": []}, {"text": "In this paper, we present a cubic time algorithm to find the best binarization tree, given the conflicting constraints.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": []}