{"title": [{"text": "Metagrammar Engineering: Towards systematic exploration of implemented grammars", "labels": [], "entities": [{"text": "Metagrammar Engineering", "start_pos": 0, "end_pos": 23, "type": "TASK", "confidence": 0.844199925661087}]}], "abstractContent": [{"text": "When designing grammars of natural language , typically, more than one formal analysis can account fora given phenomenon.", "labels": [], "entities": []}, {"text": "Moreover, because analyses interact, the choices made by the engineer influence the possibilities available in further grammar development.", "labels": [], "entities": []}, {"text": "The order in which phenomena are treated may therefore have a major impact on the resulting grammar.", "labels": [], "entities": []}, {"text": "This paper proposes to tackle this problem by using metagrammar development as a methodology for grammar engineering.", "labels": [], "entities": [{"text": "grammar engineering", "start_pos": 97, "end_pos": 116, "type": "TASK", "confidence": 0.9158107042312622}]}, {"text": "I argue that metagrammar engineering as an approach facilitates the systematic exploration of grammars through comparison of competing analyses.", "labels": [], "entities": [{"text": "metagrammar engineering", "start_pos": 13, "end_pos": 36, "type": "TASK", "confidence": 0.8715968728065491}]}, {"text": "The idea is illustrated through a comparative study of auxiliary structures in HPSG-based grammars for German and Dutch.", "labels": [], "entities": []}, {"text": "Auxiliaries form a central phenomenon of German and Dutch and are likely to influence many components of the grammar.", "labels": [], "entities": []}, {"text": "This study shows that a special auxiliary+verb construction significantly improves efficiency compared to the standard argument-composition analysis for both parsing and generation.", "labels": [], "entities": [{"text": "parsing and generation", "start_pos": 158, "end_pos": 180, "type": "TASK", "confidence": 0.759418805440267}]}], "introductionContent": [{"text": "One of the challenges in designing grammars of natural language is that, typically, more than one formal analysis can account fora given phenomenon.", "labels": [], "entities": []}, {"text": "The criteria for choosing between competing analyses are fairly clear (observational adequacy, analytical clarity, efficiency), but given that analyses of different phenomena interact, actually evaluating analyses on those criteria in a systematic manner is far from straightforward.", "labels": [], "entities": [{"text": "clarity", "start_pos": 106, "end_pos": 113, "type": "METRIC", "confidence": 0.7782281041145325}]}, {"text": "The standard methodology involves either picking one analysis, and seeing how it goes, then backing out if it does notwork out, or laboriously adapting a grammar to two versions supporting different analyses . The former approach is not in anyway systematic, increasing the risk that the grammar is far from optimal in terms of efficiency.", "labels": [], "entities": []}, {"text": "The latter approach potentially causes the grammar engineer an amount of work that will not scale for considering many different phenomena.", "labels": [], "entities": []}, {"text": "This paper proposes a more systematic and tractable alternative to grammar development: metagrammar engineering.", "labels": [], "entities": [{"text": "grammar development", "start_pos": 67, "end_pos": 86, "type": "TASK", "confidence": 0.7914622128009796}]}, {"text": "I use \"metagrammar\" as a generic term to refer to a system that can generate implemented grammars.", "labels": [], "entities": []}, {"text": "The key idea is that the grammar engineer adds alternative plausable analyses for linguistic phenomena to a metagrammar.", "labels": [], "entities": []}, {"text": "This metagrammar can generate all possible combinations of these analyses automatically, creating different versions of a grammar that cover the same phenomena.", "labels": [], "entities": []}, {"text": "The engineer can test directly how competing analyses for different phenomena interact, and determine which combinations are possible (after minor adaptations) and which analyses are incompatible.", "labels": [], "entities": []}, {"text": "The idea of metagrammar engineering is illustrated here through a case study of word order and auxiliaries in Germanic languages, which forms the second goal of this paper.", "labels": [], "entities": [{"text": "metagrammar engineering", "start_pos": 12, "end_pos": 35, "type": "TASK", "confidence": 0.8244077563285828}, {"text": "word order and auxiliaries in Germanic languages", "start_pos": 80, "end_pos": 128, "type": "TASK", "confidence": 0.7872072969164167}]}, {"text": "Auxiliaries form a central phenomenon of German and Dutch and are likely to influence many components of the grammar.", "labels": [], "entities": []}, {"text": "The results show that the analysis of auxiliary+verb structures presented in  significantly im-1066 proves efficiency of the grammar compared to the standard argument-composition analysis within the range of phenomena studied.", "labels": [], "entities": []}, {"text": "Because future research is needed to determine whether the auxiliary+verb alternative can interact properly with additional phenomena and still lead to more efficient results than argument-composition, it is particularly useful to have a grammar generator that can automatically create grammars with either of the two analyses.", "labels": [], "entities": []}, {"text": "The remainder of this paper starts with the case study.", "labels": [], "entities": []}, {"text": "Section 2 provides a description of the context of the study.", "labels": [], "entities": []}, {"text": "The relevant linguistic properties and alternative analyses are described in Sections 3 and 4.", "labels": [], "entities": []}, {"text": "After evaluating and discussing the case study's results, I return to the general approach of metagrammar engineering.", "labels": [], "entities": [{"text": "metagrammar engineering", "start_pos": 94, "end_pos": 117, "type": "TASK", "confidence": 0.8886638581752777}]}, {"text": "Section 6 presents related work on metagrammars.", "labels": [], "entities": []}, {"text": "It is followed by a conclusion and discussion on using metagrammars as a methodology for grammar engineering.", "labels": [], "entities": [{"text": "grammar engineering", "start_pos": 89, "end_pos": 108, "type": "TASK", "confidence": 0.8418435156345367}]}], "datasetContent": [{"text": "As described above, the Germanic metagrammar is a branch of the customization system.", "labels": [], "entities": []}, {"text": "As such, it takes a choices file as input to create a grammar.  face.", "labels": [], "entities": []}, {"text": "The choices files defined artificial grammars with a dummy vocabulary.", "labels": [], "entities": []}, {"text": "The system can produce real fragments of the languages, but strings representing syntactic properties through dummy vocabulary were used to give better control over ambiguity facilitating the evaluation of coverage and overgeneration of the grammars.", "labels": [], "entities": []}, {"text": "The grammars have a lexicon of 9-10 unambiguous dummy words.", "labels": [], "entities": []}, {"text": "The created choices files were extended offline to define those properties that the Germanic metagrammar captures, but are not incorporated in the Matrix customization system.", "labels": [], "entities": []}, {"text": "This included word order of the auxiliary and complement, fixed or free argument order, influence of inflection on word order, a more elaborate case hierarchy, ditransitive verbs, and the choice of auxiliary/verb analysis.", "labels": [], "entities": []}, {"text": "Four choices files with different combinations of analyses were created for each language, resulting in 12 choices files in total.", "labels": [], "entities": []}, {"text": "A basic test suite was developed that covers intransitive, transitive and ditransitive main clauses with up to three auxiliaries.", "labels": [], "entities": []}, {"text": "The German set was based on a description provided by, Dutch and Flemish were based on Haeseryn (1997).", "labels": [], "entities": [{"text": "German set", "start_pos": 4, "end_pos": 14, "type": "DATASET", "confidence": 0.8075537979602814}]}, {"text": "For each verb and auxiliary combination, all permissible word orders were defined based on descriptive resources.", "labels": [], "entities": []}, {"text": "In order to make sure the grammars do not reveal unexpected forms of overgeneration, all possible ungrammatical orders were automatically generated.", "labels": [], "entities": []}, {"text": "provides the sizes of the test suites.", "labels": [], "entities": []}, {"text": "Each language has both a complete set for the 6 grammars that provide full coverage, and a reduced set for the 6 grammars that cannot handle split verbal clusters (see Section 4.3 for the motivation to test grammars that do not have full coverage).", "labels": [], "entities": []}, {"text": "Each grammar was created using the metagrammar, ensuring that all components except the competing analyses were held constant among compared grammars.", "labels": [], "entities": []}, {"text": "The [incr tsdb()] competence and performance profiling environment) was used in combination with the LKB to evaluate parsing performance of the individual grammars on the test suites.", "labels": [], "entities": [{"text": "LKB", "start_pos": 101, "end_pos": 104, "type": "DATASET", "confidence": 0.9644902944564819}]}, {"text": "For each grammar, the number of required parsing tasks, memory (space) and CPU time per sentence, as well as the number of passive edges created during an average parse were compared.", "labels": [], "entities": []}, {"text": "Performance on language generation was evaluated using the LKB.", "labels": [], "entities": [{"text": "language generation", "start_pos": 15, "end_pos": 34, "type": "TASK", "confidence": 0.744257777929306}, {"text": "LKB", "start_pos": 59, "end_pos": 62, "type": "DATASET", "confidence": 0.9713308215141296}]}, {"text": "presents the results from the parsing experiment.", "labels": [], "entities": [{"text": "parsing", "start_pos": 30, "end_pos": 37, "type": "TASK", "confidence": 0.9731858372688293}]}, {"text": "Note that all directly compared grammars have the same empirical coverage (100% coverage and 0% overgeneration on the phenomena included in the test suites).", "labels": [], "entities": [{"text": "coverage", "start_pos": 80, "end_pos": 88, "type": "METRIC", "confidence": 0.7257522940635681}]}, {"text": "The comparison therefore addresses the effect on efficiency of the alternative analyses.", "labels": [], "entities": []}, {"text": "Three tests per grammar were carried out: one on positive data, one on negative data and one on the complete dataset.", "labels": [], "entities": []}, {"text": "Results were similar for all three sets, with slightly larger differences in efficiency for negative examples.", "labels": [], "entities": []}, {"text": "For reasons of space, only the results on positive examples are presented, which are more relevant for most applications involving parsing.", "labels": [], "entities": [{"text": "parsing", "start_pos": 131, "end_pos": 138, "type": "TASK", "confidence": 0.9703421592712402}]}, {"text": "The results show that the auxiliary+verb (aux+v) leads to a more efficient grammar according to all measures used.", "labels": [], "entities": []}, {"text": "There is an average reduction of 73.2% in performed tasks, 56.3% in produced passive edges and 32.9% in memory when parsing grammatical examples using the auxiliary+verb structure compared to argument-composition.", "labels": [], "entities": []}, {"text": "CPU-time per sentence also improved significantly, but, due to the short average sentence length (5-10 words) the value is too small for exact comparison with [incr tsdb()].", "labels": [], "entities": []}, {"text": "The complete coverage versions of Dutch and German were used to create the exhaustive set of sentences with an intransitive, transitive and ditransitive verb combined with none, one or two auxiliaries but rapidly loses ground when one or more auxiliaries 8  from a total of 18 MRSs.", "labels": [], "entities": []}, {"text": "The input MRSs were obtained by parsing a sentence with canonical word order.", "labels": [], "entities": [{"text": "MRSs", "start_pos": 10, "end_pos": 14, "type": "TASK", "confidence": 0.9581270217895508}]}, {"text": "Both versions provide the same set of sentences as output, confirming their identical empirical coverage.", "labels": [], "entities": []}, {"text": "presents the number of edges required by the generator to produce the full set of generated sentences from a given MRS.", "labels": [], "entities": []}, {"text": "The cells with no number represent conditions under which the LKB generator reaches the maximum limit of edges, set at 40,000, without completing its exhaustive search.", "labels": [], "entities": []}], "tableCaptions": [{"text": " Table 3: Number of test examples (s) used in evaluation  and average words per sentence (w/s)", "labels": [], "entities": []}, {"text": " Table 4: Parsing results positive examples", "labels": [], "entities": [{"text": "Parsing", "start_pos": 10, "end_pos": 17, "type": "TASK", "confidence": 0.9484716653823853}]}, {"text": " Table 5: Performance on Sentence Generation", "labels": [], "entities": [{"text": "Sentence Generation", "start_pos": 25, "end_pos": 44, "type": "TASK", "confidence": 0.9033224284648895}]}]}