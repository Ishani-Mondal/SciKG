{"title": [{"text": "Optimal Head-Driven Parsing Complexity for Linear Context-Free Rewriting Systems", "labels": [], "entities": []}], "abstractContent": [{"text": "We study the problem of finding the best head-driven parsing strategy for Linear Context-Free Rewriting System productions.", "labels": [], "entities": []}, {"text": "A head-driven strategy must begin with a specified righthand-side nonterminal (the head) and add the remaining nonterminals one at a time in any order.", "labels": [], "entities": []}, {"text": "We show that it is NP-hard to find the best head-driven strategy in terms of either the time or space complexity of parsing.", "labels": [], "entities": []}], "introductionContent": [{"text": "Linear Context-Free Rewriting Systems (LCFRSs) constitute a very general grammatical formalism which subsumes contextfree grammars (CFGs) and tree adjoining grammars (TAGs), as well as the synchronous context-free grammars (SCFGs) and synchronous tree adjoining grammars (STAGs) used as models in machine translation.", "labels": [], "entities": [{"text": "machine translation", "start_pos": 297, "end_pos": 316, "type": "TASK", "confidence": 0.711045429110527}]}, {"text": "LCFRSs retain the fundamental property of CFGs that grammar nonterminals rewrite independently, but allow nonterminals to generate discontinuous phrases, that is, to generate more than one span in the string being produced.", "labels": [], "entities": []}, {"text": "This important feature has been recently exploited by and for modeling phrase structure treebanks with discontinuous constituents, and by  for modeling non-projective dependency treebanks.", "labels": [], "entities": []}, {"text": "The rules of a LCFRS can be analyzed in terms of the properties of rank and fan-out.", "labels": [], "entities": []}, {"text": "Rank is the number of nonterminals on the right-hand side (rhs) of a rule, while fan-out is the number of spans of the string generated by the nonterminal in the lefthand side (lhs) of the rule.", "labels": [], "entities": [{"text": "Rank", "start_pos": 0, "end_pos": 4, "type": "METRIC", "confidence": 0.9285032153129578}]}, {"text": "CFGs are equivalent to LCFRSs with fan-out one, while TAGs are one type of LCFRSs with fan-out two.", "labels": [], "entities": [{"text": "CFGs", "start_pos": 0, "end_pos": 4, "type": "DATASET", "confidence": 0.9000454545021057}]}, {"text": "show that rank and fan-out induce an infinite, two-dimensional hierarchy in terms of generative power; while CFGs can always be reduced to rank two (Chomsky Normal Form), this is not the case for LCFRSs with any fan-out greater than one.", "labels": [], "entities": []}, {"text": "General algorithms for parsing LCFRSs build a dynamic programming chart of recognized nonterminals bottom-up, in a manner analogous to the CKY algorithm for CFGs, but with time and space complexity that are dependent on the rank and fan-out of the grammar rules.", "labels": [], "entities": [{"text": "parsing LCFRSs", "start_pos": 23, "end_pos": 37, "type": "TASK", "confidence": 0.8225763738155365}]}, {"text": "Whenever it is possible, binarization of LCFRS rules, or reduction of rank to two, is therefore important for parsing, as it reduces the time complexity needed for dynamic programming.", "labels": [], "entities": [{"text": "parsing", "start_pos": 110, "end_pos": 117, "type": "TASK", "confidence": 0.987655758857727}]}, {"text": "This has lead to a number of binarization algorithms for LCFRSs, as well as factorization algorithms that factor rules into new rules with smaller rank, without necessarily reducing rank all the way to two.", "labels": [], "entities": []}, {"text": "present an algorithm for binarizing certain LCFRS rules without increasing their fan-out, and show how to reduce rank to the lowest value possible for LCFRS rules of fan-out two, again without increasing fan-out.", "labels": [], "entities": []}, {"text": "show how to factorize well-nested LCFRS rules of arbitrary fan-out for efficient parsing.", "labels": [], "entities": []}, {"text": "In general there maybe a trade-off required between rank and fan-out, and a few recent papers have investigated this trade-off taking gen-450 eral LCFRS rules as input.", "labels": [], "entities": []}, {"text": "present an algorithm for binarization of LCFRSs while keeping fan-out as small as possible.", "labels": [], "entities": []}, {"text": "The algorithm is exponential in the resulting fan-out, and as an important open question whether polynomialtime algorithms to minimize fan-out are possible.", "labels": [], "entities": []}, {"text": "Gildea (2010) presents a related method for binarizing rules while keeping the time complexity of parsing as small as possible.", "labels": [], "entities": []}, {"text": "Binarization turns out to be possible with no penalty in time complexity, but, again, the factorization algorithm is exponential in the resulting time complexity.", "labels": [], "entities": []}, {"text": "shows that a polynomial time algorithm for factorizing LCFRSs in order to minimize time complexity would imply an improved approximation algorithm for the well-studied graph-theoretic property known as treewidth.", "labels": [], "entities": []}, {"text": "However, whether the problem of factorizing LCFRSs in order to minimize time complexity is NP-hard is still an open question in the above works.", "labels": [], "entities": []}, {"text": "Similar questions have arisen in the context of machine translation, as the SCFGs used to model translation are also instances of LCFRSs, as already mentioned.", "labels": [], "entities": [{"text": "machine translation", "start_pos": 48, "end_pos": 67, "type": "TASK", "confidence": 0.7912724316120148}]}, {"text": "For SCFG, showed that the exponent in the time complexity of parsing algorithms must grow at least as fast as the square root of the rule rank, and tightened this bound to be linear in the rank.", "labels": [], "entities": [{"text": "parsing", "start_pos": 61, "end_pos": 68, "type": "TASK", "confidence": 0.9725887179374695}]}, {"text": "However, neither paper provides an algorithm for finding the best parsing strategy, and mention that whether finding the optimal parsing strategy for an SCFG rule is NPhard is an important problem for future work.", "labels": [], "entities": [{"text": "parsing", "start_pos": 66, "end_pos": 73, "type": "TASK", "confidence": 0.961847722530365}]}, {"text": "In this paper, we investigate the problem of rule binarization for LCFRSs in the context of headdriven parsing strategies.", "labels": [], "entities": [{"text": "headdriven parsing", "start_pos": 92, "end_pos": 110, "type": "TASK", "confidence": 0.83155357837677}]}, {"text": "Head-driven strategies begin with one rhs symbol, and add one nonterminal at a time.", "labels": [], "entities": []}, {"text": "This rules out any factorization in which two subsets of nonterminals of size greater than one are combined in a single step.", "labels": [], "entities": []}, {"text": "Head-driven strategies allow for the techniques of lexicalization and Markovization that are widely used in (projective) statistical parsing.", "labels": [], "entities": [{"text": "statistical parsing", "start_pos": 121, "end_pos": 140, "type": "TASK", "confidence": 0.7262909412384033}]}, {"text": "The statistical LCFRS parser of binarizes rules head-outward, and therefore adopts what we refer to as a head-driven strategy.", "labels": [], "entities": [{"text": "LCFRS parser", "start_pos": 16, "end_pos": 28, "type": "TASK", "confidence": 0.604021817445755}]}, {"text": "However, the binarization used by simply proceeds left to right through the rule, without considering the impact of the parsing strategy on either time or space complexity.", "labels": [], "entities": []}, {"text": "We examine the question of whether we can efficiently find the strategy that minimizes either the time complexity or the space complexity of parsing.", "labels": [], "entities": []}, {"text": "While a naive algorithm can evaluate all r!", "labels": [], "entities": []}, {"text": "head-driven strategies in time O(n \u00b7 r!), where r is the rule's rank and n is the total length of the rule's description, we wish to determine whether a polynomial-time algorithm is possible.", "labels": [], "entities": []}, {"text": "Since parsing problems can be cast in terms of logic programming, we note that our problem can bethought of as a type of query optimization for logic programming.", "labels": [], "entities": []}, {"text": "Query optimization for logic programming is NP-complete since query optimization for even simple conjunctive database queries is NP-complete.", "labels": [], "entities": [{"text": "Query optimization", "start_pos": 0, "end_pos": 18, "type": "TASK", "confidence": 0.8659010529518127}]}, {"text": "However, the fact that variables in queries arising from LCFRS rules correspond to the endpoints of spans in the string to be parsed means that these queries have certain structural properties.", "labels": [], "entities": []}, {"text": "We wish to determine whether the structure of LCFRS rules makes efficient factorization algorithms possible.", "labels": [], "entities": []}, {"text": "In the following, we show both the the time-and space-complexity problems to be NP-hard for headdriven strategies.", "labels": [], "entities": []}, {"text": "We provide what is to our knowledge the first NP-hardness result fora grammar factorization problem, which we hope will aid in understanding parsing algorithms in general.", "labels": [], "entities": [{"text": "understanding parsing algorithms", "start_pos": 127, "end_pos": 159, "type": "TASK", "confidence": 0.7077989379564921}]}], "datasetContent": [], "tableCaptions": []}