{"title": [{"text": "Learning Constraints for Consistent Timeline Extraction", "labels": [], "entities": [{"text": "Consistent Timeline Extraction", "start_pos": 25, "end_pos": 55, "type": "TASK", "confidence": 0.6091844737529755}]}], "abstractContent": [{"text": "We present a distantly supervised system for extracting the temporal bounds of fluents (re-lations which only hold during certain times, such as attends school).", "labels": [], "entities": []}, {"text": "Unlike previous pipelined approaches, our model does not assume independence between each fluent or even between named entities with known connections (parent, spouse, employer, etc.).", "labels": [], "entities": []}, {"text": "Instead , we model what makes timelines of flu-ents consistent by learning cross-fluent constraints , potentially spanning entities as well.", "labels": [], "entities": []}, {"text": "For example, our model learns that someone is unlikely to start a job at age two or to marry someone who hasn't been born yet.", "labels": [], "entities": []}, {"text": "Our system achieves a 36% error reduction over a pipelined baseline.", "labels": [], "entities": [{"text": "error reduction", "start_pos": 26, "end_pos": 41, "type": "METRIC", "confidence": 0.9749879240989685}]}], "introductionContent": [{"text": "Many information extraction (IE) systems traditionally extracted just relations, but a great many real world relations such as attends school or has spouse vary overtime.", "labels": [], "entities": [{"text": "information extraction (IE)", "start_pos": 5, "end_pos": 32, "type": "TASK", "confidence": 0.8595871686935425}]}, {"text": "To capture this, some recent IE systems have extended their focus from relations to fluents (relations combined with temporal bounds).", "labels": [], "entities": [{"text": "IE", "start_pos": 29, "end_pos": 31, "type": "TASK", "confidence": 0.9667871594429016}]}, {"text": "This can be seen in the temporal slot filling track in the TAC-KBP 2011 shared task.", "labels": [], "entities": [{"text": "TAC-KBP 2011 shared task", "start_pos": 59, "end_pos": 83, "type": "DATASET", "confidence": 0.771085724234581}]}, {"text": "A direct application of this work is the automatic improvement of online resources such as Freebase and Wikipedia infoboxes.", "labels": [], "entities": []}, {"text": "Indirect applications include question answering systems.", "labels": [], "entities": [{"text": "question answering", "start_pos": 30, "end_pos": 48, "type": "TASK", "confidence": 0.9279856979846954}]}, {"text": "Fluents can be grouped together to form timelines (see for an example) and provide easily capturable consistency constraints.", "labels": [], "entities": []}, {"text": "Our goal is to learn these constraints and use them to produce more accurate timelines of significant events for people and organizations.", "labels": [], "entities": []}, {"text": "For example, it is common knowledge that someone cannot attend a school if they haven't been born yet.", "labels": [], "entities": []}, {"text": "Constraints on consistent timelines do not need to be hard constraints, though: it is rare, although possible, to become the CEO of a company at the age of 21.", "labels": [], "entities": []}, {"text": "Despite the rich constraints on valid timelines, there is relatively little work on exploiting these constraints for mutual disambiguation.", "labels": [], "entities": []}, {"text": "Many existing systems extract different parts of a timeline separately and use heuristics to combine them.", "labels": [], "entities": []}, {"text": "These heuristics tend to optimize only local consistency (within a single fluent) but ignore more global constraints across fluents (e.g., attending a school before being born) or across fluents of two linked entities (e.g., attending a school before the school was founded).", "labels": [], "entities": []}, {"text": "In this work, we explore using joint inference to enforce these constraints.", "labels": [], "entities": []}, {"text": "We show that these techniques can yield substantial improvements.", "labels": [], "entities": []}, {"text": "Additionally, our general approach is not specific to extracting temporal boundaries of fluents.", "labels": [], "entities": []}, {"text": "It could easily be applied to other IE systems which employ independent extractions followed by heuristics to improve consistency.", "labels": [], "entities": [{"text": "IE", "start_pos": 36, "end_pos": 38, "type": "TASK", "confidence": 0.9583244919776917}]}], "datasetContent": [{"text": "We evaluate our models (CC and JCC) according to their ability to predict the temporal bounds of fluents from Freebase.", "labels": [], "entities": [{"text": "JCC", "start_pos": 31, "end_pos": 34, "type": "DATASET", "confidence": 0.6782165169715881}]}, {"text": "This is similar to the Diagnostic Track in the Temporal KBP task, where gold relations are provided as inputs.", "labels": [], "entities": [{"text": "Temporal KBP task", "start_pos": 47, "end_pos": 64, "type": "TASK", "confidence": 0.6261964042981466}]}, {"text": "We provide three baselines for comparison, discussed further in \u00a74.2.", "labels": [], "entities": []}, {"text": "To form our database, we scraped a random sample of people and organization entities from Freebase using their API.", "labels": [], "entities": [{"text": "Freebase", "start_pos": 90, "end_pos": 98, "type": "DATASET", "confidence": 0.9548541903495789}]}, {"text": "Since our consistency model has limited effect if entities do not have any links to other entities, we restrict our attention to entities linked to at least one other entity -this eliminates a large portion of possible entities.", "labels": [], "entities": []}, {"text": "Our corpus 7 consists of 8,450 entities for training, 1,072 for development, and 1,067 for test.", "labels": [], "entities": []}, {"text": "Entities have approximately 2.0 fluents on average.", "labels": [], "entities": []}, {"text": "From experiments on the development set, we set the relative strength of the consistency component \u03b2 = 10.", "labels": [], "entities": []}, {"text": "For the JCC model, we perform three runs for each experiment with different random seeds.", "labels": [], "entities": [{"text": "JCC", "start_pos": 8, "end_pos": 11, "type": "DATASET", "confidence": 0.7462615966796875}]}, {"text": "Each experiment performs 10 rounds of RRHC, 8 initializing from an empty timeline.", "labels": [], "entities": [{"text": "RRHC", "start_pos": 38, "end_pos": 42, "type": "TASK", "confidence": 0.8097445964813232}]}, {"text": "Our evaluation metric is adapted from the Temporal KBP metric) to work with 2-tuples for temporal representations rather than the 4-tuples in Temporal KBP.", "labels": [], "entities": []}, {"text": "The metric favors tighter bounds on fluents while giving partial credit.", "labels": [], "entities": []}, {"text": "All dates need to be given at day resolution.", "labels": [], "entities": []}, {"text": "Thus, for gold fluents with only year-or month-level resolution, we treat them as their earliest (for starts) or latest (for ends) possible day.", "labels": [], "entities": []}, {"text": "To score a boundary, we take the difference between the predicted and gold values: If they're both unbounded (\u00b1\u221e), the boundary's score is 1.", "labels": [], "entities": []}, {"text": "If only one is unbounded, the score is 0.", "labels": [], "entities": []}, {"text": "If both are finite, the score is 1/(1 + |d|) where dis the difference between the values in years.", "labels": [], "entities": []}, {"text": "To score a fluent, we average the scores of its start and end boundaries.", "labels": [], "entities": []}, {"text": "In rare cases, we have multiple spans for the same relation (e.g., Elizabeth Taylor married Richard Burton twice).", "labels": [], "entities": []}, {"text": "In these cases, we give systems the benefit of the doubt and greedily align fluents in such away as to maximize the metric.", "labels": [], "entities": []}, {"text": "The total metric computes the score of each fluent divided by the number of fluents.", "labels": [], "entities": []}, {"text": "The official metric includes precision and recall components, but since our setup provides gold relations, our precision and recall are be equal.", "labels": [], "entities": [{"text": "precision", "start_pos": 29, "end_pos": 38, "type": "METRIC", "confidence": 0.9993292093276978}, {"text": "recall", "start_pos": 43, "end_pos": 49, "type": "METRIC", "confidence": 0.9925200939178467}, {"text": "precision", "start_pos": 111, "end_pos": 120, "type": "METRIC", "confidence": 0.9997232556343079}, {"text": "recall", "start_pos": 125, "end_pos": 131, "type": "METRIC", "confidence": 0.9993784427642822}]}, {"text": "This allows us to report a single number.", "labels": [], "entities": []}], "tableCaptions": [{"text": " Table 2: Performance of systems on development and test  divisions. The Joint classifier with Consistency is the av- erage of three runs with negligible variance (\u03c3 \u2248 0.02).", "labels": [], "entities": [{"text": "av- erage", "start_pos": 114, "end_pos": 123, "type": "METRIC", "confidence": 0.6009745399157206}]}, {"text": " Table 3: Fluent-level performance of models and baselines on development data. Scores are calculated with the  temporal metric. CC stands for Combined Classifier and JCC for Joint Classifier with Consistency. The JCC model  obtains most of its benefits on the two lifespan relations. For attends school, it is the only system able to achieve  oracle-level performance. The null baseline is especially strong for several fluents since these tend to be unbounded or  (more likely) missing their values in Freebase. The two basic aggregation models differ primarily on their predictions  for the lifespan fluents.", "labels": [], "entities": [{"text": "Freebase", "start_pos": 504, "end_pos": 512, "type": "DATASET", "confidence": 0.9717546701431274}]}]}