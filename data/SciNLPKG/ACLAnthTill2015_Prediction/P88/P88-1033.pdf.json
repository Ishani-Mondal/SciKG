{"title": [{"text": "A DEFINITE CLAUSE VERSION OF CATEGORIAL GRAMMAR", "labels": [], "entities": [{"text": "VERSION", "start_pos": 18, "end_pos": 25, "type": "METRIC", "confidence": 0.41328200697898865}, {"text": "GRAMMAR", "start_pos": 40, "end_pos": 47, "type": "METRIC", "confidence": 0.8505160808563232}]}], "abstractContent": [{"text": "We introduce a first-order version of Categorial Grammar, based on the idea of encoding syntactic types as definite clauses.", "labels": [], "entities": [{"text": "Categorial Grammar", "start_pos": 38, "end_pos": 56, "type": "TASK", "confidence": 0.8235793113708496}]}, {"text": "Thus, we drop all explicit requirements of adjacency between combinable constituents, and we capture word-order constraints simply by allowing subformu-lae of complex types to share variables ranging over string positions.", "labels": [], "entities": []}, {"text": "We are in this way able to account for constructiods involving discontin-uous constituents.", "labels": [], "entities": []}, {"text": "Such constructions axe difficult to handle in the more traditional version of Categorial Grammar, which is based on propositional types and on the requirement of strict string ad-jacency between combinable constituents.", "labels": [], "entities": [{"text": "Categorial Grammar", "start_pos": 78, "end_pos": 96, "type": "TASK", "confidence": 0.7586006224155426}]}, {"text": "We show then how, for this formalism, parsing can be efficiently implemented as theorem proving.", "labels": [], "entities": [{"text": "parsing", "start_pos": 38, "end_pos": 45, "type": "TASK", "confidence": 0.9708579778671265}, {"text": "theorem proving", "start_pos": 80, "end_pos": 95, "type": "TASK", "confidence": 0.8317678868770599}]}, {"text": "Our approach to encoding types:as definite clauses presupposes a modification of standard Horn logic syntax to allow internal implications in definite clauses.", "labels": [], "entities": []}, {"text": "This modification is needed to account for the types of higher-order functions and, as a consequence , standard Prolog-like Horn logic theorem proving is not powerful enough.", "labels": [], "entities": [{"text": "Prolog-like Horn logic theorem proving", "start_pos": 112, "end_pos": 150, "type": "TASK", "confidence": 0.7923658013343811}]}, {"text": "We tackle this * I am indebted to Dale Miller for help and advice.", "labels": [], "entities": []}, {"text": "I am also grateful to problem by adopting an intuitionistic treatment of implication, which has already been proposed elsewhere as an extension of Prolog for implementing hypothetical reasoning and modular logic programming .", "labels": [], "entities": []}], "introductionContent": [{"text": "Classical Categorial Grammar (CG) is an approach to natural language syntax where all linguistic information is encoded in the lexicon, via the assignment of syntactic types to lexical items.", "labels": [], "entities": [{"text": "Classical Categorial Grammar (CG)", "start_pos": 0, "end_pos": 33, "type": "TASK", "confidence": 0.8662662009398142}]}, {"text": "Such syntactic types can be viewed as expressions of an implicational calculus of propositions, where atomic propositions correspond to atomic types, and implicational propositions account for complex types.", "labels": [], "entities": []}, {"text": "A string is grammatical if and only if its syntactic type can be logically derived from the types of its words, assuming certain inference rules.", "labels": [], "entities": []}, {"text": "In classical CG, a common way of encoding word-order constraints is by having two symmetric forms of \"directional\" implication, usually indicated with the forward slash / and the backward slash \\, constraining the antecedent of a complex type to be, respectively, right-or left-adjacent.", "labels": [], "entities": []}, {"text": "A word, or a string of words, associated with a right-(left-) oriented type can then bethought of as a right-(left-) oriented function looking for an argument of the type specified in the antecedent.", "labels": [], "entities": []}, {"text": "A convention more or less generally followed by linguists working in CG is to have the antecedent and the consequent of an implication respectively on the right and on tile left of the connective.", "labels": [], "entities": []}, {"text": "Thus, tile type-assignment (1) says that the ditransitive verb put is a function taking a right-adjacent argulnent of type NP, to return a function taking a right-adjacent argument of type PP, to return a function taking a left-adjacent argument of type NP, to finally return an expression of the atomic type S.", "labels": [], "entities": []}, {"text": "(1) put: The Definite Clause Grammar (DCG) framework (see also), where phrase-structure grammars can be encoded as sets of definite clauses (which are themselves a subset of Horn clauses), and the formalization of some aspects of it in, suggests a more expressive alternative to encode word-order constraints in CG.", "labels": [], "entities": []}, {"text": "Such an alternative eliminates all notions of directionality from the logical connectives, and any explicit requirement of adjacency between functions and arguments, and replaces propositions with first-order \u2022 formulae.", "labels": [], "entities": []}, {"text": "Thus, atomic types are viewed as atomic formulae obtained from two-place predicates over string positions represented as integers, the first and the second argument corresponding, respectively, to the left and right end of a given string.", "labels": [], "entities": []}, {"text": "Therefore, the set of all sentences of length j generated from a certain lexicon corresponds to the type S(0,j).", "labels": [], "entities": []}, {"text": "Constraints over the order of constituents are enforced by sharing integer indices across subformulae inside complex (functional) types.", "labels": [], "entities": []}, {"text": "This first-order version of CG can be viewed as a logical reconstruction of some of the ideas behind the recent trend of Categorial Unification Grammars 1.", "labels": [], "entities": []}, {"text": "A strongly analogous development characterizes the systems of type-assignment for the formal languages of Combinatory Logic and Lambda Calculus, leading from propositional type systems to the \"formulae-as-types\" slogan which is behind the current research in type theory.", "labels": [], "entities": [{"text": "type theory", "start_pos": 259, "end_pos": 270, "type": "TASK", "confidence": 0.923297107219696}]}, {"text": "In this paper, we show how syntactic types can be encoded using an extended version of standard Horn logic syntax.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": []}