{"title": [{"text": "Conditional Descriptions in Functional Unification Grammar", "labels": [], "entities": [{"text": "Conditional Descriptions", "start_pos": 0, "end_pos": 24, "type": "TASK", "confidence": 0.8587414026260376}]}], "abstractContent": [{"text": "A grammatical description often applies to a linguistic object only when that object has certain features.", "labels": [], "entities": []}, {"text": "Such conditional descriptions can be indirectly modeled in Kay's Functional Unification Grammar (FUG) using functional descriptions that are embedded within disjunctive alternatives.", "labels": [], "entities": []}, {"text": "An extension to FUG is proposed that allows fora direct representation of conditional descriptions.", "labels": [], "entities": [{"text": "FUG", "start_pos": 16, "end_pos": 19, "type": "DATASET", "confidence": 0.806650698184967}]}, {"text": "This extension has been used to model the input conditions on the systems of systemic grammar.", "labels": [], "entities": []}, {"text": "Conditional descriptions are formally defined in terms of logical implication and negation.", "labels": [], "entities": []}, {"text": "This formal definition enables the use of conditional descriptions as a general notational extension to any of the unification-based gram\u00b0 mar representation systems currently used in computational linguistics.", "labels": [], "entities": []}], "introductionContent": [{"text": "Functional Unification Grammar (FUG) and other grammatical formalisms that use feature structures and unification provide a general basis for the declarative representation of natural language grammars.", "labels": [], "entities": [{"text": "Functional Unification Grammar (FUG)", "start_pos": 0, "end_pos": 36, "type": "TASK", "confidence": 0.7574953536192576}]}, {"text": "In order to utilize some of the computational tools available with unification grammars, we have developed a mapping from sVstelnic \u00a2ram-mars into FUG notation.", "labels": [], "entities": [{"text": "FUG", "start_pos": 147, "end_pos": 150, "type": "METRIC", "confidence": 0.5461805462837219}]}, {"text": "This mapping has been used as the first step in creating a general parsing method for systemic grammars.", "labels": [], "entities": []}, {"text": "The experience of translating systemic grammars into FUG has shown several ways in which the notational resources of FUG maybe improved.", "labels": [], "entities": [{"text": "FUG", "start_pos": 53, "end_pos": 56, "type": "DATASET", "confidence": 0.8675447702407837}, {"text": "FUG", "start_pos": 117, "end_pos": 120, "type": "DATASET", "confidence": 0.8581633567810059}]}, {"text": "In particular, FUG has limited notational resources for expressing conditional information.", "labels": [], "entities": [{"text": "FUG", "start_pos": 15, "end_pos": 18, "type": "DATASET", "confidence": 0.8096997737884521}]}, {"text": "In this paper we describe how FUG has been enhanced by the addition of conditional descriptions, building on research that has already been reported [Kas87a,.", "labels": [], "entities": [{"text": "FUG", "start_pos": 30, "end_pos": 33, "type": "METRIC", "confidence": 0.9907732009887695}]}, {"text": "Conditional information is stated explicitly in systemic grammars by the input conditions of systems that specify when a system must be used.", "labels": [], "entities": []}, {"text": "Consider, for example, the two systems (MoodType and Indicatlve'l~ype) x shown in.", "labels": [], "entities": []}, {"text": "The input condition for the MoodType system is the feature IThis example is extracted from Nigel, a large systemic grammar of English that has been developed in text generation research at USC/ISI.", "labels": [], "entities": [{"text": "text generation", "start_pos": 161, "end_pos": 176, "type": "TASK", "confidence": 0.7056189179420471}]}, {"text": "C/auae, and the input condition for the IndicatlveType system ls the feature Indicative.", "labels": [], "entities": [{"text": "Indicative", "start_pos": 77, "end_pos": 87, "type": "METRIC", "confidence": 0.7949054837226868}]}, {"text": "Because the features of a systemic grammar are normally introduced by a unique system, these input conditions actually express a bidirectional type of logical implication: I.", "labels": [], "entities": []}, {"text": "If a constituent has the feature(s) specified by a system's input condition, then exactly one of the alternatives described by that system must also be yard for the constituent; 2.", "labels": [], "entities": []}, {"text": "If a constituent has one of the feature alternatives described by a system, then it must also have the feature(s) specified by that system's input condition.", "labels": [], "entities": []}, {"text": "Thus the input condition of the Irtd/cative~pe system expresses the following implications: 1.", "labels": [], "entities": []}, {"text": "If a clause ha~s the feature Indic,~tive, then it must also have exactly one of the alternatives from the Zndicative23,/pe system (either Declarative or Interrogative).", "labels": [], "entities": []}, {"text": "2. If a clause has one of the feature alternatives described by the Indicativs~3ype system (either Declarative or/nterrooaties), then it must also have the feature Indieaties.", "labels": [], "entities": []}, {"text": "While it is theoretically correct to regard the two directions of implication as exact converses of each other, there is a subtle difference between them.", "labels": [], "entities": []}, {"text": "The consequent of the first type of implication is the description of the entire system, including systemic features and their realizations.", "labels": [], "entities": []}, {"text": "2 The antecedent of the second type of implication can be safely abbreviated by the systemic features without their realizations, because the presence of a systemic feature implies that its realizations also hold.", "labels": [], "entities": []}, {"text": "We will return to this distinction when we provide a formal definition of conditional descriptions in Section 2.", "labels": [], "entities": []}, {"text": "For simple input conditions, the first type of implication can be expressed in FUG, as it was originally formulated by, by embedding the description of one system inside the description of another.", "labels": [], "entities": [{"text": "FUG", "start_pos": 79, "end_pos": 82, "type": "METRIC", "confidence": 0.9661220908164978}]}, {"text": "For example, we can capture this implication for the IndicativeType system by embedding it within the description of the Indicative alternative of the 2A realization is a statement of structural properties that are required by a feature, such as the statement that SUBJECT precedes FINITE for the feature declarative.", "labels": [], "entities": [{"text": "FINITE", "start_pos": 282, "end_pos": 288, "type": "METRIC", "confidence": 0.8785418272018433}]}, {"text": "Figure 2: The MoodType and IndlcativeType Systems in FUG MoodType system, as shown in.", "labels": [], "entities": [{"text": "FUG MoodType system", "start_pos": 53, "end_pos": 72, "type": "DATASET", "confidence": 0.8824950853983561}]}, {"text": "Note that the second type of implication expressed by systemic input conditions has not been expressed by embedding one functional description inside another.", "labels": [], "entities": []}, {"text": "To express the second type of lmplicatlon, we have used a different notational device, called a feature existence condition; it will be defined in Section 2.4.", "labels": [], "entities": []}, {"text": "Not all systems have simple input conditions consisting of single features.", "labels": [], "entities": []}, {"text": "Those input conditious which are complex boolea~u expressions over features cannot be expressed directly by embedding.", "labels": [], "entities": []}, {"text": "Consider the BenefactiveVolce s system shown in as an example.", "labels": [], "entities": []}, {"text": "Its input condition is the conjunction of two features, Agentive and Benefactive.", "labels": [], "entities": []}, {"text": "One way to express a system with a complex input condition in FUG is to use a disjunction with two alternatives, as shown in.", "labels": [], "entities": [{"text": "FUG", "start_pos": 62, "end_pos": 65, "type": "DATASET", "confidence": 0.8193367719650269}]}, {"text": "The first alternative corresponds to what happens when the Benef~ctiveVoice system is entered; the second alternative corresponds to what happens when the BenefactlveVoice system is not entered.", "labels": [], "entities": []}, {"text": "The first alternative also includes the features of the input condition.", "labels": [], "entities": []}, {"text": "The second alternative includes the features of the negated input condition.", "labels": [], "entities": []}, {"text": "Notice that the input condition and its negation must both be stated explicltly, unlike in systemic notation.", "labels": [], "entities": []}, {"text": "If the negation of the input condition was not included in the second alternative, it would be possible to use this alternative 3The BenefactivcVoice system iJ also extracted from the Nigel grammar.", "labels": [], "entities": [{"text": "Nigel grammar", "start_pos": 184, "end_pos": 197, "type": "DATASET", "confidence": 0.866683304309845}]}, {"text": "It describes the active and passive voice options that are possible in clauses that have both an agent and a beneficiary.", "labels": [], "entities": []}, {"text": "The active/passive distinction is not primitive in systemic grammars of English.", "labels": [], "entities": []}, {"text": "Instead, it is decomposed into several cases depending on which participant roles are present in the clause.", "labels": [], "entities": []}, {"text": "In this case the subject of a passive clause maybe conflated with either beneficiary or medium.", "labels": [], "entities": []}, {"text": "even when the input condition for the system holds.", "labels": [], "entities": []}, {"text": "Thus the description of the system would not always be used when it should be.", "labels": [], "entities": []}, {"text": "Note that this method of encoding systemic input conditions presupposes an adequate treatment of negated features.\"", "labels": [], "entities": []}, {"text": "A formal definition of negation will be developed in Section 2.3.", "labels": [], "entities": [{"text": "negation", "start_pos": 23, "end_pos": 31, "type": "TASK", "confidence": 0.9817149639129639}]}, {"text": "While it is formally possible to encode complex input conditione by disjunction and ne~tion, such encoding IS not altogether satisfactory: It should not be necessary to state the negated input condition explicitly, since it can always be derived automatically from the unne&-~ted condition.", "labels": [], "entities": []}, {"text": "It is also rather inefficient to mix the features of the input condition with the other features of the system.", "labels": [], "entities": []}, {"text": "The features of the input condition contain exactly the information that is needed to choose between the two alternatives of the disjunction (Le., to choose whether the system is entered or not).", "labels": [], "entities": []}, {"text": "It would be more efficient and less verbose to have a notation in which the features of the input condition are distlnguished from the other features of the system, and in which the negation of the input condition does not need to be stated explicitly.", "labels": [], "entities": []}, {"text": "Therefore, we have developed an extension to FUG that uses a conditional operator (-~), as illustrated by the encoding of the BenefactiveVoice system shown in.", "labels": [], "entities": [{"text": "FUG", "start_pos": 45, "end_pos": 48, "type": "DATASET", "confidence": 0.8336319923400879}]}, {"text": "A description corresponding to the input condition appears to the left of the --~ symbol, and the description to be included when the input condition is satisfied appears to its right.", "labels": [], "entities": []}, {"text": "A formal definition of what it means fora description to be satisfied will be given in Section 2.1. 4Some negations of atomic features can be replaced by a finite disjunction of other pouible values for that feature, but this technique only works effectively when the set of possible values is small and can be enumerated.", "labels": [], "entities": []}, {"text": "where a E A, to describe atomic values; where l E Land ~b E FDL, to describe structures in which the feature labeled by I has a value described by ~; where each p; E L', to describe an equivalence class of paths sharing a common value in a feature structure; where ~i E FDL, denoting conjunction; where ~; E FDL, denoting disjunction.", "labels": [], "entities": [{"text": "FDL", "start_pos": 60, "end_pos": 63, "type": "METRIC", "confidence": 0.9631330966949463}, {"text": "FDL", "start_pos": 270, "end_pos": 273, "type": "METRIC", "confidence": 0.983927309513092}, {"text": "E", "start_pos": 306, "end_pos": 307, "type": "METRIC", "confidence": 0.9292095303535461}, {"text": "FDL", "start_pos": 308, "end_pos": 311, "type": "METRIC", "confidence": 0.5306622385978699}]}, {"text": "sets of symbols which are used to denote atomic values and feature labels, respectively.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": []}