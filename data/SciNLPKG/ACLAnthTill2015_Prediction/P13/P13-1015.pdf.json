{"title": [{"text": "Generic binarization for parsing and translation", "labels": [], "entities": [{"text": "translation", "start_pos": 37, "end_pos": 48, "type": "TASK", "confidence": 0.6102907657623291}]}], "abstractContent": [{"text": "Binarization of grammars is crucial for improving the complexity and performance of parsing and translation.", "labels": [], "entities": [{"text": "parsing and translation", "start_pos": 84, "end_pos": 107, "type": "TASK", "confidence": 0.6086071133613586}]}, {"text": "We present a versatile binarization algorithm that can be tailored to a number of grammar formalisms by simply varying a formal parameter.", "labels": [], "entities": []}, {"text": "We apply our algorithm to bi-narizing tree-to-string transducers used in syntax-based machine translation.", "labels": [], "entities": [{"text": "machine translation", "start_pos": 86, "end_pos": 105, "type": "TASK", "confidence": 0.7115446925163269}]}], "introductionContent": [{"text": "Binarization amounts to transforming a given grammar into an equivalent grammar of rank 2, i.e., with at most two nonterminals on any righthand side.", "labels": [], "entities": []}, {"text": "The ability to binarize grammars is crucial for efficient parsing, because for many grammar formalisms the parsing complexity depends exponentially on the rank of the grammar.", "labels": [], "entities": []}, {"text": "It is also critically important for tractable statistical machine translation (SMT).", "labels": [], "entities": [{"text": "statistical machine translation (SMT)", "start_pos": 46, "end_pos": 83, "type": "TASK", "confidence": 0.7762004435062408}]}, {"text": "Syntaxbased SMT systems) typically use some type of synchronous grammar describing a binary translation relation between strings and/or trees, such as synchronous context-free grammars (SCFGs) (, synchronous tree-substitution grammars, synchronous tree-adjoining grammars (, and tree-tostring transducers).", "labels": [], "entities": [{"text": "SMT", "start_pos": 12, "end_pos": 15, "type": "TASK", "confidence": 0.9317730069160461}]}, {"text": "These grammars typically have a large number of rules, many of which have rank greater than two.", "labels": [], "entities": []}, {"text": "The classical approach to binarization, as known from the Chomsky normal form transformation for context-free grammars (CFGs), proceeds rule by rule.", "labels": [], "entities": []}, {"text": "It replaces each rule of rank greater than 2 by an equivalent collection of rules of rank 2.", "labels": [], "entities": []}, {"text": "All CFGs can be binarized in this way, which is why their recognition problem is cubic.", "labels": [], "entities": []}, {"text": "In the case of linear context-free rewriting systems (LCFRSs,) the rule-by-rule technique also applies to every grammar, as long as an increased fanout it permitted).", "labels": [], "entities": []}, {"text": "There are also grammar formalisms for which the rule-by-rule technique is not complete.", "labels": [], "entities": []}, {"text": "In the case of SCFGs, not every grammar has an equivalent representation of rank 2 in the first place.", "labels": [], "entities": []}, {"text": "Even when such a representation exists, it is not always possible to compute it rule by rule.", "labels": [], "entities": []}, {"text": "Nevertheless, the rule-by-rule binarization algorithm of is very useful in practice.", "labels": [], "entities": []}, {"text": "In this paper, we offer a generic approach for transferring the rule-by-rule binarization technique to new grammar formalisms.", "labels": [], "entities": []}, {"text": "At the core of our approach is a binarization algorithm that can be adapted to anew formalism by changing a parameter at runtime.", "labels": [], "entities": []}, {"text": "Thus it only needs to be implemented once, and can then be reused fora variety of formalisms.", "labels": [], "entities": []}, {"text": "More specifically, our algorithm requires the user to (i) encode the grammar formalism as a subclass of interpreted regular tree grammars) and (ii) supply a collection of b-rules, which represent equivalence of grammars syntactically.", "labels": [], "entities": []}, {"text": "Our algorithm then replaces, in a given grammar, each rule of rank greater than 2 by an equivalent collection of rules of rank 2, if such a collection is licensed by the b-rules.", "labels": [], "entities": []}, {"text": "We define completeness of b-rules in away that ensures that if any equivalent collection of rules of rank 2 exists, the algorithm finds one.", "labels": [], "entities": []}, {"text": "As a consequence, the algorithm binarizes every grammar that can be binarized rule by rule.", "labels": [], "entities": []}, {"text": "Step (i) is possible for all the grammar formalisms mentioned above.", "labels": [], "entities": []}, {"text": "We show Step (ii) for SCFGs and tree-to-string transducers.", "labels": [], "entities": []}, {"text": "We will use SCFGs as our running example throughout the paper.", "labels": [], "entities": []}, {"text": "We will also apply the algo-rithm to tree-to-string transducers (), which describe relations between strings in one language and parse trees of another, which means that existing methods for binarizing SCFGs and LCFRSs cannot be directly applied to these systems.", "labels": [], "entities": []}, {"text": "To our knowledge, our binarization algorithm is the first to binarize such transducers.", "labels": [], "entities": []}, {"text": "We illustrate the effectiveness of our system by binarizing a large treeto-string transducer for English-German SMT.", "labels": [], "entities": [{"text": "SMT", "start_pos": 112, "end_pos": 115, "type": "TASK", "confidence": 0.8533558249473572}]}, {"text": "We start by defining IRTGs in Section 2.", "labels": [], "entities": [{"text": "IRTGs", "start_pos": 21, "end_pos": 26, "type": "TASK", "confidence": 0.8201861381530762}]}, {"text": "In Section 3, we define the general outline of our approach to rule-by-rule binarization for IRTGs, and then extend this to an efficient binarization algorithm based on b-rules in Section 4.", "labels": [], "entities": []}, {"text": "In Section 5 we show how to use the algorithm to perform rule-by-rule binarization of SCFGs and tree-to-string transducers, and relate the results to existing work.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": []}