{"title": [{"text": "Plurality, Negation, and Quantification: Towards Comprehensive Quantifier Scope Disambiguation", "labels": [], "entities": [{"text": "Negation, and Quantification", "start_pos": 11, "end_pos": 39, "type": "TASK", "confidence": 0.6201705485582352}, {"text": "Quantifier Scope Disambiguation", "start_pos": 63, "end_pos": 94, "type": "TASK", "confidence": 0.682250459988912}]}], "abstractContent": [{"text": "Recent work on statistical quantifier scope disambiguation (QSD) has improved upon earlier work by scoping an arbitrary number and type of noun phrases.", "labels": [], "entities": [{"text": "statistical quantifier scope disambiguation (QSD)", "start_pos": 15, "end_pos": 64, "type": "TASK", "confidence": 0.8215156367846898}]}, {"text": "No corpus-based method, however, has yet addressed QSD when incorporating the implicit universal of plurals and/or operators such as negation.", "labels": [], "entities": []}, {"text": "In this paper we report early, though promising, results for automatic QSD when handling both phenomena.", "labels": [], "entities": [{"text": "QSD", "start_pos": 71, "end_pos": 74, "type": "TASK", "confidence": 0.8106823563575745}]}, {"text": "We also present a general model for learning to build partial orders from a set of pair-wise preferences.", "labels": [], "entities": []}, {"text": "We give an n log n algorithm for finding a guaranteed approximation of the optimal solution, which works very well in practice.", "labels": [], "entities": []}, {"text": "Finally, we significantly improve the performance of the previous model using a rich set of automatically generated features.", "labels": [], "entities": []}], "introductionContent": [{"text": "The sentence there is one faculty member in every graduate committee is ambiguous with respect to quantifier scoping, since there are at least two possible readings: If one has wide scope, there is a unique faculty member on every committee.", "labels": [], "entities": [{"text": "quantifier scoping", "start_pos": 98, "end_pos": 116, "type": "TASK", "confidence": 0.7120781540870667}]}, {"text": "If every has wide scope, there can be different faculty members on each committee.", "labels": [], "entities": []}, {"text": "Over the past decade there has been some work on statistical quantifier scope disambiguation (QSD)).", "labels": [], "entities": [{"text": "statistical quantifier scope disambiguation (QSD))", "start_pos": 49, "end_pos": 99, "type": "TASK", "confidence": 0.7864607317107064}]}, {"text": "However, the extent of the work has been quite limited for several reasons.", "labels": [], "entities": []}, {"text": "First, in the past two decades, the main focus of the NLP community has been on shallow text processing.", "labels": [], "entities": [{"text": "shallow text processing", "start_pos": 80, "end_pos": 103, "type": "TASK", "confidence": 0.6056621472040812}]}, {"text": "As a deep processing task, QSD is not essential for many NLP applications that do not require deep understanding.", "labels": [], "entities": []}, {"text": "Second, there has been alack of comprehensive scope-disambiguated corpora, resulting in the lack of work on extensive statistical QSD.", "labels": [], "entities": []}, {"text": "Third, QSD has often been considered only in the context of explicit quantification such as each and every versus some and a/an.", "labels": [], "entities": []}, {"text": "These co-occurrences do not happen very often in real-life data.", "labels": [], "entities": []}, {"text": "For example, find fewer than 1000 sentences with two or more explicit quantifiers in the Wall Street journal section of Penn Treebank.", "labels": [], "entities": [{"text": "Wall Street journal section of Penn Treebank", "start_pos": 89, "end_pos": 133, "type": "DATASET", "confidence": 0.9432863422802517}]}, {"text": "Furthermore, for more than 60% of those sentences, the order of the quantifiers does not matter, either as a result of the logical equivalence (as in two existentials), or because they do not have any scope interaction.", "labels": [], "entities": []}, {"text": "Having said that, with deep language processing receiving more attention in recent years, QSD is becoming a real-life issue.", "labels": [], "entities": [{"text": "QSD", "start_pos": 90, "end_pos": 93, "type": "TASK", "confidence": 0.9639166593551636}]}, {"text": "At the same time, new scope-disambiguated corpora have become available (.", "labels": [], "entities": []}, {"text": "In this paper, we aim at tackling the third issue mentioned above.", "labels": [], "entities": []}, {"text": "We push statistical QSD beyond explicit quantification, and address an interesting, yet practically important, problem in QSD: plurality and quantification.", "labels": [], "entities": []}, {"text": "In spite of an extensive literature in theoretical semantics, this topic has not been well investigated in computational linguistics.", "labels": [], "entities": []}, {"text": "To illustrate the phenomenon, consider (1): 1.", "labels": [], "entities": []}, {"text": "Three words start with a capital letter.", "labels": [], "entities": []}, {"text": "A deep understanding of this sentence, requires deciding whether each word in the set, referred to by Three words, starts with a potentially distinct capital letter (as in Apple, Orange, Banana) or there is a unique capital letter which each word starts with (as in Apple, Adam, Athens).", "labels": [], "entities": []}, {"text": "By treating the NP Three words as a single atomic entity, earlier work on automatic QSD has overlooked this problem.", "labels": [], "entities": []}, {"text": "In general, every plural NP potentially introduces an implicit universal, ranging over the collection of entities introduced by the plural.", "labels": [], "entities": []}, {"text": "Scoping this implicit universal is just as important.", "labels": [], "entities": []}, {"text": "While explicit universals may not occur very often in natural language, the usage of plurals is very common.", "labels": [], "entities": []}, {"text": "Plurals form 18% of the NPs in our corpus and 20% of the nouns in Penn Treebank.", "labels": [], "entities": [{"text": "Penn Treebank", "start_pos": 66, "end_pos": 79, "type": "DATASET", "confidence": 0.9947413206100464}]}, {"text": "Explicit universals, on the other hand, formless than 1% of the determiners in Penn Treebank.", "labels": [], "entities": [{"text": "Penn Treebank", "start_pos": 79, "end_pos": 92, "type": "DATASET", "confidence": 0.9960539937019348}]}, {"text": "Quantifiers are also affected by negation.", "labels": [], "entities": []}, {"text": "Previous work (e.g., has investigated automatically detecting the scope and focus of negation.", "labels": [], "entities": [{"text": "automatically detecting the scope and focus of negation", "start_pos": 38, "end_pos": 93, "type": "TASK", "confidence": 0.5632043108344078}]}, {"text": "However, the scope of negation with respect to quantifiers is a different phenomenon.", "labels": [], "entities": []}, {"text": "2. The word does not start with a capital letter.", "labels": [], "entities": []}, {"text": "Transforming this sentence into a meaning representation language, for almost any practical purposes, requires deciding whether the NP a capital letter lies in the scope of the negation or outside of it.", "labels": [], "entities": []}, {"text": "The former describes the preferred reading where The word starts with a lowercase letter as in apple, orange, banana, but the latter gives the unlikely reading, according to which there exists a particular capital letter, say A, that The word starts with, as in apple, Orange, Banana.", "labels": [], "entities": []}, {"text": "By not involving negation in quantifier scoping, a semantic parser may produce an unintended interpretation.", "labels": [], "entities": []}, {"text": "Previous work on statistical QSD has been quite restricted., which we refer to as HS03, developed the first statistical QSD system for English.", "labels": [], "entities": [{"text": "HS03", "start_pos": 82, "end_pos": 86, "type": "DATASET", "confidence": 0.966590940952301}]}, {"text": "Their system disambiguates the scope of exactly two explicitly quantified NPs in a sentence, ignoring indefinite a/an, definites and bare NPs., hence MA11, go beyond those limitations and scope an arbitrary number of NPs in a sentence with no restriction on the type of quantification.", "labels": [], "entities": [{"text": "MA11", "start_pos": 150, "end_pos": 154, "type": "DATASET", "confidence": 0.8921405076980591}]}, {"text": "However, although their corpus annotates the scope of negations and the implicit universal of plurals, their QSD system does not handle those.", "labels": [], "entities": []}, {"text": "As a step towards comprehensive automatic QSD, in this paper we present our work on automatic scoping of the implicit universal of plurals and negations.", "labels": [], "entities": []}, {"text": "For data, we use anew revision of MA11's corpus, first introduced in.", "labels": [], "entities": [{"text": "MA11's corpus", "start_pos": 34, "end_pos": 47, "type": "DATASET", "confidence": 0.9657110770543417}]}, {"text": "The new revision, called QuanText, carries a more detailed, fine-grained scope annotation ().", "labels": [], "entities": [{"text": "QuanText", "start_pos": 25, "end_pos": 33, "type": "DATASET", "confidence": 0.8967113494873047}]}, {"text": "The performance of Although plurals carry different types of quantification, almost always there exists an implicit universal.", "labels": [], "entities": []}, {"text": "The importance of scoping this universal, however, may vary based on the type of quantification.", "labels": [], "entities": []}, {"text": "our model defines a baseline for future efforts on (comprehensive) QSD over QuanText.", "labels": [], "entities": []}, {"text": "In addition to addressing plurality and negation, this work improves upon MA11's in two directions.", "labels": [], "entities": [{"text": "MA11", "start_pos": 74, "end_pos": 78, "type": "DATASET", "confidence": 0.8219509124755859}]}, {"text": "\u2022 We theoretically justify MA11's ternaryclassification approach, formulating it as a general framework for learning to build partial orders.", "labels": [], "entities": []}, {"text": "Ann log n algorithm is then given to find a guaranteed approximation within a fixed ratio of the optimal solution from a set of pairwise preferences (Sect. 3.1).", "labels": [], "entities": []}, {"text": "\u2022 We replace MA11's hand-annotated features with a set of automatically generated linguistic features.", "labels": [], "entities": [{"text": "MA11", "start_pos": 13, "end_pos": 17, "type": "DATASET", "confidence": 0.8909897804260254}]}, {"text": "Our rich set of features significantly improves the performance of the QSD model, even though we give up the goldstandard dependency features (Sect. 3.3).", "labels": [], "entities": []}], "datasetContent": [{"text": "Given the gold standard DAG G g = (V, E g ) and the predicted DAG G p = (V, E p ), a similarity measure maybe defined based on the ratio of the number of pairs (of nodes) labeled correctly to the (a) G1 (d) G3: Scoping as DAG total number of pairs.", "labels": [], "entities": []}, {"text": "In order to take the transitivity of outscoping relations into account, we use the transitive closure (TC) of DAGs.", "labels": [], "entities": [{"text": "transitive closure (TC)", "start_pos": 83, "end_pos": 106, "type": "METRIC", "confidence": 0.7819858908653259}]}, {"text": "Let G + = (V, E + ) represent the TC of a DAG G = (V, E).", "labels": [], "entities": [{"text": "TC", "start_pos": 34, "end_pos": 36, "type": "METRIC", "confidence": 0.9456788301467896}]}, {"text": "3 G 1 and G + 1 in illustrate this concept.", "labels": [], "entities": []}, {"text": "We now define the similiarty metric S + as follows: in which \u00af G = (V, \u00af E) is the complement of the underlying undirected version of G.", "labels": [], "entities": []}, {"text": "HS03 and others have used such a similarity measure for evaluation purposes.", "labels": [], "entities": [{"text": "HS03", "start_pos": 0, "end_pos": 4, "type": "DATASET", "confidence": 0.9672755002975464}]}, {"text": "A disadvantage of this metric is that it gives the same weight to outscoping and incomparability relations.", "labels": [], "entities": []}, {"text": "In practice, if two scopal terms with equivalent ordering (and hence, no outscoping relation) are incorrectly labeled with an outscoping, the logical form still remains valid.", "labels": [], "entities": []}, {"text": "But if an outscoping relation is mislabeled, it will change the interpretation of the sentence.", "labels": [], "entities": []}, {"text": "Therefore, in MA11, we suggest defining a precision/recall based on the number of outscoping relations recovered correctly: 4 argues that TC-based metrics tend to produce higher numbers.", "labels": [], "entities": [{"text": "MA11", "start_pos": 14, "end_pos": 18, "type": "DATASET", "confidence": 0.8844223618507385}, {"text": "precision", "start_pos": 42, "end_pos": 51, "type": "METRIC", "confidence": 0.998794674873352}, {"text": "recall", "start_pos": 52, "end_pos": 58, "type": "METRIC", "confidence": 0.968482494354248}]}, {"text": "For example if G3 in is a goldstandard DAG and G1 is a candidate DAG, TC-based metrics count 2 > 3 as another match, even though it is entailed from 2 > 1 and 1 > 3.", "labels": [], "entities": []}, {"text": "They give an alternative metric based on transitive reduction (TR), obtained by removing all the redundant edges of a DAG.", "labels": [], "entities": [{"text": "transitive reduction (TR)", "start_pos": 41, "end_pos": 66, "type": "METRIC", "confidence": 0.607517421245575}]}, {"text": "TR-based metrics, however, have their own disadvantage.", "labels": [], "entities": []}, {"text": "For example, if G2 is another candidate for G3, TR-based metrics produce the same numbers for both G1 and G2, even though G1 is clearly closer to G3 than G2.", "labels": [], "entities": []}, {"text": "Therefore, in this paper we stick to TC-based metrics.", "labels": [], "entities": []}, {"text": "QuanText contains 500 sentences with a total of 1750 chunks, that is 3.5 chunks/sentence on average.", "labels": [], "entities": [{"text": "QuanText", "start_pos": 0, "end_pos": 8, "type": "DATASET", "confidence": 0.9335331916809082}]}, {"text": "Of those, 1700 chunks are NP chunks.", "labels": [], "entities": []}, {"text": "The rest are scopal operators, mainly negation.", "labels": [], "entities": []}, {"text": "Of all the NP chunks, 320 (more than 18%) are plural, each introducing an implicit universal, that is, an additional node in the DAG.", "labels": [], "entities": []}, {"text": "Since we feed each pair of elements to the classifiers independently, each (unordered) pair introduces one sample.", "labels": [], "entities": []}, {"text": "Therefore, a sentence with n scopal elements creates C(n, 2) = n(n \u2212 1)/2 samples for classification.", "labels": [], "entities": []}, {"text": "When all the elements are taken into account, 12 the total number of samples in the corpus will be: Where n i is the number of scopal terms introduced by sentence i.", "labels": [], "entities": []}, {"text": "Out of the 4500 samples, around 1800 involve at least one implicit universal (i.e., id), but only 120 samples contain a negation.", "labels": [], "entities": []}, {"text": "We evaluate the performance of the system for implicit universals and negation both separately and in the context of full scope disambiguation.", "labels": [], "entities": []}, {"text": "We split the corpus at random into three sets of 50, 100, and 350 sentences, as development, test, and train sets respectively.", "labels": [], "entities": []}, {"text": "To extract part-of-speech tags, phrase structure trees, and typed dependencies, we use the Stanford parser () on both train and test sets.", "labels": [], "entities": []}, {"text": "Since we are using SVM, we have passed the confidence levels through a softmax function to convert them into probabilities P \u03bb u,v before applying the algorithm of Section 3.", "labels": [], "entities": []}, {"text": "We take MA11's system as the baseline.", "labels": [], "entities": [{"text": "MA11", "start_pos": 8, "end_pos": 12, "type": "DATASET", "confidence": 0.9259400963783264}]}, {"text": "However, in order to have a fair comparison, we have used the output of the Stanford parser to automatically generate the same features that MA11 have hand-annotated.", "labels": [], "entities": [{"text": "MA11", "start_pos": 141, "end_pos": 145, "type": "DATASET", "confidence": 0.9258123636245728}]}, {"text": "In order to run the baseline system on implicit universals, we take the feature vector of a plural NP and add a feature to indicate that this feature vector represents the implicit universal of the corresponding chunk.", "labels": [], "entities": []}, {"text": "Similarly, for negation we add a feature to show that the chunk represents a negation.", "labels": [], "entities": [{"text": "negation", "start_pos": 15, "end_pos": 23, "type": "TASK", "confidence": 0.9583169221878052}]}, {"text": "As shown in Section 3.3.2, we have used a more compact set of features for negations.", "labels": [], "entities": []}, {"text": "Once again, in order to have a fair comparison, we apply a similar modification to the baseline system.", "labels": [], "entities": []}, {"text": "We also use the exact same classifier as used in MA11.", "labels": [], "entities": [{"text": "MA11", "start_pos": 49, "end_pos": 53, "type": "DATASET", "confidence": 0.9514394998550415}]}, {"text": "15(a) compares the performance of our model, which we refer to as RPC-SVM-13, with the baseline system, but only on explicit NP chunks.", "labels": [], "entities": []}, {"text": "The goal for running this experiment has been to compare the performance of our model to the baseline systoken, as described by.", "labels": [], "entities": []}, {"text": "In this work, we have only considered the token entity introduced by those nouns and have ignored the type entity.", "labels": [], "entities": []}, {"text": "Since the percentage of sentences with negation is small, we made sure that those sentences are distributed uniformly between three sets.", "labels": [], "entities": []}, {"text": "14 MA11's features are similar to part-of-speech tags and untyped dependency relations.", "labels": [], "entities": [{"text": "14 MA11", "start_pos": 0, "end_pos": 7, "type": "DATASET", "confidence": 0.8138146102428436}]}, {"text": "15 SV MM ulticlass from SVM-light.", "labels": [], "entities": [{"text": "SVM-light", "start_pos": 24, "end_pos": 33, "type": "DATASET", "confidence": 0.9108988642692566}]}, {"text": "In all experiments, we ignore NP conjunctions.", "labels": [], "entities": []}, {"text": "Previous work treats a conjunction of NPs as separate NPs.", "labels": [], "entities": []}, {"text": "However, similar to plurals, NP conjunctions (disjunctions) introduce an extra scopal element: a universal (existential).", "labels": [], "entities": []}, {"text": "We are working on an annotation scheme for NP conjunctions, so we have left this for after the annotations become available.", "labels": [], "entities": []}, {"text": "tem on the task that it was actually defined to perform (that is scoping only explicit NP chunks).", "labels": [], "entities": []}, {"text": "As seen in this table, by incorporating a richer set of features and a better learning algorithm, our model outperforms the baseline by almost 15%.", "labels": [], "entities": []}, {"text": "The measure A in these figures shows sentencebased accuracy.", "labels": [], "entities": [{"text": "A", "start_pos": 12, "end_pos": 13, "type": "METRIC", "confidence": 0.937328040599823}, {"text": "accuracy", "start_pos": 51, "end_pos": 59, "type": "METRIC", "confidence": 0.983123779296875}]}, {"text": "A sentence counts as correct iff every pair of scopal elements has been labeled correctly.", "labels": [], "entities": []}, {"text": "Therefore A is a tough measure.", "labels": [], "entities": [{"text": "A", "start_pos": 10, "end_pos": 11, "type": "METRIC", "confidence": 0.9965121150016785}]}, {"text": "Furthermore, it is sensitive to the length of the sentence.", "labels": [], "entities": []}, {"text": "Following MA11, we have computed another sentence-based accuracy measure, AR.", "labels": [], "entities": [{"text": "MA11", "start_pos": 10, "end_pos": 14, "type": "DATASET", "confidence": 0.8538954854011536}, {"text": "accuracy", "start_pos": 56, "end_pos": 64, "type": "METRIC", "confidence": 0.9569381475448608}, {"text": "AR", "start_pos": 74, "end_pos": 76, "type": "METRIC", "confidence": 0.9892013072967529}]}, {"text": "In computing AR, a sentence counts as correct iff all the outscoping relations have been recovered correctly -in other words, iff R = 100%, regardless of the value of P.", "labels": [], "entities": []}, {"text": "AR maybe more practically meaningful, because if in the correct scoping of the sentence there is no outscoping between two elements, inserting one does not affect the interpretation of the sentence.", "labels": [], "entities": [{"text": "AR", "start_pos": 0, "end_pos": 2, "type": "METRIC", "confidence": 0.9821385145187378}]}, {"text": "In other words, precision is less important for QSD in practice.(b) gives the performance of the overall model when all the elements including the implicit universals and the negations are taken into account.", "labels": [], "entities": [{"text": "precision", "start_pos": 16, "end_pos": 25, "type": "METRIC", "confidence": 0.9994412064552307}]}, {"text": "That the F-score of our model for the second experiment is 0.042 higher than F-score for the first indicates that scoping implicit universals and/or negations must be easier than scoping explicit NP chunks.", "labels": [], "entities": [{"text": "F-score", "start_pos": 9, "end_pos": 16, "type": "METRIC", "confidence": 0.9989017248153687}, {"text": "F-score", "start_pos": 77, "end_pos": 84, "type": "METRIC", "confidence": 0.9982361793518066}]}, {"text": "In order to find how much one or both of the two elements contribute to this gain, we have run two more experiments, scoping only the pairs with at least one implicit universal and pairs with one negation, respectively.", "labels": [], "entities": []}, {"text": "As seen, the contribution in boosting the overall performance comes from the implicit universals while negations, in fact, lower the performance.", "labels": [], "entities": []}, {"text": "The performance for pairs with implicit universal is higher because universals, in general, (b) Pairs with at least one negation: Implicit universals and negations are easier to scope, even for the human annotators.", "labels": [], "entities": []}, {"text": "There are several reasons for poor performance with negations as well.", "labels": [], "entities": [{"text": "negations", "start_pos": 52, "end_pos": 61, "type": "TASK", "confidence": 0.9531059861183167}]}, {"text": "First, the number of negations in the corpus is small, therefore the data is very sparse.", "labels": [], "entities": []}, {"text": "Second, the RPC model does notwork well for negations.", "labels": [], "entities": [{"text": "negations", "start_pos": 44, "end_pos": 53, "type": "TASK", "confidence": 0.9615991115570068}]}, {"text": "Scoping a negation relative to an NP chunk, with which it has along distance dependency, often depends on the scope of the elements in between.", "labels": [], "entities": []}, {"text": "Third, scoping negation usually requires a deep semantic analysis.", "labels": [], "entities": [{"text": "scoping negation", "start_pos": 7, "end_pos": 23, "type": "TASK", "confidence": 0.8545646965503693}]}, {"text": "In order to see how well our approximation algorithm is working, similar to the approach of, we tried an ILP solver for DAGs with at most 8 nodes to find the optimum solution, but we found the difference insignificant.", "labels": [], "entities": []}, {"text": "In fact, the approximation algorithm finds the optimum solution in all but one case.", "labels": [], "entities": []}], "tableCaptions": []}