{"title": [{"text": "Removing Left Recursion from Context-Free Grammars", "labels": [], "entities": [{"text": "Removing Left Recursion from Context-Free Grammars", "start_pos": 0, "end_pos": 50, "type": "TASK", "confidence": 0.8751479287942251}]}], "abstractContent": [{"text": "A long-standing issue regarding algorithms that manipulate context-free grammars (CFGs) in a \"top-down\" left-to-right fashion is that left recursion can lead to nontermination.", "labels": [], "entities": []}, {"text": "An algorithm is known that transforms any CFG into an equivalent non-left-recursive CFG, but the resulting grammars are often too large for practical use.", "labels": [], "entities": []}, {"text": "We present anew method for removing left recursion from CFGs that is both theoretically superior to the standard algorithm , and produces very compact non-left-recursive CFGs in practice.", "labels": [], "entities": []}, {"text": "1 Introduction A long-standing issue regarding algorithms that manipulate context-free grammars (CFGs) in a \"top-down\" left-to-right fashion is that left recursion can lead to nontermination.", "labels": [], "entities": []}, {"text": "This is most familiar in the case of top-down recursive-descent parsing (Aho et al., 1986, pp. 181-182).", "labels": [], "entities": [{"text": "top-down recursive-descent parsing", "start_pos": 37, "end_pos": 71, "type": "TASK", "confidence": 0.6155063907305399}]}, {"text": "A more recent motivation is that off-the-shelf speech recognition systems are now available (e.g., from Nuance Communications and Microsoft) that accept CFGs as language models for constraining recognition; but as these recogniz-ers process CFGs top-down, they also require that the CFGs used be non-left-recursive.", "labels": [], "entities": [{"text": "speech recognition", "start_pos": 47, "end_pos": 65, "type": "TASK", "confidence": 0.7528776228427887}]}, {"text": "The source of the problem can be seen by considering a directly left-recursive grammar production such as A-4 As.", "labels": [], "entities": []}, {"text": "Suppose we are trying to parse, or recognize using a speech recognizer, an A at a given position in the input.", "labels": [], "entities": []}, {"text": "If we apply this production top-down and left-to-right, our first subgoal will be to parse or recognize an A at the same input position.", "labels": [], "entities": []}, {"text": "This immediately puts us into an infinite recursion.", "labels": [], "entities": []}, {"text": "The same thing will happen with an indirectly left-recursive grammar, via a chain of subgoals that will lead us from the goal of parsing or recognizing an A at a given position to a descendant subgoal of parsing or recognizing an A at that position.", "labels": [], "entities": [{"text": "parsing or recognizing an A", "start_pos": 129, "end_pos": 156, "type": "TASK", "confidence": 0.8416195511817932}]}, {"text": "In theory, the restriction to non-left-recursive CFGs puts no additional constraints on the languages that can be described, because any CFG can in principle be transformed into an equivalent non-left-recursive CFG.", "labels": [], "entities": []}, {"text": "However, the standard algorithm for carrying out this transformation (Aho et al., 1986, pp. 176-178) (Hopcroft and Ullman, 1979, p. 96)-attributed to M.", "labels": [], "entities": []}, {"text": "C. Panll by Hopcroft and Ullman (1979, p. 106)-can produce transformed grammars that are orders of magnitude larger than the original grammars.", "labels": [], "entities": []}, {"text": "In this paper we develop a number of improvements to Panll's algorithm, which help somewhat but do not completely solve the problem.", "labels": [], "entities": [{"text": "Panll's algorithm", "start_pos": 53, "end_pos": 70, "type": "DATASET", "confidence": 0.8620710174242655}]}, {"text": "We then goon to develop an alternative approach based on the left-corner grammar transform, which makes it possible to remove left recursion with no significant increase in size for several grammars for which Paull's original algorithm is impractical.", "labels": [], "entities": []}, {"text": "2 Notation and Terminology Grammar nonterminals will be designated by \"low order\" upper-case letters (A, B, etc.); and terminals will be designated by lowercase letters.", "labels": [], "entities": []}, {"text": "We will use \"high order\" upper-case letters (X, Y, Z) to denote single symbols that could be either terminals or nonterminals, and Greek letters to denote (possibly empty) sequences of terminals and/or non-terminals.", "labels": [], "entities": []}, {"text": "Any production of the form A-4 a will be said to bean A-production, and a will be said to bean expansion of A.", "labels": [], "entities": []}, {"text": "We will say that a symbol X is a direct left corner of a nonterminal A, if there is an A-production with X as the left-most symbol on the right-hand side.", "labels": [], "entities": []}, {"text": "We define the left-corner relation to be the reflexive transitive closure of the direct-left-corner relation, and we define the proper-left-corner relation to be the transitive closure of the direct-left-corner relation.", "labels": [], "entities": []}, {"text": "A nonterminal is left recursive if it is a proper left corner of itself; a nonterminal is directly left re-cursive if it is a direct left corner of itself; and a nonterminal is indirectly left recursive if it is left re-cursive, but not directly left recursive.", "labels": [], "entities": []}, {"text": "3 Test Grammars We will test the algorithms considered hereon three large, independently-motivated, natural-language grammars.", "labels": [], "entities": []}, {"text": "The CT grammar 1 was compiled into a CFG from a task-specific unification grammar 1Courtesy of John Dowding, SRI International 249", "labels": [], "entities": [{"text": "Dowding, SRI International", "start_pos": 100, "end_pos": 126, "type": "DATASET", "confidence": 0.7666293829679489}]}], "introductionContent": [{"text": "A long-standing issue regarding algorithms that manipulate context-free grammars (CFGs) in a \"topdown\" left-to-right fashion is that left recursion can lead to nontermination.", "labels": [], "entities": []}, {"text": "This is most familiar in the case of top-down recursive-descent parsing (Aho et.", "labels": [], "entities": []}, {"text": "A more recent motivation is that off-the-shelf speech recognition systems are now available (e.g., from Nuance Communications and Microsoft) that accept CFGs as language models for constraining recognition; but as these recognizers process CFGs top-down, they also require that the CFGs used be non-left-recursive.", "labels": [], "entities": [{"text": "speech recognition", "start_pos": 47, "end_pos": 65, "type": "TASK", "confidence": 0.7545506656169891}]}, {"text": "The source of the problem can be seen by considering a directly left-recursive grammar production such as A -4 As.", "labels": [], "entities": []}, {"text": "Suppose we are trying to parse, or recognize using a speech recognizer, an A at a given position in the input.", "labels": [], "entities": []}, {"text": "If we apply this production top-down and left-to-right, our first subgoal will be to parse or recognize an A at the same input position.", "labels": [], "entities": []}, {"text": "This immediately puts us into an infinite recursion.", "labels": [], "entities": []}, {"text": "The same thing will happen with an indirectly left-recursive grammar, via a chain of subgoals that will lead us from the goal of parsing or recognizing an A at a given position to a descendant subgoal of parsing or recognizing an A at that position.", "labels": [], "entities": [{"text": "parsing or recognizing an A", "start_pos": 129, "end_pos": 156, "type": "TASK", "confidence": 0.8416195511817932}]}, {"text": "In theory, the restriction to non-left-recursive CFGs puts no additional constraints on the languages that can be described, because any CFG can in principle be transformed into an equivalent non-left-recursive CFG.", "labels": [], "entities": []}, {"text": "However, the standard algorithm for carrying out this transformation (), p.", "labels": [], "entities": []}, {"text": "96)--attributed to M.", "labels": [], "entities": []}, {"text": "C. Panll by)--can produce transformed grammars that are orders of magnitude larger than the original grammars.", "labels": [], "entities": [{"text": "Panll", "start_pos": 3, "end_pos": 8, "type": "DATASET", "confidence": 0.9107281565666199}]}, {"text": "In this paper we develop a number of improvements to Panll's algorithm, which help somewhat but do not completely solve the problem.", "labels": [], "entities": [{"text": "Panll's algorithm", "start_pos": 53, "end_pos": 70, "type": "DATASET", "confidence": 0.8620710174242655}]}, {"text": "We then goon to develop an alternative approach based on the left-corner grammar transform, which makes it possible to remove left recursion with no significant increase in size for several grammars for which Paull's original algorithm is impractical.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": [{"text": " Table 1: Grammars used for evaluation.", "labels": [], "entities": []}, {"text": " Table 3: Grammar size comparisons with Panll's algorithm variants", "labels": [], "entities": []}, {"text": " Table 4: Grammar size comparisons for LC transform variants", "labels": [], "entities": []}]}