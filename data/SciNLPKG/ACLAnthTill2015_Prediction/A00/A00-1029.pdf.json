{"title": [{"text": "A Tool for Automated Revision of Grammars for NLP Systems", "labels": [], "entities": [{"text": "Automated Revision of Grammars", "start_pos": 11, "end_pos": 41, "type": "TASK", "confidence": 0.7910363301634789}]}], "abstractContent": [{"text": "We present an algorithm and a tool for automatically revising grammars for natural language processing (NLP) systems to disallow specifically identified sentences or sets of sentences.", "labels": [], "entities": []}, {"text": "We also outline an approach for automatically revising attribute value grammars using counterexamples.", "labels": [], "entities": []}, {"text": "Developing grammars for NLP systems that are both general enough to accept most sentences about a domain, but constrained enough to disallow other sentences is very tedious.", "labels": [], "entities": []}, {"text": "Our approach of revising grammars automatically using counterexamples greatly simplifies the development and revision of tightly constrained grammars.", "labels": [], "entities": []}, {"text": "We have successfully used our tool to constrain over-generalizing grammars of speech understanding systems and obtained higher recognition accuracy.", "labels": [], "entities": [{"text": "accuracy", "start_pos": 139, "end_pos": 147, "type": "METRIC", "confidence": 0.9761547446250916}]}], "introductionContent": [{"text": "Natural language processing systems often constrain the set of \"utterances\" from a user (spoken, typed in, etc.) to narrow down the possible syntactic and semantic resolutions of the utterance and reduce the number of misrecognitions and/or misunderstandings by the system.", "labels": [], "entities": []}, {"text": "Such constraints on the allowed syntax and the inferred semantics are often expressed in the form of a \"grammar \"l, a set of Throughout this document, by using the word \"grammar\", we refer to a Context-Free Grammar that consists of a finite set of non-terminals, a finite set of terminals, a unique non-terminal called the start symbol, and a set of production rules of the form A-> a, where A is a non-terminal and a is a string of terminal or non-terminal symbols.", "labels": [], "entities": []}, {"text": "The 'language' rules specifying the set of allowed utterances and possibly also specifying the semantics associated with these utterances.", "labels": [], "entities": []}, {"text": "For instance, grammars are commonly used in speech understanding systems to specify both the set of allowed sentences and to specify \"tags\" to extract semantic entities (e.g. the \"amount\" of money).", "labels": [], "entities": [{"text": "speech understanding", "start_pos": 44, "end_pos": 64, "type": "TASK", "confidence": 0.7338603734970093}]}, {"text": "Constraining the number of sentences accepted by a grammar is essential for reducing misinterpretations of user queries by an NLP system.", "labels": [], "entities": []}, {"text": "For instance, for speech understanding systems, if the grammar accepts a large number of sentences, then the likelihood of recognizing uttered sentences as random, irrelevant, or undesirable sentences is increased.", "labels": [], "entities": [{"text": "speech understanding", "start_pos": 18, "end_pos": 38, "type": "TASK", "confidence": 0.7033451944589615}]}, {"text": "For transaction processing systems, misrecognized words can lead to unintended transactions being processed.", "labels": [], "entities": []}, {"text": "An effective constraining grammar can reduce transactional errors by limiting the number of sentence level errors.", "labels": [], "entities": []}, {"text": "The problem of over-generalization of speech grammars and related issues is well discussed by.", "labels": [], "entities": []}, {"text": "Thus, speech grammars must often balance the conflicting requirements of \u2022 accepting a wide variety of sentences to increase flexibility, and \u2022 accepting a small number of sentences to increase system accuracy and robustness.", "labels": [], "entities": [{"text": "flexibility", "start_pos": 125, "end_pos": 136, "type": "METRIC", "confidence": 0.967538058757782}, {"text": "accuracy", "start_pos": 201, "end_pos": 209, "type": "METRIC", "confidence": 0.9783274531364441}]}, {"text": "Developing tight grammars which trade-off these conflicting constraints is a tedious and accepted by a grammar is the set of all terminal strings that can be generated from the start symbol by successive application of the production rules.", "labels": [], "entities": []}, {"text": "The grammar may optionally have semantic interpretation rules associated with each production rule (e.g. see (Allen 95)).", "labels": [], "entities": []}, {"text": "Typically, grammars overgeneralize and accept too many sentences that are irrelevant or undesirable fora given application.", "labels": [], "entities": []}, {"text": "We call such sentences \"counterexamples\".", "labels": [], "entities": []}, {"text": "The problem is usually handled by revising the grammar manually to disallow such counter-examples.", "labels": [], "entities": []}, {"text": "For instance, the sentence \"give me my last eighteen transactions\" may need to be excluded from a grammar fora speech understanding system, since the words \"eighteen\" and \"ATM\" are easily confused by the speech recogniser.", "labels": [], "entities": []}, {"text": "However, \"five\" and \"ten\" should remain as possible modifiers of \"transactions\".", "labels": [], "entities": []}, {"text": "Counter-examples can also be sets of sentences that need to be excluded from a grammar (specified by allowing the inclusion of non-terminals in counter-examples).", "labels": [], "entities": []}, {"text": "For example, fora banking application that disallows money transfers to online accounts, we might wish to exclude the set of sentences \"transfer <AMOUNT> dollars to my online account\" from the grammar, where <AMOUNT> is a non-terminal in the grammar that maps to all possible ways of specifying amounts.", "labels": [], "entities": []}, {"text": "In this paper, we are proposing techniques for automatically revising grammars using counterexamples.", "labels": [], "entities": []}, {"text": "The grammar developer identifies counter-examples from among sentences (or sets of sentences) mis-recognized by the speech recognizer or from sentences randomly generated by a sentence generator using the original grammar.", "labels": [], "entities": []}, {"text": "The grammar reviser modifies the original grammar to invalidate the counterexamples.", "labels": [], "entities": []}, {"text": "The revised grammar can be fed back to the grammar reviser and whole process can be iterated several times until the resulting grammar is deemed satisfactory.", "labels": [], "entities": []}, {"text": "In the next sections, we first describe our algorithm for revising grammars to disallow counter-examples.", "labels": [], "entities": []}, {"text": "We also discuss algorithms to make the revised grammar compact using minimum description length (MDL) based grammar compaction techniques and extensions to our basic algorithm to handle grammars with recursion.", "labels": [], "entities": []}, {"text": "We then present some results of applying our grammar reviser tool to constrain speech grammars of speech understanding systems.", "labels": [], "entities": []}, {"text": "Finally, we present an approach for revising attribute value grammars using our technique and present our conclusions.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": []}