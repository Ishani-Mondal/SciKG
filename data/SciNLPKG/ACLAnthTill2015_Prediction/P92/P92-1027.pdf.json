{"title": [{"text": "A UNIFICATION-BASED SEMANTIC INTERPRETATION FOR COORDINATE CONSTRUCTS", "labels": [], "entities": [{"text": "A UNIFICATION-BASED SEMANTIC INTERPRETATION FOR COORDINATE CONSTRUCTS", "start_pos": 0, "end_pos": 69, "type": "METRIC", "confidence": 0.6514487479414258}]}], "abstractContent": [{"text": "This paper shows that a first-order unification-based semantic interpretation for various coordinate constructs is possible without an explicit use of lambda expressions if we slightly modify the standard Montagovian semantics of coordination.", "labels": [], "entities": [{"text": "unification-based semantic interpretation", "start_pos": 36, "end_pos": 77, "type": "TASK", "confidence": 0.6237659553686777}]}, {"text": "This modification, along with partial execution, completely eliminates the lambda reduction steps during semantic interpretation.", "labels": [], "entities": [{"text": "semantic interpretation", "start_pos": 105, "end_pos": 128, "type": "TASK", "confidence": 0.7419377863407135}]}], "introductionContent": [{"text": "Combinatory Categorial Grammar (CCG) has been offered as a theory of coordination in natural language (Steedman).", "labels": [], "entities": [{"text": "Combinatory Categorial Grammar (CCG)", "start_pos": 0, "end_pos": 36, "type": "TASK", "confidence": 0.7696559578180313}]}, {"text": "It has usually been implemented in languages based on first order unification.", "labels": [], "entities": [{"text": "first order unification", "start_pos": 54, "end_pos": 77, "type": "TASK", "confidence": 0.6409729421138763}]}, {"text": "Moore however has pointed out that coordination presents problems for firstorder unification-based semantic interpretation.", "labels": [], "entities": [{"text": "firstorder unification-based semantic interpretation", "start_pos": 70, "end_pos": 122, "type": "TASK", "confidence": 0.8302935063838959}]}, {"text": "We show that it is possible to get over the problem by compiling the lambda reduction steps that are associated with coordination in the lexicon.", "labels": [], "entities": []}, {"text": "We show how our first-order unification handles the following examples of coordinate constructs.", "labels": [], "entities": []}, {"text": "(1.5) Mary gives every dog a bone and some policeman a flower.", "labels": [], "entities": []}, {"text": "We will first start with an illustration of why standard Montagovian semantics of coordination cannot be immediately rendered into a first-order 209 unification strategy.", "labels": [], "entities": []}, {"text": "The lexicon must contain multiple entries for the single lexical item \"and\", since only like categories are supposed to conjoin.", "labels": [], "entities": []}, {"text": "For example, the lexical entry for \"and\" in (1.1) specifies the constraint that the lexical item should expect on both sides sentences to give a sentence.", "labels": [], "entities": []}, {"text": "Moore predicts that a unification-based semantic interpretation for sentences which involve for example noun phrase coordination won't be possible without an explicit use of lambda expressions, though there are cases where some lambda expressions can be eliminated by directly assigning values to variables embedded in a logical-form expression.", "labels": [], "entities": [{"text": "unification-based semantic interpretation", "start_pos": 22, "end_pos": 63, "type": "TASK", "confidence": 0.8550579150517782}]}, {"text": "The problematic example is shown in (1.6), where proper noun subjects are conjoined.", "labels": [], "entities": []}, {"text": "(1.6) john and bill walk.", "labels": [], "entities": []}, {"text": "The argument is that if we do not change the semantics of \"john\" from j to AP.P(j), where P is a second order variable for property in the Montagovian sense 1 , then the single predicate AX.", "labels": [], "entities": []}, {"text": "walk(X) should accommodate two different constants j and bin a single variable X at the same time.", "labels": [], "entities": []}, {"text": "Since the unification simply blocks in this case, the argument goes, we need to use higher order lambda expressions such as AP.P(j) or AP.P(b), which when conjoined together, will yield semantics for e.g. \"john and bill\" as ,~P.(P(j) ~ P(b)) . Combined finally with the predicate, this will result in the semantics (1.7), after lambda reduction.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": []}