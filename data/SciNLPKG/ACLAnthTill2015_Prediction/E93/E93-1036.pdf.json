{"title": [], "abstractContent": [{"text": "We show how techniques known from gen-erMized LR parsing can be applied to left-corner parsing.", "labels": [], "entities": [{"text": "LR parsing", "start_pos": 46, "end_pos": 56, "type": "TASK", "confidence": 0.4879457801580429}]}, {"text": "The ~esulting parsing algorithm for context-free grammars has some advantages over generalized LR parsing: the sizes and generation times of the parsers are smaller, the produced output is more compact, and the basic parsing technique can more easily be adapted to arbitrary context-free grammars.", "labels": [], "entities": [{"text": "LR parsing", "start_pos": 95, "end_pos": 105, "type": "TASK", "confidence": 0.6779947429895401}]}, {"text": "The algorithm can be seen as an optimization of algorithms known from existing literature.", "labels": [], "entities": []}, {"text": "A strong advantage of our presentation is that it makes explicit the role of left-corner parsing in these algorithms.", "labels": [], "entities": []}], "introductionContent": [{"text": "Generalized LR parsing was first described by Tomita.", "labels": [], "entities": [{"text": "LR parsing", "start_pos": 12, "end_pos": 22, "type": "TASK", "confidence": 0.7480435371398926}]}, {"text": "It has been regarded as the most efficient parsing technique for context-free grammars.", "labels": [], "entities": []}, {"text": "The technique has been adapted to other formalisms than context-free grammars in.", "labels": [], "entities": []}, {"text": "A useful property of generalized LR parsing (henceforth abbreviated to GLR parsing) is that input is parsed in polynomial time.", "labels": [], "entities": [{"text": "LR parsing", "start_pos": 33, "end_pos": 43, "type": "TASK", "confidence": 0.7460848987102509}, {"text": "GLR parsing)", "start_pos": 71, "end_pos": 83, "type": "TASK", "confidence": 0.7702047228813171}]}, {"text": "To be exact, if the length of the right side of the longest rule is p, and if the length of the input is n, then the time complexity is O(nP+l).", "labels": [], "entities": [{"text": "O", "start_pos": 136, "end_pos": 137, "type": "METRIC", "confidence": 0.9746832847595215}]}, {"text": "Theoretically, this maybe worse *Supported by the Dutch Organization for Scientific Research (NWO), under grant 00-62-518 than the time complexity of Earley's algorithm, which is O(n3).", "labels": [], "entities": []}, {"text": "For practical cases in natural language processing however, GLR parsing seems to give the best results.", "labels": [], "entities": [{"text": "GLR parsing", "start_pos": 60, "end_pos": 71, "type": "TASK", "confidence": 0.8837757408618927}]}, {"text": "The polynomial time complexity is established by using a graph-structured stack, which is a generalization of the notion of parse stack, in which pointers are used to connect stack elements.", "labels": [], "entities": []}, {"text": "If nondeterminism occurs, then the search paths are investigated simultaneously, where the initial part of the parse stack which is common to all search paths is represented only once.", "labels": [], "entities": []}, {"text": "If two search paths share the state of the top elements of their imaginary individual parse stacks, then the top element is represented only once, so that any computation which thereupon pushes elements onto the stack is performed only once.", "labels": [], "entities": []}, {"text": "Another useful property of GLR parsing is that the output is a concise representation of all possible parses, the so called parse forest, which can be seen as a generalization of the notion of parse tree.", "labels": [], "entities": [{"text": "GLR parsing", "start_pos": 27, "end_pos": 38, "type": "TASK", "confidence": 0.8586339056491852}]}, {"text": "(By some authors, parse forests are more specifically called shared, shared-packed, or packed shared forests.)", "labels": [], "entities": []}, {"text": "The parse forests produced by the Mgorithm can be represented using O(n p+I) space.", "labels": [], "entities": [{"text": "Mgorithm", "start_pos": 34, "end_pos": 42, "type": "DATASET", "confidence": 0.9144587516784668}]}, {"text": "Efficient decoration of parse forests with attribute values has been investigated in.", "labels": [], "entities": []}, {"text": "There are however some drawbacks to GLR parsing.", "labels": [], "entities": [{"text": "GLR parsing", "start_pos": 36, "end_pos": 47, "type": "TASK", "confidence": 0.8949176669120789}]}, {"text": "In order of decreasing importance, these are: \u2022 The parsing technique is based on the use of LR tables, which maybe very large for grammars describing natural languages.", "labels": [], "entities": [{"text": "parsing", "start_pos": 52, "end_pos": 59, "type": "TASK", "confidence": 0.9706754088401794}]}, {"text": "1 Related to this is the large amount of time needed to construct l argues that grammars for programruing languages require LR tables which have a size which is about linear in the size of the grammar.", "labels": [], "entities": []}, {"text": "It is generally considered doubtful that similar observations can be made for grammars for natural languages.", "labels": [], "entities": []}, {"text": "Incremental construction of parsers may in some cases alleviate this problem.", "labels": [], "entities": []}, {"text": "\u2022 The parse forests produced by the algorithm are not as compact as they might be.", "labels": [], "entities": []}, {"text": "This is because packing of subtrees is guided by the merging of search paths due to equal LR states, instead of by the equality of the derived nonterminals.", "labels": [], "entities": []}, {"text": "The solution presented in implies much computational overhead.", "labels": [], "entities": []}, {"text": "\u2022 Adapting the technique to arbitrary grammars requires the generalization to cyclic graphstructured stacks, which may complicate the implementation.", "labels": [], "entities": []}, {"text": "\u2022 A minor disadvantage is that the theoretical time complexity worsens if p becomes larger.", "labels": [], "entities": []}, {"text": "The solution given in to obtain a variant of the parsing technique which has a fixed time complexity of O(n3), independent of p, implies an overhead in computation costs which worsens instead of improves the time complexity in practical cases.", "labels": [], "entities": [{"text": "parsing", "start_pos": 49, "end_pos": 56, "type": "TASK", "confidence": 0.9728662967681885}, {"text": "O", "start_pos": 104, "end_pos": 105, "type": "METRIC", "confidence": 0.9766225814819336}]}, {"text": "These disadvantages of generalized LR parsing are mainly consequences of the LR parsing technique, more than consequences of the use of graphstructured stacks and parse forests.", "labels": [], "entities": [{"text": "LR parsing", "start_pos": 35, "end_pos": 45, "type": "TASK", "confidence": 0.5094686150550842}, {"text": "LR parsing", "start_pos": 77, "end_pos": 87, "type": "TASK", "confidence": 0.6650149822235107}]}, {"text": "Lang gives a general construction of deterministic parsing algorithms from nondeterministic push-down automata.", "labels": [], "entities": []}, {"text": "The produced data structures have a strong similarity to parse forests, as argued in.", "labels": [], "entities": []}, {"text": "The general idea of Lang has been applied to other formalisms than context-free grammars in.", "labels": [], "entities": []}, {"text": "The idea of a graph-structured stack, however, does not immediately follow from Lang's construction.", "labels": [], "entities": []}, {"text": "Instead, One of the parsing techniques which can with some minor difficulties be derived from the construction of Lang is generalized left-corner parsing (henceforth abbreviated to GLC parsing).", "labels": [], "entities": [{"text": "parsing", "start_pos": 20, "end_pos": 27, "type": "TASK", "confidence": 0.9742986559867859}]}, {"text": "3 The starting-point is left-corner parsing, which was first formally defined in [Rosenkrantz and.", "labels": [], "entities": [{"text": "left-corner parsing", "start_pos": 24, "end_pos": 43, "type": "TASK", "confidence": 0.6190020889043808}]}, {"text": "Generalized left-corner parsing, albeit under a different name, has first been investigated in 2 argues that the way in which the table is implemented (using a two-dimensional matrix as in case of Earley's algorithm or using a graph-structured stack) is only of secondary importance to the global behaviour of the parsing algorithm.", "labels": [], "entities": []}, {"text": "3The term \"generalized left-corner parsing\" has been used before in fora different parsing technique.", "labels": [], "entities": [{"text": "generalized left-corner parsing", "start_pos": 11, "end_pos": 42, "type": "TASK", "confidence": 0.5949240724245707}]}, {"text": "Demers generalizes \"left corner of aright side\" to be a prefix of aright side which does not necessarily consist of one member, whereas we generalize LG parsing with zero lookahead to grammars which are not.", "labels": [], "entities": [{"text": "LG parsing", "start_pos": 150, "end_pos": 160, "type": "TASK", "confidence": 0.6424779295921326}]}, {"text": "In it was shown that the parsing technique can be a serious rival to generalized LR parsing with regard to the time complexities.", "labels": [], "entities": [{"text": "parsing", "start_pos": 25, "end_pos": 32, "type": "TASK", "confidence": 0.9854385852813721}, {"text": "LR parsing", "start_pos": 81, "end_pos": 91, "type": "TASK", "confidence": 0.702583447098732}]}, {"text": "(Other papers discussing the time complexity of GLC parsing are.)", "labels": [], "entities": [{"text": "GLC parsing", "start_pos": 48, "end_pos": 59, "type": "TASK", "confidence": 0.9229702651500702}]}, {"text": "A functional variant of GLC parsing for definite clause grammars has been discussed in.", "labels": [], "entities": [{"text": "GLC parsing for definite clause grammars", "start_pos": 24, "end_pos": 64, "type": "TASK", "confidence": 0.7013670206069946}]}, {"text": "This algorithm does not achieve a polynomial time complexity however, because no \"packing\" takes place.", "labels": [], "entities": []}, {"text": "A variant of Earley's algorithm discussed in also is very similar to GLC parsing although the top-down nature of Earley's algorithm is preserved.", "labels": [], "entities": [{"text": "GLC parsing", "start_pos": 69, "end_pos": 80, "type": "TASK", "confidence": 0.7026109993457794}]}, {"text": "GLC parsin~ has been rediscovered a number of times (e.g. in,, and), but without any mention of the connection with LC parsing, which made the presentations unnecessarily difficult to understand.", "labels": [], "entities": [{"text": "LC parsing", "start_pos": 116, "end_pos": 126, "type": "TASK", "confidence": 0.6723538637161255}]}, {"text": "This also prevented discovery of a number of optimizations which are obvious from the viewpoint of left-corner parsing.", "labels": [], "entities": []}, {"text": "In this paper we reinvestigate GLC parsing in combination with graph-structured stacks and parse forests.", "labels": [], "entities": [{"text": "GLC parsing", "start_pos": 31, "end_pos": 42, "type": "TASK", "confidence": 0.9100479185581207}]}, {"text": "It is shown that this parsing technique is not subject to the four disadvantages of the algorithm of Tomita.", "labels": [], "entities": [{"text": "parsing", "start_pos": 22, "end_pos": 29, "type": "TASK", "confidence": 0.9768099188804626}]}, {"text": "The structure of this paper is as follows.", "labels": [], "entities": []}, {"text": "In Section 2 we explain nondeterministic LC parsing.", "labels": [], "entities": [{"text": "LC parsing", "start_pos": 41, "end_pos": 51, "type": "TASK", "confidence": 0.699514776468277}]}, {"text": "This parsing algorithm is the starting-point of Section 3, which shows how a deterministic algorithm can be defined which uses a graph-structured stack and produces parse forests.", "labels": [], "entities": [{"text": "parsing", "start_pos": 5, "end_pos": 12, "type": "TASK", "confidence": 0.9654077887535095}]}, {"text": "Section 4 discusses how this generalized LC parsing algorithm can be adapted to arbitrary context-free grammars.", "labels": [], "entities": [{"text": "LC parsing", "start_pos": 41, "end_pos": 51, "type": "TASK", "confidence": 0.7409631609916687}]}, {"text": "How the algorithm can be improved to operate in cubic time is shown in Section 5.", "labels": [], "entities": []}, {"text": "The improved algorithm produces parse forests in a non-standard representation, which requires only cubic space.", "labels": [], "entities": []}, {"text": "One more class of optimizations is discussed in Section 6.", "labels": [], "entities": []}, {"text": "Preliminary results with an implementation of our algorithm are discussed in Section 7. 2 Left-corner parsing Before we define LC parsing, we first define some notions strongly connected with this kind of parsing.", "labels": [], "entities": [{"text": "Left-corner parsing", "start_pos": 90, "end_pos": 109, "type": "TASK", "confidence": 0.6638031750917435}, {"text": "LC parsing", "start_pos": 127, "end_pos": 137, "type": "TASK", "confidence": 0.7644081711769104}]}, {"text": "We define a spine to be a path in a parse tree which begins at some node which is not the first son of its father (or which does not have a father), then proceeds downwards every time taking the leftmost son, and finally ends in a leaf.", "labels": [], "entities": []}, {"text": "We define the relation / between nonterminals such that B / A if and only if there is a rule A --* Ba, where a denotes some sequence of grammar symbols.", "labels": [], "entities": []}, {"text": "The transitive and reflexive closure of / is denoted by L*, which is called the left-corner relation.", "labels": [], "entities": []}, {"text": "Informally, we have that B/* A if and only if it is possible to have a spine in some parse tree in which B occurs below A (or 13 = A).", "labels": [], "entities": []}, {"text": "We pronounce B Z* A as \"B is a left corner of A\".", "labels": [], "entities": [{"text": "B Z* A", "start_pos": 13, "end_pos": 19, "type": "METRIC", "confidence": 0.8708551228046417}]}, {"text": "We define the set GOAL to be the set consisting of S, the start symbol, and of all nonterminals A which occur in a rule of the form B--* t~ A fl where is note (the empty sequence of grammar symbols).", "labels": [], "entities": [{"text": "GOAL", "start_pos": 18, "end_pos": 22, "type": "METRIC", "confidence": 0.8762767910957336}]}, {"text": "Informally, a nonterminal is in GOAL if and only if it may occur at the first node of some spine.", "labels": [], "entities": [{"text": "GOAL", "start_pos": 32, "end_pos": 36, "type": "METRIC", "confidence": 0.48247402906417847}]}, {"text": "We explain LC parsing by means of the small context-free grammar below.", "labels": [], "entities": [{"text": "LC parsing", "start_pos": 11, "end_pos": 21, "type": "TASK", "confidence": 0.8969866037368774}]}, {"text": "No claims are made about the linguistic relevance of this grammar.", "labels": [], "entities": []}, {"text": "Note that we have transformed lexieal ambiguity into grammatical ambiguity by introducing the nonterminals VorN and VorP.", "labels": [], "entities": []}, {"text": "The algorithm reads the input from left to right.", "labels": [], "entities": []}, {"text": "The elements on the parse stack are either nonterminals (the goal elements) or items (the item elements).", "labels": [], "entities": []}, {"text": "Items consist of a rule in which a dot has been inserted somewhere in the right side to separate the members which have been recognized from those which have not.", "labels": [], "entities": []}, {"text": "Initially, the parse stack consists only of the start symbol, which is the first goal, as indicate in Figure 1.", "labels": [], "entities": []}, {"text": "The indicated parse corresponds with one of the two possible readings of \"time flies like an arrow\" according to the grammar above.", "labels": [], "entities": []}, {"text": "We define a nondeterministic LC parser by the parsing steps which are possible according to the following clauses: la.", "labels": [], "entities": []}, {"text": "If the element on top of the stack is the nonterminal A and if the first symbol of the remaining input is t, then we may remove t from the input and push an item 6.", "labels": [], "entities": []}, {"text": "If the stack consists only of the two elements S [S--* a .] and if the input has been completely read, then we may successfully terminate the parsing process.", "labels": [], "entities": []}, {"text": "Note that only nonterminals from GOAL will occur as separate elements on the stack.", "labels": [], "entities": [{"text": "GOAL", "start_pos": 33, "end_pos": 37, "type": "DATASET", "confidence": 0.47294098138809204}]}, {"text": "The nondeterministie LC parsing algorithm defined above uses one symbol of lookahead in case of terminal left corners.", "labels": [], "entities": [{"text": "nondeterministie LC parsing", "start_pos": 4, "end_pos": 31, "type": "TASK", "confidence": 0.5843302806218466}]}, {"text": "The algorithm is therefore deterministic for the LC(0) grammars, according to the definition of LC(k) grammars in.", "labels": [], "entities": []}, {"text": "(This definition is incompatible with that of.)", "labels": [], "entities": []}, {"text": "The exact formulation of the algorithm above is chosen to simplify the treatment of generalized LC parsing in the next section.", "labels": [], "entities": [{"text": "LC parsing", "start_pos": 96, "end_pos": 106, "type": "TASK", "confidence": 0.6408508270978928}]}, {"text": "The strict separation between goal elements and item elements has also been achieved in, as opposed to.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": []}