{"title": [{"text": "A Strategy for Dynamic Interpretation: a Fragment and an Implementation", "labels": [], "entities": [{"text": "Implementation", "start_pos": 57, "end_pos": 71, "type": "TASK", "confidence": 0.48778101801872253}]}], "abstractContent": [{"text": "The strategy for natural language interpretation presented in this paper implements the dynamics of context change by translating natural language texts into a meaning representation language consisting of (de-scriptions of) programs, in the spirit of dynamic predicate logic (DPL) [5].", "labels": [], "entities": [{"text": "natural language interpretation", "start_pos": 17, "end_pos": 48, "type": "TASK", "confidence": 0.6521547238032023}]}, {"text": "The difference with DPL is that the usual DPL semantics is replaced by an error state semantics [2].", "labels": [], "entities": []}, {"text": "This allows for the treatment of unbound anaphors, as in DPL, but also of presuppositions and presupposition projection.", "labels": [], "entities": [{"text": "presupposition projection", "start_pos": 94, "end_pos": 119, "type": "TASK", "confidence": 0.6674642413854599}]}, {"text": "The use of this dynamic interpretation strategy is demonstrated in an implementation of a small fragment of natural language which handles unbound pronoun antecedent links, where it is assumed that the intended links are indicated in the input string, and uniqueness presuppositions of definite descriptions.", "labels": [], "entities": []}, {"text": "The implementation consists of a syntax module which outputs parse trees, a semantic module mapping parse trees to DPL representations, a representation processor which determines truth conditions, falsity conditions and presuppo-sition failure conditions, and an evaluator of these conditions in a database model.", "labels": [], "entities": []}, {"text": "The implementation uses the logic programming language GSdel [6], an experimental successor of Prolog, with similar functionality and expressiveness, but with an improved declarative semantics.", "labels": [], "entities": []}], "introductionContent": [], "datasetContent": [{"text": "The intermediate language QDL allows us to translate DPL programs into formulas of FOL.", "labels": [], "entities": [{"text": "FOL", "start_pos": 83, "end_pos": 86, "type": "DATASET", "confidence": 0.8819354772567749}]}, {"text": "These are then evaluated in a database model, i.e., a first order model which is implemented as a G6del database (a G6del program).", "labels": [], "entities": []}, {"text": "There we have a so-cMled metamodule Evaluation and an object program Logic Database, and the meta-program manipulates the object program.", "labels": [], "entities": []}, {"text": "We translate first order conditions into G6del goals, and then apply the goal to the object G6del program, using the possibilities of metaprogramming offered by G6del.", "labels": [], "entities": []}, {"text": "In ordinary Prolog, these things could also be done, but they would look much less elegant.", "labels": [], "entities": []}, {"text": "% Top must be defined in every model.", "labels": [], "entities": []}], "tableCaptions": []}