{"title": [{"text": "Using linguistic principles to recover empty categories", "labels": [], "entities": []}], "abstractContent": [{"text": "This paper describes an algorithm for detecting empty nodes in the Penn Treebank (Marcus et al., 1993), finding their antecedents, and assigning them function tags, without access to lexical information such as valency.", "labels": [], "entities": [{"text": "Penn Treebank", "start_pos": 67, "end_pos": 80, "type": "DATASET", "confidence": 0.9833716452121735}]}, {"text": "Unlike previous approaches to this task, the current method is not corpus-based, but rather makes use of the principles of early Government-Binding theory (Chomsky, 1981), the syntactic theory that underlies the annotation.", "labels": [], "entities": []}, {"text": "Using the evaluation metric proposed by Johnson (2002), this approach outperforms previously published approaches on both detection of empty categories and antecedent identification, given either annotated input stripped of empty categories or the output of a parser.", "labels": [], "entities": [{"text": "antecedent identification", "start_pos": 156, "end_pos": 181, "type": "TASK", "confidence": 0.7392920851707458}]}, {"text": "Some problems with this evaluation metric are noted and an alternative is proposed along with the results.", "labels": [], "entities": []}, {"text": "The paper considers the reasons a principle-based approach to this problem should outperform corpus-based approaches, and speculates on the possibility of a hybrid approach.", "labels": [], "entities": []}], "introductionContent": [{"text": "Many recent approaches to parsing (e.g.) have focused on labeled bracketing of the input string, ignoring aspects of structure that are not reflected in the string, such as phonetically null elements and long-distance dependencies, many of which provide important semantic information such as predicate-argument structure.", "labels": [], "entities": [{"text": "parsing", "start_pos": 26, "end_pos": 33, "type": "TASK", "confidence": 0.9649179577827454}, {"text": "labeled bracketing of the input string", "start_pos": 57, "end_pos": 95, "type": "TASK", "confidence": 0.8132315079371134}]}, {"text": "In the Penn Treebank (), null elements, or empty categories, are used to indicate non-local dependencies, discontinuous constituents, and certain missing elements.", "labels": [], "entities": [{"text": "Penn Treebank", "start_pos": 7, "end_pos": 20, "type": "DATASET", "confidence": 0.9925240576267242}]}, {"text": "Empty categories are coindexed with their antecedents in the same sentence.", "labels": [], "entities": []}, {"text": "In addition, if anode has a particular grammatical function (such as subject) or semantic role (such as location), it has a function tag indicating that role; empty categories may also have function tags.", "labels": [], "entities": []}, {"text": "Thus in the sentence below, who is coindexed with the empty category *T* in the embedded S; the function tag SBJ indicates that this empty category is the subject of that S: [ WHNP-1 who] NP want [ S [ NP-SBJ-1 *T*] to VP] Empty categories, with coindexation and function tags, allow a transparent reconstruction of predicate-argument structure not available from a simple bracketed string.", "labels": [], "entities": []}, {"text": "In addition to bracketing the input string, a fully adequate syntactic analyzer should also locate empty categories in the parse tree, identify their antecedents, if any, and assign them appropriate function tags.", "labels": [], "entities": []}, {"text": "State-of-the-art statistical parsers (e.g.) typically provide a labeled bracketing only; i.e., a parse tree without empty categories.", "labels": [], "entities": []}, {"text": "This paper describes an algorithm for inserting empty categories in such impoverished trees, coindexing them with their antecedents, and assigning them function tags.", "labels": [], "entities": []}, {"text": "This is the first approach to include function tag assignment as part of the more general task of empty category recovery.", "labels": [], "entities": [{"text": "function tag assignment", "start_pos": 38, "end_pos": 61, "type": "TASK", "confidence": 0.7578386267026266}, {"text": "empty category recovery", "start_pos": 98, "end_pos": 121, "type": "TASK", "confidence": 0.6355101267496744}]}, {"text": "Previous approaches to the problem) have all been learning-based; the primary difference between the present algorithm and earlier ones is that it is not learned, but explicitly incorporates principles of GovernmentBinding theory, since that theory underlies the annotation.", "labels": [], "entities": []}, {"text": "The absence of rulebased approaches up until now is not motivated by the failure of such approaches in this domain; on the contrary, no one seems to have tried a rulebased approach to this problem.", "labels": [], "entities": []}, {"text": "Instead it appears that there is an understandable predisposition against rule-based approaches, given the fact that data-driven, especially machine-learning, approaches have worked so much better in many other domains.", "labels": [], "entities": []}, {"text": "Empty categories however seem different, in that, for the most part, their location and existence is determined, not by observable data, but by explicitly constructed linguistic principles, which were consciously used in the annotation; i.e., unlike overt words and phrases, which correspond to actual strings in the data, empty categories are in the data only because linguists doing the annotation put them there.", "labels": [], "entities": []}, {"text": "This paper therefore explores a rule-based approach to empty category recovery, with two purposes in mind: first, to explore the limits of such an approach; and second, to establish a more realistic baseline for future (possibly data-driven or hybrid) approaches.", "labels": [], "entities": [{"text": "empty category recovery", "start_pos": 55, "end_pos": 78, "type": "TASK", "confidence": 0.7232020894686381}]}, {"text": "Although it does not seem likely that any application trying to glean semantic information from a parse tree would care about the exact string position of an empty category, the algorithm described here does try to insert empty categories in the correct position in the string.", "labels": [], "entities": []}, {"text": "The main reason for this is to facilitate comparison with previous approaches to the problem, which evaluate accuracy by including such information.", "labels": [], "entities": [{"text": "accuracy", "start_pos": 109, "end_pos": 117, "type": "METRIC", "confidence": 0.9982399940490723}]}, {"text": "In Section 5, however, a revised evaluation metric is proposed that does not depend on string position per se.", "labels": [], "entities": []}, {"text": "Before proceeding, a note on terminology is in order.", "labels": [], "entities": []}, {"text": "I use the term detection (of empty categories) for the insertion of a labeled empty category into the tree (and/or string), and the term resolution for the coindexation of the empty category with its antecedent(s), if any.", "labels": [], "entities": [{"text": "coindexation", "start_pos": 156, "end_pos": 168, "type": "TASK", "confidence": 0.9598394632339478}]}, {"text": "The term recovery refers to the complete package: detection, resolution, and assignment of function tags to empty categories.", "labels": [], "entities": [{"text": "detection, resolution", "start_pos": 50, "end_pos": 71, "type": "TASK", "confidence": 0.6563639243443807}]}], "datasetContent": [{"text": "Following Johnson (2002), the system was evaluated on two different kinds of input: first, on perfect input, i.e., PTB annotations stripped of all empty categories and information related to them; and second, on imperfect input, in this case the output of Charniak's (2000) parser.", "labels": [], "entities": []}, {"text": "Each is discussed in turn below.", "labels": [], "entities": []}, {"text": "The results reported in the previous subsections are quite good, and demonstrate that the current approach outperforms previously reported approaches on the detection and resolution of empty categories.", "labels": [], "entities": [{"text": "detection and resolution of empty categories", "start_pos": 157, "end_pos": 201, "type": "TASK", "confidence": 0.8219268520673116}]}, {"text": "In this subsection some refinements to the evaluation method are considered.", "labels": [], "entities": []}, {"text": "The label and string position method is useful if one sees the task as inserting empty nodes into a string, and thus is quite useful for evaluating systems that detect empty categories without parse trees, as in.", "labels": [], "entities": []}, {"text": "However, if the task is to insert empty nodes into a tree, then the method leads both to false positives and to false negatives.", "labels": [], "entities": []}, {"text": "Suppose for example that the sentence When do you expect to finish? has the bracketing shown below, where '1' and '2' indicate two possible locations in the tree for the trace of the WHADVP: Suppose position 1 is correct; i.e. it represents the position of the trace in the gold standard.", "labels": [], "entities": [{"text": "WHADVP", "start_pos": 183, "end_pos": 189, "type": "DATASET", "confidence": 0.7801090478897095}, {"text": "gold standard", "start_pos": 274, "end_pos": 287, "type": "DATASET", "confidence": 0.8903655111789703}]}, {"text": "Since 1 and 2 correspond to the same string position, if a system inserts the trace in position 2, the string position evaluation method will count it as correct.", "labels": [], "entities": []}, {"text": "This is a serious problem with the string-based method of evaluation, if one assumes, as seems reasonable, that the purpose of inserting empty categories into trees is to be able to recover semantic information such as predicate-argument structure and modification relations.", "labels": [], "entities": []}, {"text": "In the above example, it is clearly semantically relevant whether the system proposes that when modifies expect instead of finish.", "labels": [], "entities": []}, {"text": "Conversely, suppose the sentence Who (besides me) cares? has the bracketing shown: Again suppose that position 1 represents the placement of the WHNP trace in the gold standard.", "labels": [], "entities": [{"text": "WHNP trace in the gold standard", "start_pos": 145, "end_pos": 176, "type": "DATASET", "confidence": 0.821817934513092}]}, {"text": "If a system places the trace in position 2 instead, the string position method will count it as an error, since 1 and 2 have different string positions.", "labels": [], "entities": []}, {"text": "However it is not at all clear what it means to say that one of those two positions is correct and the other not, since there is no semantic, grammatical, or textual indicator of its exact position.", "labels": [], "entities": []}, {"text": "If the task is to be able to recover semantic information using traces, then it does not matter in this case whether the system inserts the trace to the left or to the right of the parenthetical.", "labels": [], "entities": []}, {"text": "Given that both false positives and false negatives are possible, I propose that future evaluations of this task should identify empty categories by their label and by their parent category, instead of, or perhaps in addition to, doing so by label and string position.", "labels": [], "entities": []}, {"text": "Since the parent of an empty node is always an overt node 4 , the parent could be identified by its label and string position (left and right edges).", "labels": [], "entities": []}, {"text": "Resolution is evaluated by a natural extension, by identifying the antecedent (which could itself bean empty category) according to its label and its parent's label and string position.", "labels": [], "entities": [{"text": "Resolution", "start_pos": 0, "end_pos": 10, "type": "TASK", "confidence": 0.9335532784461975}]}, {"text": "This would serve to identify an empty category by its position in the tree, rather than in the string, and would avoid the false positives and false negatives described above.", "labels": [], "entities": []}, {"text": "In addition to an evaluation based on tree position rather than string position, I propose to evaluate the entire recovery task, i.e., including function tag assignment, not just detection and resolution.", "labels": [], "entities": [{"text": "function tag assignment", "start_pos": 145, "end_pos": 168, "type": "TASK", "confidence": 0.6411583224932352}]}, {"text": "The revised evaluation is still not perfect: when inserting an NP* or NP*T* into a double-object construction, it clearly matters semantically whether it is the first or second object, though both positions have the same parent.", "labels": [], "entities": []}, {"text": "Ideally, we would evaluate based on a richer set of grammatical relations than are annotated in the PTB, or perhaps based on thematic roles.", "labels": [], "entities": [{"text": "PTB", "start_pos": 100, "end_pos": 103, "type": "DATASET", "confidence": 0.8891187906265259}]}, {"text": "However, it is difficult to see how to accomplish this without additional annotation.", "labels": [], "entities": []}, {"text": "It is probable that constructions of this sort are relatively rare in the PTB in any case, so for now the proposed evaluation method, however imperfect, will suffice.", "labels": [], "entities": [{"text": "PTB", "start_pos": 74, "end_pos": 77, "type": "DATASET", "confidence": 0.8890013694763184}]}, {"text": "The result of this revised evaluation, given perfect input, is presented in.", "labels": [], "entities": []}, {"text": "The first two rows are comparable to the string-based results in; the last row, showing the results of the full recovery task (i.e., including antecedents and function tags), is not much lower, suggesting that labeling empty categories with function tags does not pose any serious difficulties.", "labels": [], "entities": []}, {"text": "The only exception is the 0 complementizer and S*T* daughters of the SBAR category in; but since the entire SBAR is treated as a single empty node for evaluation purposes, this does not pose a problem.", "labels": [], "entities": []}, {"text": "I am indebted to two ACL reviewers for calling this to my attention.", "labels": [], "entities": []}], "tableCaptions": [{"text": " Table 1: Common empty categories and their  distribution in section 24 of the PTB", "labels": [], "entities": [{"text": "PTB", "start_pos": 79, "end_pos": 82, "type": "DATASET", "confidence": 0.8841668367385864}]}, {"text": " Table 2. Precision here  and throughout is the percentage of empty nodes  proposed by the system that are in the gold  standard (section 23 of the PTB), recall is the  percentage of empty nodes in the gold standard  that are proposed by the system, and F 1 is balanced  f-measure; i.e., 2PR/(P+R).", "labels": [], "entities": [{"text": "Precision", "start_pos": 10, "end_pos": 19, "type": "METRIC", "confidence": 0.9962546825408936}, {"text": "PTB", "start_pos": 148, "end_pos": 151, "type": "DATASET", "confidence": 0.9232335686683655}, {"text": "recall", "start_pos": 154, "end_pos": 160, "type": "METRIC", "confidence": 0.9996229410171509}, {"text": "F 1", "start_pos": 254, "end_pos": 257, "type": "METRIC", "confidence": 0.977035641670227}, {"text": "2PR", "start_pos": 288, "end_pos": 291, "type": "METRIC", "confidence": 0.9470277428627014}]}, {"text": " Table 2: Detection and resolution of empty cate- gories given perfect input (label + string position  method), expressed as percentage", "labels": [], "entities": []}, {"text": " Table 3: Detection and resolution of empty  categories on parser output (label + string position  method), expressed as percentage", "labels": [], "entities": []}, {"text": " Table 4: Detection and resolution of empty  categories on PTB input without function tags  (label + string position method), expressed as  percentage", "labels": [], "entities": [{"text": "resolution of empty  categories", "start_pos": 24, "end_pos": 55, "type": "TASK", "confidence": 0.7828603982925415}]}, {"text": " Table 5: Detection, resolution and recovery of  empty categories given perfect input (label +  parent method), expressed as percentage", "labels": [], "entities": []}, {"text": " Table 6: Detection, resolution and recovery of  empty categories on parser output (label + parent  method), expressed as percentage", "labels": [], "entities": []}, {"text": " Table 7: F 1 for detection and resolution of empty  categories by type, using perfect input (label +  parent method), expressed as percentage", "labels": [], "entities": [{"text": "F", "start_pos": 10, "end_pos": 11, "type": "METRIC", "confidence": 0.9627376794815063}, {"text": "detection and resolution of empty  categories", "start_pos": 18, "end_pos": 63, "type": "TASK", "confidence": 0.7683012088139852}]}]}