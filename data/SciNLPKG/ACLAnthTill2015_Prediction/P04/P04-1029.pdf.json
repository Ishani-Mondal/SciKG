{"title": [{"text": "Optimizing Typed Feature Structure Grammar Parsing through Non-Statistical Indexing", "labels": [], "entities": [{"text": "Optimizing Typed Feature Structure Grammar Parsing", "start_pos": 0, "end_pos": 50, "type": "TASK", "confidence": 0.7073307931423187}]}], "abstractContent": [{"text": "This paper introduces an indexing method based on static analysis of grammar rules and type signatures for typed feature structure grammars (TFSGs).", "labels": [], "entities": []}, {"text": "The static analysis tries to predict at compile-time which feature paths will cause unification failure during parsing at run-time.", "labels": [], "entities": []}, {"text": "To support the static analysis, we introduce anew classification of the instances of variables used in TFSGs, based on what type of structure sharing they create.", "labels": [], "entities": []}, {"text": "The indexing actions that can be performed during parsing are also enumerated.", "labels": [], "entities": [{"text": "parsing", "start_pos": 50, "end_pos": 57, "type": "TASK", "confidence": 0.9643893837928772}]}, {"text": "Non-statistical indexing has the advantage of not requiring training, and, as the evaluation using large-scale HPSGs demonstrates, the improvements are comparable with those of statistical optimizations.", "labels": [], "entities": []}, {"text": "Such statistical optimizations rely on data collected during training, and their performance does not always compensate for the training costs.", "labels": [], "entities": []}], "introductionContent": [{"text": "Developing efficient all-paths parsers has been a long-standing goal of research in computational linguistics.", "labels": [], "entities": []}, {"text": "One particular class still in need of parsing time improvements is that of TFSGs.", "labels": [], "entities": [{"text": "parsing", "start_pos": 38, "end_pos": 45, "type": "TASK", "confidence": 0.9796238541603088}]}, {"text": "While simpler formalisms such as context-free grammars (CFGs) also face slow all-paths parsing times when the size of the grammar increases significantly, TFSGs (which generally have fewer rules than largescale CFGs) become slow as a result of the complex structures used to describe the grammatical categories.", "labels": [], "entities": []}, {"text": "In HPSGs (, one category description could contain hundreds of feature values.", "labels": [], "entities": []}, {"text": "This has been a barrier in transferring CFGsuccessful techniques to TFSG parsing.", "labels": [], "entities": [{"text": "TFSG parsing", "start_pos": 68, "end_pos": 80, "type": "TASK", "confidence": 0.8044344782829285}]}, {"text": "For TFSG chart parsers, one of the most timeconsuming operations is the retrieval of categories from the chart during rule completion (closing of constituents in the chart under a grammar rule).", "labels": [], "entities": [{"text": "TFSG chart parsers", "start_pos": 4, "end_pos": 22, "type": "TASK", "confidence": 0.7572226723035177}]}, {"text": "Looking in the chart fora matching edge fora daughter is accomplished by attempting unifications with edges stored in the chart, resulting in many failed unifications.", "labels": [], "entities": []}, {"text": "The large and complex structure of TFS descriptions leads to slow unification times, affecting the parsing times.", "labels": [], "entities": [{"text": "parsing", "start_pos": 99, "end_pos": 106, "type": "TASK", "confidence": 0.9652398228645325}]}, {"text": "Thus, failing unifications must be avoided during retrieval from the chart.", "labels": [], "entities": []}, {"text": "To our knowledge, there have been only four methods proposed for improving the retrieval component of TFSG parsing.", "labels": [], "entities": [{"text": "TFSG parsing", "start_pos": 102, "end_pos": 114, "type": "TASK", "confidence": 0.9011170864105225}]}, {"text": "One ( addresses only the cost of copying large categories, and was found to reduce parsing times by an average of 25% on a large-scale TFSG (MERGE).", "labels": [], "entities": [{"text": "copying large categories", "start_pos": 33, "end_pos": 57, "type": "TASK", "confidence": 0.8979571064313253}, {"text": "parsing", "start_pos": 83, "end_pos": 90, "type": "TASK", "confidence": 0.9638633728027344}]}, {"text": "The second, a statistical method known as quickcheck (), determines the paths that are likely to cause unification failure by profiling a large sequence of parses over representative input, and then filters unifications at run-time by first testing these paths for type consistency.", "labels": [], "entities": [{"text": "quickcheck", "start_pos": 42, "end_pos": 52, "type": "METRIC", "confidence": 0.9755685925483704}]}, {"text": "This was measured as providing up to a 50% improvement in parse times on the English Resource Grammar.", "labels": [], "entities": [{"text": "English Resource Grammar", "start_pos": 77, "end_pos": 101, "type": "DATASET", "confidence": 0.924225370089213}]}, {"text": "The third) is a similar but more conservative approach that uses the profile to re-order sister feature values in the internal data structure.", "labels": [], "entities": []}, {"text": "This was found to improve parse times on the ALE HPSG by up to 33%.", "labels": [], "entities": [{"text": "parse", "start_pos": 26, "end_pos": 31, "type": "TASK", "confidence": 0.8563716411590576}, {"text": "ALE HPSG", "start_pos": 45, "end_pos": 53, "type": "DATASET", "confidence": 0.827842503786087}]}, {"text": "The problem with these statistical methods is that the improvements in parsing times may not justify the time spent on profiling, particularly during grammar development.", "labels": [], "entities": []}, {"text": "The static analysis method introduced here does not use profiling, although it does not preclude it either.", "labels": [], "entities": []}, {"text": "Indeed, an evaluation of statistical methods would be more relevant if measured on top of an adequate extent of non-statistical optimizations.", "labels": [], "entities": []}, {"text": "Although quick-check is thought to produce parsing time improvements, its evaluation used a parser with only a superficial static analysis of chart indexing.", "labels": [], "entities": [{"text": "parsing", "start_pos": 43, "end_pos": 50, "type": "TASK", "confidence": 0.9791841506958008}]}, {"text": "That analysis, rule filtering (), reduces parse times by filtering out mother-daughter unifications that can be determined to fail at compile-time.", "labels": [], "entities": [{"text": "rule filtering", "start_pos": 15, "end_pos": 29, "type": "TASK", "confidence": 0.7589300274848938}]}, {"text": "True indexing organizes the data (in this case, chart edges) to avoid unnecessary retrievals altogether, does not require the operations that it performs to be repeated once full unification is deemed necessary, and offers the support for easily adding information extracted from further static analysis of the grammar rules, while maintaining the same indexing strategy.", "labels": [], "entities": []}, {"text": "Flexibility is one of the reasons for the successful employment of indexing in databases) and automated reasoning.", "labels": [], "entities": []}, {"text": "In this paper, we present a general scheme for indexing TFS categories during parsing (Section 3).", "labels": [], "entities": [{"text": "indexing TFS categories", "start_pos": 47, "end_pos": 70, "type": "TASK", "confidence": 0.7460914154847463}, {"text": "parsing", "start_pos": 78, "end_pos": 85, "type": "TASK", "confidence": 0.6506760120391846}]}, {"text": "We then present a specific method for statically analyzing TFSGs based on the type signature and the structure of category descriptions in the grammar rules, and prove its soundness and completeness (Section 4.2.1).", "labels": [], "entities": []}, {"text": "We describe a specific indexing strategy based on this analysis (Section 4), and evaluate it on two large-scale TFSGs (Section 5).", "labels": [], "entities": []}, {"text": "The result is a purely non-statistical method that is competitive with the improvements gained by statistical optimizations, and is still compatible with further statistical improvements.", "labels": [], "entities": []}], "datasetContent": [{"text": "Two TFSGs were used to evaluate the performance of indexing: a pre-release version of the MERGE grammar, and the ALE port of the ERG (in its final form).", "labels": [], "entities": [{"text": "MERGE grammar", "start_pos": 90, "end_pos": 103, "type": "DATASET", "confidence": 0.7167913019657135}]}, {"text": "MERGE is an adaptation of the ERG which uses types more conservatively in favour of relations, macros and complex-antecedent constraints.", "labels": [], "entities": [{"text": "MERGE", "start_pos": 0, "end_pos": 5, "type": "DATASET", "confidence": 0.6116381287574768}]}, {"text": "This pre-release version has 17 rules, 136 lexical items, 1157 types, and 144 introduced features.", "labels": [], "entities": []}, {"text": "The ERG port has 45 rules, 1314 lexical entries, 4305 types and 155 features.", "labels": [], "entities": []}, {"text": "MERGE was tested on 550 sentences of lengths between 6 and 16 words, extracted from the Wall Street Journal annotated parse trees (where phrases not covered by MERGE's vocabulary were replaced by lexical entries having the same parts of speech), and from MERGE's own test corpus.", "labels": [], "entities": [{"text": "Wall Street Journal annotated parse trees", "start_pos": 88, "end_pos": 129, "type": "DATASET", "confidence": 0.9395969808101654}, {"text": "MERGE's own test corpus", "start_pos": 255, "end_pos": 278, "type": "DATASET", "confidence": 0.6843742966651917}]}, {"text": "ERG was tested on 1030 sentences of lengths between 6 and 22 words, extracted from the Brown Corpus and from the Wall Street Journal annotated parse trees.", "labels": [], "entities": [{"text": "Brown Corpus", "start_pos": 87, "end_pos": 99, "type": "DATASET", "confidence": 0.9862705767154694}, {"text": "Wall Street Journal annotated parse trees", "start_pos": 113, "end_pos": 154, "type": "DATASET", "confidence": 0.929702510436376}]}, {"text": "Rather than use the current version of ALE, TFSs were encoded as Prolog terms as prescribed in, where the number of argument positions is the number of colours needed to colour the feature graph.", "labels": [], "entities": []}, {"text": "This was extended to allow for the enforcement of type constraints during TFS unification.", "labels": [], "entities": [{"text": "TFS unification", "start_pos": 74, "end_pos": 89, "type": "TASK", "confidence": 0.8983116149902344}]}, {"text": "Types were encoded as attributed variables in SICStus Prolog (Swedish Institute of Computer Science, 2004).", "labels": [], "entities": [{"text": "SICStus Prolog (Swedish Institute of Computer Science, 2004)", "start_pos": 46, "end_pos": 106, "type": "DATASET", "confidence": 0.890489171851765}]}, {"text": "The average and best improvements in parsing times of positional and path indexing over the same EFDbased parser without indexing are presented in", "labels": [], "entities": [{"text": "parsing", "start_pos": 37, "end_pos": 44, "type": "TASK", "confidence": 0.9712808728218079}]}], "tableCaptions": [{"text": " Table 1: Parsing time improvements of positional and  path indexing over the non-indexed EFD parser.", "labels": [], "entities": []}, {"text": " Table 3: Comparison of average improvements over non- indexed parsing among all parsers.", "labels": [], "entities": []}, {"text": " Table 4: The number of successful and failed unifications for the non-indexed, positional indexing, path indexing, and  quick-check parsers, over MERGE and ERG (collected on the slowest sentence in the corresponding test sets.)", "labels": [], "entities": [{"text": "MERGE", "start_pos": 147, "end_pos": 152, "type": "DATASET", "confidence": 0.7466487288475037}]}]}