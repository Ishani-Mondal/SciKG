{"title": [], "abstractContent": [{"text": "This paper extends the approach to feature structures developed in Johnson (1991a), which uses SchO'nfinkel-Bernays' formulae to express feature structure constraints.", "labels": [], "entities": []}, {"text": "These are shown to be a disjunctive generalization of Datalog clauses, as used in database theory.", "labels": [], "entities": [{"text": "database theory", "start_pos": 82, "end_pos": 97, "type": "TASK", "confidence": 0.9020304977893829}]}, {"text": "This paper provides a fixed-point characterization of the minimal models of these formulae that serves as the theoretical foundation of a forward-chaining algorithm for determining their satisfiability.", "labels": [], "entities": []}, {"text": "This algorithm, which generalizes the standard attribute-value unification algorithm, is also recognizable as a nondeterministic variant of the semi-naive bottom-up algorithm for evaluating Datalog programs, further strengthening the connection between the theory of feature structures and databases.", "labels": [], "entities": [{"text": "attribute-value unification", "start_pos": 47, "end_pos": 74, "type": "TASK", "confidence": 0.75978884100914}]}], "introductionContent": [{"text": "Despite their simplicity, a surprisingly wide range of linguistic phenomena can be described in terms of simple equality constraints on values in attribute-value structures, which area particularly simple kind of feature structure (see for examples of some of these analyses).", "labels": [], "entities": []}, {"text": "But some phenomena do not seem to be able to be described in such a pure 'unification' framework.", "labels": [], "entities": []}, {"text": "For example, the analysis of conjunctions in LFG ( and the formalizations of Discourse Representation Theory presented in and require additional mechanisms for representing and manipulating aggregates or sets of values in ways that are beyond the capability of such \"pure\" attribute-value systems.", "labels": [], "entities": []}, {"text": "Further, sortal constraints (which also cannot be expressed as simple equality constraints) can be used to formulate simpler and more comprehensible grammars.", "labels": [], "entities": []}, {"text": "Versions of both of these kinds of constraint, as well as the familiar attribute-value constraints, can be expressed as Scho'nfinkel-Bernays'formulae (as demonstrated in, so that the problem of determining the satisfiability of a system of such constraints is reduced to the satisfiability problem for the corresponding formula.", "labels": [], "entities": []}, {"text": "This class of formulae (defined in Section 3.1) seems to be expressive enough for most linguistic purposes when used with an external phrase-structure backbone.", "labels": [], "entities": []}, {"text": "That is, these formulae are used as annotations on phrase structure rules in the manner described in, e.g.,,.", "labels": [], "entities": []}, {"text": "This paper extends the author's previous paper on the topic (Johnson 1991a) by sketching several other linguistic applications of Sch6nfinkel-Bernays' formulae (including aversion of D-theory), and presenting a least-fixed-point theorem that serves as the theoretical basis fora \"forwardchaining\" algorithm for determining satisfiability of Sch6nfinkel-Bernays' formulae.", "labels": [], "entities": []}, {"text": "Interestingly, this algorithm can be viewed both as a straightforward generalization of the standard attribute-value unification algorithm and also as a nondeterministic variant of the semi-naive evaluation method for Datalog clauses.", "labels": [], "entities": [{"text": "attribute-value unification", "start_pos": 101, "end_pos": 128, "type": "TASK", "confidence": 0.7602646052837372}]}, {"text": "Several extended \"unification-based\" constraint formalisms have been developed.", "labels": [], "entities": [{"text": "unification-based\" constraint formalisms", "start_pos": 18, "end_pos": 58, "type": "TASK", "confidence": 0.8601277768611908}]}, {"text": "In this paper, the term \"feature structure\" denotes any kind of structured entity used as a component of a category label.", "labels": [], "entities": []}, {"text": "An attribute-value structure is a particularly simple kind of feature structure of the kind used in \"pure\" unification-based frameworks.", "labels": [], "entities": []}, {"text": "Some extensions to the basic attribute-value framework are rather weak, e.g., allowing disjunctive and negative constraints and preserving decidability.", "labels": [], "entities": []}, {"text": "1 Such systems require an \"off-line\" phrase structure backbone to which these constraints are attached.", "labels": [], "entities": []}, {"text": "It seems that most of the constraints that can be expressed in these formalisms can be expressed as Sch6nfinkel-Bernays' formulae, the constraint formalism described below.", "labels": [], "entities": []}, {"text": "A second class of extended constraint formalisms has been devised to be capable of expressing the entire grammar as systems of constraints and as far as I know, for all of these systems the problem of determining the satisfiabihty of an arbitrary system of constraints that they can express is undecidable.", "labels": [], "entities": []}, {"text": "2 This is because the recognition problem for an arbitrary \"unification-based\" grammar is undecidable unless the size of the phrase structure tree is constrained somehow, e.g., by the offiine parsability constraint, but there seems to be no natural way to impose such constraints in these systems because the encoding of the phrase structure tree in the feature structure is not distinguished from other features.", "labels": [], "entities": []}, {"text": "3 Thus in order to maintain decidability the system described here is not designed to be capable of expressing phrase structure constraints directly, and must be used with an external phrase-structure component, as in LFG.", "labels": [], "entities": [{"text": "LFG", "start_pos": 218, "end_pos": 221, "type": "DATASET", "confidence": 0.9014043807983398}]}, {"text": "(However, Bob Carpenter [p.c.] points out that one can impose abound on the size of the feature structure that can serve as an analysis [say, some polynomial of the length of the input], and so ensure decidability.)", "labels": [], "entities": []}, {"text": "Interestingly, a first-order logicbased approach similar to the one presented in this paper can also be developed for extended constraint formalisms capable of expressing the entire grammar, but this is not discussed further here; see Johnson (in press b) for details.", "labels": [], "entities": []}, {"text": "In the approach developed here Sch6nfinkel-Bernays' formulae are used to express a variety of feature structure constraints.", "labels": [], "entities": []}, {"text": "Previous work has shown that these formulae are expressive enough to define arbitrary disjunctions and negations of constraints), a kind of 'set-valued' entity (Johnson 1991a), and they can be used to impose useful sort constraints.", "labels": [], "entities": []}, {"text": "The expression of D-theory constraints on nodes in trees is discussed in this paper.", "labels": [], "entities": []}, {"text": "This paper extends the ideas in these earlier papers with theoretical results that suggest a forward-chaining algorithm for determining the satisfiability of an arbitrary Sch6nfinkel-Bernays' formula.", "labels": [], "entities": []}, {"text": "This generalizes the standard feature-graph unification algorithm and is closely related to the semi-naive bottom-up algorithm used in database theory.", "labels": [], "entities": [{"text": "feature-graph unification", "start_pos": 30, "end_pos": 55, "type": "TASK", "confidence": 0.754130095243454}, {"text": "database theory", "start_pos": 135, "end_pos": 150, "type": "TASK", "confidence": 0.7973162829875946}]}, {"text": "For examples of this approach see,,, in press a),,,,,, and.", "labels": [], "entities": []}, {"text": "2 Examples of this approach are Carpenter,,,, Johnson (in press b),,,,, and Zajac (1992).", "labels": [], "entities": []}, {"text": "3 While it may well be that the universal recognition and parsing problems for natural language are undecidable (Chomsky points out that there is no contrary evidence), I know of no evidence that this is actually the case.", "labels": [], "entities": [{"text": "universal recognition and parsing", "start_pos": 32, "end_pos": 65, "type": "TASK", "confidence": 0.7738073617219925}]}, {"text": "It seems reasonable then to also investigate formalisms that can only express decidable systems of constraints (and for which there exist satisfiability-testing algorithms) if linguistically adequate systems can be found.", "labels": [], "entities": []}, {"text": "Specifically, it is shown that the satisfying Herbrand models of an arbitrary Sch6n-finkel-Bernays' formula are the fix points of certain functions, and that the least fixed points of these functions are all of the models of the formula that are \"minimal\" in a certain sense.", "labels": [], "entities": []}, {"text": "This leads to a forward-chaining algorithm for computing all of the atomic consequences of a Sch6nfinkel-Bernays' formula; the fixed-point theorem shows that this suffices to determine the satisfiability of an arbitrary Sch6nfinkel-Bernays' formula.", "labels": [], "entities": []}], "datasetContent": [{"text": "One could attempt to find such a set A in the following manner.", "labels": [], "entities": []}, {"text": "First, one nondeterministically selects a fl~ from each of the ground instances of the positive clauses in Sand adds these to A.", "labels": [], "entities": []}, {"text": "Then one attempts to close A with respect to condition (c); if ' ' of some (ground instance of an) implication are in A, all of the antecedents oq,..., olm then one of the consequents fl~,..., fl~ is nondeterministically selected and added to A, unless at least one of them is already present.", "labels": [], "entities": []}, {"text": "(Of course, all such nondeterministic paths might have to be investigated.)", "labels": [], "entities": []}, {"text": "Periodically, condition (a) is checked; if it fails to hold, then this nondeterministic path on the search for A must be abandoned.", "labels": [], "entities": []}, {"text": "Nondeterminism arises solely from the presence of disjunction in consequents of clauses; if S is a set of Horn clauses then the fixed-point calculation proceeds deterministically.", "labels": [], "entities": []}, {"text": "Ignoring the checking of condition (a), the method is essentially computing a fixedpoint of the nonnegative clauses in S via a kind of iterative approximation known as naive evaluation.", "labels": [], "entities": []}, {"text": "Naive evaluation is unnecessarily computationally inefficient.", "labels": [], "entities": [{"text": "Naive evaluation", "start_pos": 0, "end_pos": 16, "type": "TASK", "confidence": 0.9251399040222168}]}, {"text": "Once the set A is large enough to require an atom o~ to be added to A, naive evaluation \"rediscovers\" this requirement on all subsequent passes.", "labels": [], "entities": []}, {"text": "Semi-naive evaluation avoids rediscovering the same fact in the same way by insisting that each time a clause is applied at least one of the antecedents was just discovered on the previous round).", "labels": [], "entities": []}, {"text": "This is done by maintaining two sets of atoms, A and &A, where A is the set of atoms discovered one or more iterations ago, and &A is the set of atoms discovered at the last iteration.", "labels": [], "entities": []}, {"text": "The nondeterministic semi-naive algorithm for computing a set A (if it exists) is sketched in.", "labels": [], "entities": []}, {"text": "In that algorithm choose is a \"function\" that nondeterministically picks one member from its set argument; it can be implemented using, e.g., backtracking.", "labels": [], "entities": []}, {"text": "Ullman describes methods of matching clauses in S against the sets A and &A that avoids calculating all of the ground instances of the clauses in S.", "labels": [], "entities": []}, {"text": "The semi-naive algorithm can be used directly with the syntactic equality axioms given in Section 3.4 as a decision procedure for SB formulae, and hence for systems of feature structure constraints.", "labels": [], "entities": []}, {"text": "However, the resulting system is inefficient because the equality axioms, specifically the instances of schemata (E2) and (E3), cause the \"copying\" of any atom containing an argument that appears in an equality atom to all members of the equivalence class containing that argument.", "labels": [], "entities": []}, {"text": "For example, if p(a), q(b) and a = bare atoms in A, then instances of (E2) and (E3) ensure that p(b),q(a) and b = a will be added to &A and thence to A.", "labels": [], "entities": []}, {"text": "In general, if it is discovered that n constants al,.., an are equal, then A will ultimately contain then 2 equalities ai = aj, 1 < i < n, 1 < j <_ n, as well as at least n \"copies\" of any predicate containing any ai.", "labels": [], "entities": []}], "tableCaptions": []}