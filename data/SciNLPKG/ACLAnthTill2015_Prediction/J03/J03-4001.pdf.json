{"title": [{"text": "Dependency Parsing with an Extended Finite-State Approach", "labels": [], "entities": [{"text": "Dependency Parsing", "start_pos": 0, "end_pos": 18, "type": "TASK", "confidence": 0.8220160603523254}]}], "abstractContent": [{"text": "This article presents a dependency parsing scheme using an extended finite-state approach.", "labels": [], "entities": [{"text": "dependency parsing", "start_pos": 24, "end_pos": 42, "type": "TASK", "confidence": 0.8056440949440002}]}, {"text": "The parser augments input representation with \"channels\" so that links representing syntactic dependency relations among words can be accommodated and iterates on the input a number of times to arrive at a fixed point.", "labels": [], "entities": []}, {"text": "Intermediate configurations violating various constraints of projective dependency representations such as no crossing links and no independent items except senten-tial head are filtered via finite-state filters.", "labels": [], "entities": []}, {"text": "We have applied the parser to dependency parsing of Turkish.", "labels": [], "entities": [{"text": "dependency parsing", "start_pos": 30, "end_pos": 48, "type": "TASK", "confidence": 0.8562521934509277}]}], "introductionContent": [{"text": "Finite-state machines have been used for many tasks in language processing, such as tokenization, morphological analysis, and parsing.", "labels": [], "entities": [{"text": "tokenization", "start_pos": 84, "end_pos": 96, "type": "TASK", "confidence": 0.9682522416114807}, {"text": "morphological analysis", "start_pos": 98, "end_pos": 120, "type": "TASK", "confidence": 0.6929774582386017}]}, {"text": "Recent advances in the development of sophisticated tools for building finite-state systems (e.g., XRCE Finite State Tools, AT&T Tools, and Finite State Automata Utilities) have fostered the development of quite complex finite-state systems for natural language processing.", "labels": [], "entities": [{"text": "AT&T Tools", "start_pos": 124, "end_pos": 134, "type": "DATASET", "confidence": 0.8017957210540771}]}, {"text": "In the last several years, there have been a number of studies on developing finite-state parsing systems.", "labels": [], "entities": [{"text": "finite-state parsing", "start_pos": 77, "end_pos": 97, "type": "TASK", "confidence": 0.5922888666391373}]}, {"text": "Another stream of work in using finite-state methods in parsing is based on approximating context-free grammars with finite-state grammars, which are then processed by efficient methods for such grammars).", "labels": [], "entities": []}, {"text": "There have also been a number of approaches to natural language parsing using extended finite-state approaches in which a finite-state engine is applied multiple times to the input, or various derivatives thereof, until some termination condition is reached.", "labels": [], "entities": [{"text": "natural language parsing", "start_pos": 47, "end_pos": 71, "type": "TASK", "confidence": 0.6396413147449493}]}, {"text": "This article presents an approach to dependency parsing using a finite-state approach.", "labels": [], "entities": [{"text": "dependency parsing", "start_pos": 37, "end_pos": 55, "type": "TASK", "confidence": 0.848624587059021}]}, {"text": "The approach is similar to those of Roche and Abney in that all three use an extended finite-state scheme to parse the input sentences.", "labels": [], "entities": []}, {"text": "Our contributions can be summarized as follows: \u2022 Our approach differs from Roche's and Abney's in that it is based on the dependency grammar approach and at the output produces an encoding of the dependency structure of a sentence.", "labels": [], "entities": []}, {"text": "The lexical items and the dependency relations are encoded in an intertwined manner and manipulated by grammar rules, as well as structural and linguistic constraints implemented as finite-state filters, to arrive at parses.", "labels": [], "entities": []}, {"text": "The output of the parser is a finite-state transducer that compactly packs all the ambiguities as a lattice.", "labels": [], "entities": []}, {"text": "\u2022 As our approach is an all-parses approach with no statistical component, we have used proposal for ranking the parses based on the total link length and have obtained promising results.", "labels": [], "entities": []}, {"text": "For over 48% of the sentences, the correct parse was among the dependency trees with the smallest total link length.", "labels": [], "entities": []}, {"text": "\u2022 Our approach can employ violable constraints for robust parsing so that when the parser fails to link all dependents to ahead, one can use lenient filtering to allow parses with a small number of unlinked dependents to be output.", "labels": [], "entities": []}, {"text": "\u2022 The rules for linking dependents to heads can specify constraints on the intervening material between them, so that, for instance, certain links maybe prevented from crossing barriers such as punctuation or lexical items with certain parts of speech or morphological properties.", "labels": [], "entities": []}, {"text": "We summarize in the basic idea of our approach.", "labels": [], "entities": []}, {"text": "This figure presents in a rather high-level fashion, fora Turkish and an English sentence, the input and output representation for the approach to be presented.", "labels": [], "entities": []}, {"text": "For the purposes of this summary, we assume that none of the words in the sentences have any morphological ambiguity and that their morphological properties are essentially obvious from the glosses.", "labels": [], "entities": []}, {"text": "We represent the input to the parser as a string of symbols encoding the words with some additional delimiter markers.", "labels": [], "entities": []}, {"text": "Panel (a) of shows this input representation fora Turkish sentence, on the top right, and panel (b) shows it for an English sentence.", "labels": [], "entities": []}, {"text": "The parser operates in iterations.", "labels": [], "entities": []}, {"text": "In the first iteration, the parser takes the input string encoding the sentence and manipulates it to produce the intermediate string in which we have three dependency relations encoded by additional symbols (highlighted with boldface type) injected into the string.", "labels": [], "entities": []}, {"text": "The partial dependency trees encoded are depicted to the left of the intermediate strings.", "labels": [], "entities": []}, {"text": "It should be noted that the sets of dependency relations captured in the first iteration are different for Turkish and English.", "labels": [], "entities": []}, {"text": "In the Turkish sentence, two determiner links and one object link are encoded in parallel, whereas in the English sentence, two determiner links and one subject link are encoded in parallel.", "labels": [], "entities": []}, {"text": "The common property of these links is that they do not \"interfere\" with each other.", "labels": [], "entities": []}, {"text": "The second iteration of the parser takes the output of the first iteration and manipulates it to produce a slightly longer string in which symbols encoding anew subject (object) link are injected into the Turkish (English) string.", "labels": [], "entities": []}, {"text": "(We again highlight these symbols with boldface type.)", "labels": [], "entities": []}, {"text": "Note that in the English string the relative positions of the link start and end symbols indicate that this is a right-to-left link.", "labels": [], "entities": []}, {"text": "The dependency structures encoded by these strings are again on their left.", "labels": [], "entities": []}, {"text": "After the second iteration, there are no further links that can be added, since in each case there is only one word left without any outgoing links and it happens to be the head of the sentence.", "labels": [], "entities": []}, {"text": "The article is structured as follows: After a brief overview of related work, we summarize dependency grammars and aspects of Turkish relevant to this work.", "labels": [], "entities": []}, {"text": "We provide a summary of concepts from finite-state transducers so that subsequent sections can be self-contained.", "labels": [], "entities": []}, {"text": "We continue by describing the representation that we have employed for encoding dependency structures, along with the encoding of dependency linking rules operating on these representations and configurational constraints Dependency Parsing tions and build upon these by grouping them into phrases.", "labels": [], "entities": []}, {"text": "Later stages are geared toward recognizing event patterns and building event structures.", "labels": [], "entities": []}], "datasetContent": [{"text": "Our implementation work has mainly consisted of developing and implementing the representation and finite-state techniques involved here, along with a nontrivial grammar component; we have not attempted to build a wide-coverage parser that is expected to work on an arbitrary test corpus.", "labels": [], "entities": []}, {"text": "Although we have built the grammar component manually using a very small set of sentences, it is conceivable that future work on inducing (possibly statistical) dependency grammars will exploit dependency treebanks, which are slowly becoming available).", "labels": [], "entities": []}, {"text": "The grammar has two major components.", "labels": [], "entities": []}, {"text": "The morphological analyzer is a fullcoverage analyzer built using XRCE finite-state tools, slightly modified to generate outputs as a sequence of IGs fora sequence of words.", "labels": [], "entities": [{"text": "morphological analyzer", "start_pos": 4, "end_pos": 26, "type": "TASK", "confidence": 0.7076395153999329}]}, {"text": "When an input sentence (again represented as a transducer denoting a sequence of words) is composed with the morphological analyzer (see the pseudocode given in section 6.6), a transducer for the lattice representing all IGs for all morphological ambiguities (remaining after alight morphological disambiguation) is generated.", "labels": [], "entities": []}, {"text": "The dependency relations are described by a set of about 60 rules much like the ones exemplified earlier.", "labels": [], "entities": []}, {"text": "These rules were developed using a small set of 30 sentences.", "labels": [], "entities": []}, {"text": "The rules were almost all nonlexical, establishing links of the types listed earlier.", "labels": [], "entities": []}, {"text": "There is an additional set of 28 finitestate constraints that impose various syntactic and structural constraints.", "labels": [], "entities": []}, {"text": "The resulting Parser transducer has 13,290 states and 186,270 transitions, and the SyntacticFilter transducer has 3,800 states and 134,491 transitions.", "labels": [], "entities": []}, {"text": "The combined transducer for morphological analysis and (very limited) disambiguation has 100,103 states and 243,533 arcs.", "labels": [], "entities": [{"text": "morphological analysis", "start_pos": 28, "end_pos": 50, "type": "TASK", "confidence": 0.7671845257282257}]}, {"text": "The dependency grammar and the finite-state dependency parser were tested on a set of 200 Turkish sentences, including the 30 that were used for developing and testing the grammar.", "labels": [], "entities": []}, {"text": "These sentences had 4 to 43 words, with an average of about 18 words.", "labels": [], "entities": []}, {"text": "presents our results for parsing this set of 200 sentences.", "labels": [], "entities": []}, {"text": "This table presents the minimum, the maximum, and the average of the number of words and IGs per sentence, the number of parser iterations and the number of parses generated.", "labels": [], "entities": []}, {"text": "(The number of iterations includes the last iteration where no new links are added.)", "labels": [], "entities": []}, {"text": "There were 22 sentences among the 200 that had quite a number of verbal adjuncts that function as modifiers.", "labels": [], "entities": []}, {"text": "These freely attach to any verb IG, creating an analog of the PP attachment problem and giving rise to a very large number of parses.", "labels": [], "entities": [{"text": "PP attachment problem", "start_pos": 62, "end_pos": 83, "type": "TASK", "confidence": 0.8626691301663717}]}, {"text": "The last row in the table gives the minimum, maximum and the average number of parses when such sentences were not considered.", "labels": [], "entities": []}, {"text": "To impose a ranking on the parses generated based on just structural properties of the dependency tree, we employed Lin's (1996) notion of structural complexity.", "labels": [], "entities": []}, {"text": "We measured the total link length (TLL) in a dependency parse counting the IGs the links pass over in the linear representation and ordered the dependency parses based on the TLL of the dependency tree.", "labels": [], "entities": [{"text": "total link length (TLL)", "start_pos": 16, "end_pos": 39, "type": "METRIC", "confidence": 0.8161096672217051}]}, {"text": "We classified the sentences into six groups:", "labels": [], "entities": []}], "tableCaptions": [{"text": " Table 1  Statistics from parsing 200 Turkish sentences.", "labels": [], "entities": [{"text": "parsing 200 Turkish sentences", "start_pos": 26, "end_pos": 55, "type": "TASK", "confidence": 0.803524911403656}]}]}