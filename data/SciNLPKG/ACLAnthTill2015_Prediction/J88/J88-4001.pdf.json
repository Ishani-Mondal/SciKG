{"title": [{"text": "LFP: A LOGIC FOR LINGUISTIC DESCRIPTIONS AND AN ANALYSIS OF ITS COMPLEXITY", "labels": [], "entities": [{"text": "A LOGIC FOR LINGUISTIC DESCRIPTIONS", "start_pos": 5, "end_pos": 40, "type": "METRIC", "confidence": 0.7874504923820496}, {"text": "AN", "start_pos": 45, "end_pos": 47, "type": "METRIC", "confidence": 0.9783838987350464}, {"text": "ANALYSIS", "start_pos": 48, "end_pos": 56, "type": "METRIC", "confidence": 0.7932982444763184}]}], "abstractContent": [{"text": "We investigate the weak expressive power of a notation using first-order logic, augmented with a facility for recursion, to give linguistic descriptions.", "labels": [], "entities": []}, {"text": "The notation is precise and easy to read, using ordinary conventions of logic.", "labels": [], "entities": []}, {"text": "Two versions of the notation are presented.", "labels": [], "entities": []}, {"text": "One, called CLFP, speaks about strings and concatenation, and generates the class EXPTIME of languages accepted by Turing machines in time 2 c\" for some c > 0.", "labels": [], "entities": []}, {"text": "The other, called ILFP, speaks about integer positions in strings, and generates the class PTIME of languages recognizable in polynomial time.", "labels": [], "entities": []}, {"text": "An application is given, showing how to code Head Grammars in ILFP, showing why these grammars generate only polynomial time languages.", "labels": [], "entities": []}, {"text": "1 FIRST-ORDER LOGIC AS A TOOL FOR SYNTACTIC DESCRIPTION In this paper we investigate the properties of anew notation for specifying syntax for natural languages.", "labels": [], "entities": [{"text": "FIRST-ORDER LOGIC AS A TOOL FOR SYNTACTIC DESCRIPTION", "start_pos": 2, "end_pos": 55, "type": "METRIC", "confidence": 0.8403841853141785}]}, {"text": "It is based on the simple idea that first-order logic, though inadequate as a semantics for natural language, is quite adequate to express relations between syntactic constituents.", "labels": [], "entities": []}, {"text": "This is the insight behind definite clause grammars (DCGs) (Pereira and Warren 1980) and, in fact, our notation is in some ways a generalization of that notation.", "labels": [], "entities": [{"text": "definite clause grammars (DCGs)", "start_pos": 27, "end_pos": 58, "type": "TASK", "confidence": 0.7857319513956705}]}, {"text": "However, we have tried to keep our formalism as much as possible like that of standard textbook first-order logic.", "labels": [], "entities": []}, {"text": "There are actually two versions of our notation.", "labels": [], "entities": []}, {"text": "The first works with strings of symbols and uses concatenation as a primitive operation.", "labels": [], "entities": []}, {"text": "The second works with integers and takes the standard arithmetic operations as primitive.", "labels": [], "entities": []}, {"text": "These integers can be regarded as indexing positions of morphemes in a sentence, but the sentence itself is not explicitly referenced.", "labels": [], "entities": []}, {"text": "Both versions allow the recursive definition of predicates over strings and integers.", "labels": [], "entities": []}, {"text": "This capacity for recursive definition is what gives our grammars their generative ability, and our notation has this feature in common with DCGs.", "labels": [], "entities": []}, {"text": "However, we liberate DCGs from the Horn clause format, and we do not base the semantics of our notation on the semantics for Prolog or for logic programs.", "labels": [], "entities": [{"text": "Prolog", "start_pos": 125, "end_pos": 131, "type": "DATASET", "confidence": 0.9324521422386169}]}, {"text": "We hope that making the logic more familiar and readable will encourage more people to use logic as a means for specifying desired syntactic relations between sentential constituents in grammars.", "labels": [], "entities": []}, {"text": "Anyone knowing the standard conventions of first-order logic should be able to read or to specify a grammar in our notation.", "labels": [], "entities": []}, {"text": "We also provide a precise semantics for our two notations.", "labels": [], "entities": []}, {"text": "This involves using the least-fixed-point operator from denotational semantics for programming languages to explain the recursive definition of predicates.", "labels": [], "entities": []}, {"text": "It involves as well using restricted universal and existential quantification to restrict the class of defin-able predicates (sets of strings).", "labels": [], "entities": []}, {"text": "We prove a complexity theoretic characterization for both grammar formalisms: (1) the formalism using strings and concatenation defines exactly the class EXPTIME of formal languages recognizable by deterministic Turing machines within time T(n) = 2 en for some positive c; and (2) the formalism using integers defines exactly the class PTIME of languages recognizable in time T(n) = n k for some integer k.", "labels": [], "entities": []}, {"text": "As an application of the second notation we sketch a natural way to write Head Grammars (Pollard 1984).", "labels": [], "entities": []}, {"text": "Because these grammars can be expressed in this way, we immediately obtain the result that head languages can be recognized in polynomial time.", "labels": [], "entities": []}, {"text": "We even obtain an estimate of the degree of the polynomial that is required, derived directly from the form of the grammatical description.", "labels": [], "entities": []}, {"text": "Unfortunately, the estimated degree is at least twice as large as is actually necessary if one uses the algorithm of Pollard (1984), or Vija", "labels": [], "entities": [{"text": "degree", "start_pos": 29, "end_pos": 35, "type": "METRIC", "confidence": 0.7552358508110046}]}], "introductionContent": [], "datasetContent": [], "tableCaptions": []}