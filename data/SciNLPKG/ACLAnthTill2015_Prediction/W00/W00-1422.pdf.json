{"title": [{"text": "Enriching Partially-Specified Representations for Text Realization Using an Attribute Grammar *", "labels": [], "entities": [{"text": "Text Realization", "start_pos": 50, "end_pos": 66, "type": "TASK", "confidence": 0.7634637951850891}]}], "abstractContent": [{"text": "We present anew approach to enriching under-specified representations of content to be realized as text.", "labels": [], "entities": []}, {"text": "Our approach uses an attribute grammar to propagate missing information where needed in a tree that represents the text to be realized.", "labels": [], "entities": []}, {"text": "This declaratively-specified grammar mediates between application-produced output and the input to a generation system and, as a consequence, can easily augment an existing generation system.", "labels": [], "entities": []}, {"text": "End-applications that use this approach can produce high quality text without a fine-grained specification of the text to be realized, thereby reducing the burden to the application.", "labels": [], "entities": []}, {"text": "Additionally, representations used by the generator are compact, because values that can be constructed from the constraints encoded by the grammar will be propagated where necessary.", "labels": [], "entities": []}, {"text": "This approach is more flexible than defaulting or making a statistically good choice because it can deal with long-distance dependencies (such as gaps and reflexive pronouns).", "labels": [], "entities": []}, {"text": "Our approach differs from other approaches that use attribute grammars in that we use the grammar to enrich the representations of the content to be realized, rather than to generate the text itself.", "labels": [], "entities": []}, {"text": "We illustrate the approach with examples from our template-based text-realizer, YAG.", "labels": [], "entities": [{"text": "YAG", "start_pos": 80, "end_pos": 83, "type": "DATASET", "confidence": 0.7863329648971558}]}], "introductionContent": [{"text": "Typically, a text realization system requires a great deal of syntactic information from an application in order to generate a high quality text; however, an application might not have this information (unless it has been built with text generation in mind).", "labels": [], "entities": [{"text": "text realization", "start_pos": 13, "end_pos": 29, "type": "TASK", "confidence": 0.7348544150590897}, {"text": "text generation", "start_pos": 233, "end_pos": 248, "type": "TASK", "confidence": 0.74931800365448}]}, {"text": "This problem has been referred to as the Generation Gap ture fora given plan.", "labels": [], "entities": []}, {"text": "Typically, neither a text planner nor a sentence planner is concerned with finegrained syntactic issues, such as whether the subject of the sentence is a singular or plural noun.", "labels": [], "entities": [{"text": "text planner", "start_pos": 21, "end_pos": 33, "type": "TASK", "confidence": 0.7037825286388397}]}, {"text": "Thus, it becomes the responsibility of a text realizer to infer the missing information and to generate the best possible text from a given input.", "labels": [], "entities": []}, {"text": "Most generation systems (such as FUF/SURGE, Penman, RealPro (), TG/2, and YAG)) alleviate this problem by using defaulting, in which a grammar writer specifies a default for each syntactic constraint.", "labels": [], "entities": [{"text": "FUF", "start_pos": 33, "end_pos": 36, "type": "DATASET", "confidence": 0.8205058574676514}]}, {"text": "This approach is inflexible and prone to errors, because there might not be one default that suits all applications or situations.", "labels": [], "entities": []}, {"text": "Another approach that has been proposed is to fill in the missing information on the basis of word cooccurrence data collected from a large corpus of text (see).", "labels": [], "entities": []}, {"text": "However, statistical approaches have difficulty when there are long-distance dependencies among constituents in a text.", "labels": [], "entities": []}, {"text": "In this paper, we present anew approach to resolving the so-called generation gap that uses an Attribute Grammar) to enrich partiallyspecified inputs to a realization system to produce high quality texts.", "labels": [], "entities": []}, {"text": "Attribute Grammars area declarative formalism for defining rules for attribute propagation (see Section 3).", "labels": [], "entities": [{"text": "attribute propagation", "start_pos": 69, "end_pos": 90, "type": "TASK", "confidence": 0.7653664946556091}]}, {"text": "They have been used primarily for specifying the .semantics of programruing languages, although a few researchers have also used them to drive a text generator (see, for exaanple).", "labels": [], "entities": []}, {"text": "The main advantage of our approach is that it allows a generator to enjoy the computational efficiency of a templatebased realization system, while reducing the linguistic burden on an application and increasing the quality of the generated texts.", "labels": [], "entities": []}, {"text": "Our work differs from previous uses of attribute grammars in natural language generation, which are similar to)in that they apply attribute grammars directly to text realization.", "labels": [], "entities": [{"text": "natural language generation", "start_pos": 61, "end_pos": 88, "type": "TASK", "confidence": 0.7707735697428385}, {"text": "text realization", "start_pos": 161, "end_pos": 177, "type": "TASK", "confidence": 0.7249275892972946}]}, {"text": "Attributes in their system assist the realization by propagating information down a tree that specifies the complete syntactic structure of the output text.", "labels": [], "entities": []}, {"text": "By contrast, our work employs attribute grammars, not to realize a text, but to perform a generation gap analysis prior to actual realization.", "labels": [], "entities": []}, {"text": "We use both inherited and synthesized attributes (i.e., propagating information both down and up a tree) to share information and to determine appropriate values for any missing features.", "labels": [], "entities": []}, {"text": "Values for the tenlplates are provided by an application; inputs can include either,a conceptual representation of content or a feature structure.", "labels": [], "entities": []}, {"text": "When an input is only partially specified, defaults defined in a template will be applied.", "labels": [], "entities": []}, {"text": "shows an example of YAG's feature-structure based input; YAG would realize this example as \"Jack and I want his sister's dog to swim.", "labels": [], "entities": []}, {"text": "\". This input is partially specified, and thus is more compact and easier for an application to specify, than a complete specification.", "labels": [], "entities": []}, {"text": "shows the features that have been omitted and the defaults used t75 YAG to realize the sentence from tile input.", "labels": [], "entities": [{"text": "YAG", "start_pos": 68, "end_pos": 71, "type": "METRIC", "confidence": 0.958221435546875}]}, {"text": "Although the input is already more compact than a full specification, further simplification of the input provided from an application would have been possible, if certain inferences could be made.", "labels": [], "entities": []}, {"text": "For example, shows an input structure that could replace the one given in.", "labels": [], "entities": []}, {"text": "In, it was not necessary for the application to specify that the conjunction of two noun phrases is a phlral noun phrase, nor that component noun phrases (proper nouns, pronouns, and possessives) should not, contain an article.", "labels": [], "entities": []}, {"text": "In the case of conjunctions, there is no default that would provide the correct outputs in all cases, because the same conjunction template is used to conjoin adjectives and clauses.", "labels": [], "entities": []}, {"text": "Instead, our approach uses an attribute grammar to make the appropriate inferences and enrich the feature struc-  ture input so that neither the application, nor the templates need to be altered to handle dependencies, like conjunctions, correctly.", "labels": [], "entities": []}, {"text": "for every attribute instance in the tree according to the semantic rules defined for each production.", "labels": [], "entities": []}, {"text": "An example of an attribute grammar and its components is given in (adapted from).", "labels": [], "entities": []}, {"text": "This attribute grammar consists of two nonterminals, two terminals, andthree production rules.", "labels": [], "entities": []}, {"text": "As mentioned earlier, semantic rules define dependencies among attributes\u2022 shows dependency graphs corresponding to the semantic rules of.", "labels": [], "entities": []}, {"text": "In the graphs, a dotted line represents a derivation of a production rule, ' while an arrow de inotes an attribute dependency.", "labels": [], "entities": []}, {"text": "Thus..4 ~ B means \u2022 . .", "labels": [], "entities": [{"text": "B", "start_pos": 10, "end_pos": 11, "type": "METRIC", "confidence": 0.9679847359657288}]}, {"text": "To make a generation gap analysis possible, a grammar writer must first extend the grammar of his or her existing generator to capture the propagation semantics of a target language.", "labels": [], "entities": []}, {"text": "This extension involves defining attributes (synthesized and inherited) and associated semantic rules.", "labels": [], "entities": []}, {"text": "Next, a small program must be built to construct a tree from a given input and retrieve semantic rules and attributes from associated grammar units.", "labels": [], "entities": []}, {"text": "Attribute evaluation begins by instantiating each inherited attribute with values from the input and then the remaining attributes are evaluated.", "labels": [], "entities": [{"text": "Attribute evaluation", "start_pos": 0, "end_pos": 20, "type": "TASK", "confidence": 0.8451462388038635}]}, {"text": "This process is incremental in the sense that new information gained from previous evaluations might lead to the discovery of additional information.", "labels": [], "entities": []}, {"text": "When all attributes remain unchanged, or there is a conflict detected in the input, the process terminates.", "labels": [], "entities": []}, {"text": "The generator then passes the enriched input to the realization component.", "labels": [], "entities": []}, {"text": "Consider the following fragment of input from that uses the CONJUNCTION template to join a noun phrase and a pronoun.", "labels": [], "entities": []}, {"text": "( (template CONJUNCTION) (:first ((template NOUN-PHRASE) (head \"Jack\") (np-type PROPER) (gender MASCULINE) )) This fragment is the subject of the sentence, therefore features such as person and number would be required to enforce tile subject-verb agreement of English.", "labels": [], "entities": [{"text": "NOUN-PHRASE", "start_pos": 44, "end_pos": 55, "type": "METRIC", "confidence": 0.8336091637611389}, {"text": "MASCULINE", "start_pos": 96, "end_pos": 105, "type": "METRIC", "confidence": 0.8533295392990112}]}, {"text": "shows a dependency graph ~ for this i The notatio, used in the dependency graph is the following: The oval represents a template slot that is bound to anatomic value.", "labels": [], "entities": []}, {"text": "The rectangle denotes a slot that is bound to another feature structure.", "labels": [], "entities": []}, {"text": "The top text in a rectangle specifies a slot name, and the bottom text is the name of a template ~kssigned to this slot,.", "labels": [], "entities": []}, {"text": "A value with an underline'means a default of the above slot.", "labels": [], "entities": []}, {"text": "The bold fdnt represents a value yielded from attribute evaluations.", "labels": [], "entities": []}, {"text": "\u2022 Constrain the number feature to be PLURAL, the gender feature to be NEUTRAL, the definite feature to be NOART, and the sentence feature to the same as the sentence feature of the conjunets.", "labels": [], "entities": [{"text": "PLURAL", "start_pos": 37, "end_pos": 43, "type": "METRIC", "confidence": 0.9820618033409119}, {"text": "NEUTRAL", "start_pos": 70, "end_pos": 77, "type": "METRIC", "confidence": 0.9086120128631592}, {"text": "NOART", "start_pos": 106, "end_pos": 111, "type": "METRIC", "confidence": 0.9860336184501648}]}, {"text": "For tile NOUN-PHRASE teinplate, the grammar will Require this template to enforce the inherited values of the definite, number, and np-type features.", "labels": [], "entities": [{"text": "NOUN-PHRASE", "start_pos": 9, "end_pos": 20, "type": "METRIC", "confidence": 0.6732627153396606}]}, {"text": "Require the (embedded) DETERMINER template enforce the number feature of the current template.", "labels": [], "entities": [{"text": "DETERMINER", "start_pos": 23, "end_pos": 33, "type": "METRIC", "confidence": 0.6710885167121887}]}, {"text": "Pass up four features (definite, number, person, and np-type) to any templates that use this noun phrase, where the fotlcrwJng constraints apply: The definiteness feature that is passed is YES whenever the current template has inherited YES for this value or there is a possessor or a determiner and one of them passes up YES for this feature.", "labels": [], "entities": [{"text": "YES", "start_pos": 189, "end_pos": 192, "type": "METRIC", "confidence": 0.9947535991668701}, {"text": "YES", "start_pos": 322, "end_pos": 325, "type": "METRIC", "confidence": 0.9932153224945068}]}, {"text": "(If there is neither possessor nor determiner then the grammar considers the np-type: if it is COMMON, it uses NO (for indefinite) and if it is PROPER, it uses NOART The number feature passed is the value passed from the determiner, if there is one, or the value from the current template.", "labels": [], "entities": [{"text": "NO", "start_pos": 111, "end_pos": 113, "type": "METRIC", "confidence": 0.9894736409187317}, {"text": "NOART", "start_pos": 160, "end_pos": 165, "type": "METRIC", "confidence": 0.9726614952087402}]}, {"text": "The person feature passed is the one from the current template.", "labels": [], "entities": []}, {"text": "The rip-type feature passed is COMMON if the value of definite is NO and PROPER if the value is NOART.", "labels": [], "entities": [{"text": "COMMON", "start_pos": 31, "end_pos": 37, "type": "METRIC", "confidence": 0.9815639853477478}, {"text": "NO", "start_pos": 66, "end_pos": 68, "type": "METRIC", "confidence": 0.9431848526000977}, {"text": "PROPER", "start_pos": 73, "end_pos": 79, "type": "METRIC", "confidence": 0.9968380928039551}, {"text": "NOART", "start_pos": 96, "end_pos": 101, "type": "METRIC", "confidence": 0.8843435645103455}]}, {"text": "For tile PRONOUN template, the grammar will: o Pass tip the person, number, and gender values fl'om the current template (possibly using default values), along with the constraint that ttle string realized for it not be a sentence and not be preceded by an article.", "labels": [], "entities": []}, {"text": "In-the example shown in, inherited attributes 2 have been initialized to the associated values given in an input.", "labels": [], "entities": []}, {"text": "If the input does not specify a value for an inherited attribute, then the value nil is used.", "labels": [], "entities": []}, {"text": "The attribute evaluation is depth-first, and requires nmltiple traversals.", "labels": [], "entities": []}, {"text": "Here, the NOUN-PHRASE sub-tree is evaluated twice, as we discover that the definite feature must be NOART.", "labels": [], "entities": [{"text": "NOUN-PHRASE", "start_pos": 10, "end_pos": 21, "type": "METRIC", "confidence": 0.6758074760437012}, {"text": "NOART", "start_pos": 100, "end_pos": 105, "type": "METRIC", "confidence": 0.8073068857192993}]}, {"text": "Since tile PRONOUN template has no inherited attributes, a single evaluation would be sufficient.", "labels": [], "entities": []}, {"text": "The CONJUNCTION sub-tree is also traversed twice because the sentence feature is re-assigned once (from nil to NO).", "labels": [], "entities": []}, {"text": "Note that this feature structure can be generated differently as \"'Jack's sister's dog\".", "labels": [], "entities": []}, {"text": "\"the dog o~ Jack's sister\".", "labels": [], "entities": [{"text": "Jack's sister", "start_pos": 12, "end_pos": 25, "type": "DATASET", "confidence": 0.8143582344055176}]}, {"text": "\"'the do q o/ h.is sister\", and \"the dog o/ hens\".", "labels": [], "entities": []}, {"text": "\\Vhile some of these variations require further investigation to determine how to transform a tree so that it reflects anew ordering of constituents, some can be implemented using semantic rules.", "labels": [], "entities": []}, {"text": "For example,--to-avoid-/anawkward construction such as \",lack's sister's do q\" in the senoo< ....", "labels": [], "entities": []}, {"text": "tence \"Jack and I want Jack's sister's dog to swim.", "labels": [], "entities": []}, {"text": "\", in favor of \"his sister's dog\", without the application having to request a pronoun explicitly, as in the example shown above, we could add a rule to force the pronominal feature of the innermost possessor to be YES, whenever a (repeated) noun phrase is a possessor of a possessor of the primary noun.", "labels": [], "entities": [{"text": "YES", "start_pos": 215, "end_pos": 218, "type": "METRIC", "confidence": 0.9945387244224548}]}], "datasetContent": [], "tableCaptions": []}