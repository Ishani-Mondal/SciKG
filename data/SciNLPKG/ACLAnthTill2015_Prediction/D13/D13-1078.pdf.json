{"title": [{"text": "A synchronous context free grammar for time normalization", "labels": [], "entities": [{"text": "time normalization", "start_pos": 39, "end_pos": 57, "type": "TASK", "confidence": 0.6718362271785736}]}], "abstractContent": [{"text": "We present an approach to time normalization (e.g. the day before yesterday\u21d22013-04-12) based on asynchronous context free grammar.", "labels": [], "entities": [{"text": "time normalization", "start_pos": 26, "end_pos": 44, "type": "TASK", "confidence": 0.6628698706626892}]}, {"text": "Synchronous rules map the source language to formally defined operators for manipulating times (FINDENCLOSED, STARTATENDOF, etc.).", "labels": [], "entities": [{"text": "FINDENCLOSED", "start_pos": 96, "end_pos": 108, "type": "METRIC", "confidence": 0.9886729121208191}, {"text": "STARTATENDOF", "start_pos": 110, "end_pos": 122, "type": "METRIC", "confidence": 0.9208152890205383}]}, {"text": "Time expressions are then parsed using an extended CYK+ algorithm, and converted to a normalized form by applying the operators recursively.", "labels": [], "entities": []}, {"text": "For evaluation, a small set of synchronous rules for English time expressions were developed.", "labels": [], "entities": []}, {"text": "Our model outperforms HeidelTime, the best time normalization system in TempEval 2013, on four different time normalization corpora.", "labels": [], "entities": [{"text": "TempEval 2013", "start_pos": 72, "end_pos": 85, "type": "DATASET", "confidence": 0.7383705973625183}]}], "introductionContent": [{"text": "Time normalization is the task of converting a natural language expression of time into a formal representation of a time on a timeline.", "labels": [], "entities": [{"text": "Time normalization", "start_pos": 0, "end_pos": 18, "type": "TASK", "confidence": 0.6806572824716568}]}, {"text": "For example, the expression the day before yesterday would be normalized to the formal representation 2013-04-12 (assuming that today is in the ISO-TimeML representation language ( . Time normalization is a crucial part of almost any information extraction task that needs to place entities or events along a timeline.", "labels": [], "entities": [{"text": "information extraction task", "start_pos": 234, "end_pos": 261, "type": "TASK", "confidence": 0.7978239258130392}]}, {"text": "And research into methods for time normalization has been growing since the ACE 1 and TempEval () challenges began to include time normalization as a shared task.", "labels": [], "entities": [{"text": "time normalization", "start_pos": 30, "end_pos": 48, "type": "TASK", "confidence": 0.6649517118930817}, {"text": "ACE 1", "start_pos": 76, "end_pos": 81, "type": "DATASET", "confidence": 0.8437150120735168}, {"text": "time normalization", "start_pos": 126, "end_pos": 144, "type": "TASK", "confidence": 0.6917820870876312}]}, {"text": "1 http://www.itl.nist.gov/iad/mig/tests/ace/ Most prior work on time normalization has taken a rule-based, string-to-string translation approach.", "labels": [], "entities": [{"text": "time normalization", "start_pos": 64, "end_pos": 82, "type": "TASK", "confidence": 0.6686333864927292}, {"text": "string-to-string translation", "start_pos": 107, "end_pos": 135, "type": "TASK", "confidence": 0.705173671245575}]}, {"text": "That is, each word in a time expression is looked up in a normalization lexicon, and then rules map this sequence of lexical entries directly to the normalized form., which had the highest performance in, which reported slightly higher performance in its own experiments, both follow this approach.", "labels": [], "entities": []}, {"text": "A drawback of this approach though is that there is no nesting of rules: for example, in HeidelTime the rules for yesterday and the day before yesterday are completely separate, despite the compositional nature of the latter.", "labels": [], "entities": [{"text": "HeidelTime", "start_pos": 89, "end_pos": 99, "type": "DATASET", "confidence": 0.9254986643791199}]}, {"text": "A notable exception to the string-to-string approach is the work of (.", "labels": [], "entities": []}, {"text": "They define a target grammar of typed pre-terminals, such as YESTERDAY (a SEQUENCE) or DAY (a DURATION), and compositional operations, such as SHIFTLEFT (a (RANGE, DURATION) \u2192 RANGE).", "labels": [], "entities": [{"text": "YESTERDAY", "start_pos": 61, "end_pos": 70, "type": "METRIC", "confidence": 0.9836640357971191}, {"text": "DAY", "start_pos": 87, "end_pos": 90, "type": "METRIC", "confidence": 0.8627499938011169}]}, {"text": "They apply an expectation-maximization approach to learn how words align to elements of the target grammar, and achieve performance close to that of the rule-based systems.", "labels": [], "entities": []}, {"text": "However, their grammar does not allow for non-binary or partially lexicalized rules (e.g. SE-QUENCE \u2192 DURATION before SEQUENCE would be impossible), and some of their primitive elements could naturally be expressed using other primitives (e.g. YESTERDAY as SHIFTLEFT(TODAY, 1 DAY)).", "labels": [], "entities": [{"text": "YESTERDAY", "start_pos": 244, "end_pos": 253, "type": "METRIC", "confidence": 0.9057159423828125}]}, {"text": "We present asynchronous grammar for time normalization that addresses these shortcomings.", "labels": [], "entities": [{"text": "time normalization", "start_pos": 36, "end_pos": 54, "type": "TASK", "confidence": 0.6961178481578827}]}, {"text": "We first define a grammar of formal operations over temporal elements.", "labels": [], "entities": []}, {"text": "We then develop synchronous rules that map time expression words to temporal opera-  tors, and perform normalization by parsing with an extended CYK+ parsing algorithm.", "labels": [], "entities": []}, {"text": "We evaluate this approach to time normalization on the TimeBank, AQUAINT, Timen and TempEval 2013 corpora.", "labels": [], "entities": [{"text": "time normalization", "start_pos": 29, "end_pos": 47, "type": "TASK", "confidence": 0.6538099348545074}, {"text": "TimeBank", "start_pos": 55, "end_pos": 63, "type": "DATASET", "confidence": 0.9718736410140991}, {"text": "AQUAINT", "start_pos": 65, "end_pos": 72, "type": "METRIC", "confidence": 0.5066298842430115}, {"text": "Timen and TempEval 2013 corpora", "start_pos": 74, "end_pos": 105, "type": "DATASET", "confidence": 0.7241107225418091}]}], "datasetContent": [{"text": "We evaluate on the AQUAINT corpus, the TimeBank corpus, the Timen corpus ( and the TempEval 2013 test set ( . We compare to two 6 state-of-the-art systems: TIMEN and HeidelTime.", "labels": [], "entities": [{"text": "AQUAINT corpus", "start_pos": 19, "end_pos": 33, "type": "DATASET", "confidence": 0.8599570989608765}, {"text": "TimeBank corpus", "start_pos": 39, "end_pos": 54, "type": "DATASET", "confidence": 0.9746686220169067}, {"text": "Timen corpus", "start_pos": 60, "end_pos": 72, "type": "DATASET", "confidence": 0.9627608954906464}, {"text": "TempEval 2013 test set", "start_pos": 83, "end_pos": 105, "type": "DATASET", "confidence": 0.8741378337144852}]}, {"text": "Our synchronous grammar approach outperformed HeidelTime on all corpora, both on the training corpora (AQUAINT and TimeBank) and on the test corpora.", "labels": [], "entities": [{"text": "AQUAINT", "start_pos": 103, "end_pos": 110, "type": "METRIC", "confidence": 0.5880591869354248}]}, {"text": "Both our model and HeidelTime outperformed TIMEN on all corpora except for the Timen corpus.", "labels": [], "entities": [{"text": "Timen corpus", "start_pos": 79, "end_pos": 91, "type": "DATASET", "confidence": 0.971136748790741}]}, {"text": "To better understand the issues in the Timen corpus, we manually inspected the 33 time expressions that TIMEN normalized correctly and our approach", "labels": [], "entities": [{"text": "Timen corpus", "start_pos": 39, "end_pos": 51, "type": "DATASET", "confidence": 0.9372382164001465}, {"text": "TIMEN normalized", "start_pos": 104, "end_pos": 120, "type": "TASK", "confidence": 0.5826607644557953}]}], "tableCaptions": [{"text": " Table 2: Performance of TIMEN, HeidelTime and our  synchronous context free grammar (SCFG) on each evalu- ation corpus. (N is the number of time expressions.)", "labels": [], "entities": []}]}