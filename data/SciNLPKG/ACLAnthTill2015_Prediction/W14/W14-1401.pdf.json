{"title": [], "abstractContent": [{"text": "This paper studies the use of records and dependent types in GF (Grammatical Framework) to build a grammar for pred-ication with an unlimited number of sub-categories, also covering extraction and coordination.", "labels": [], "entities": []}, {"text": "The grammar is implemented for Chinese, English, Finnish, and Swedish, sharing the maximum of code to identify similarities and differences between the languages.", "labels": [], "entities": []}, {"text": "Equipped with a probabilistic model and a large lexicon, the grammar has also been tested in wide-coverage machine translation.", "labels": [], "entities": [{"text": "wide-coverage machine translation", "start_pos": 93, "end_pos": 126, "type": "TASK", "confidence": 0.5951408545176188}]}, {"text": "The first evaluations show improvements in parsing speed, coverage, and robustness in comparison to earlier GF grammars.", "labels": [], "entities": [{"text": "parsing", "start_pos": 43, "end_pos": 50, "type": "TASK", "confidence": 0.9766440987586975}, {"text": "coverage", "start_pos": 58, "end_pos": 66, "type": "METRIC", "confidence": 0.991972804069519}]}, {"text": "The study confirms that dependent types, records, and functors are useful in both engineering and theoretical perspectives.", "labels": [], "entities": []}], "introductionContent": [{"text": "Predication is the basic level of syntax.", "labels": [], "entities": [{"text": "Predication", "start_pos": 0, "end_pos": 11, "type": "METRIC", "confidence": 0.6827491521835327}]}, {"text": "In logic, it means building atomic formulas by predicates.", "labels": [], "entities": []}, {"text": "In linguistics, it means building sentences by verbs.", "labels": [], "entities": []}, {"text": "Categorial grammars adapt logical predication to natural language.", "labels": [], "entities": []}, {"text": "Thus for instance transitive verbs are categorized as (n\\s/n), which is the logical type n \u2192 n \u2192 s with the information that one argument comes before the verb and the other one after.", "labels": [], "entities": []}, {"text": "But most approaches to syntax and semantics, including, introduce predicate categories as primitives rather than as function types.", "labels": [], "entities": []}, {"text": "Thus transitive verbs area category of its own, related to logic via a semantic rule.", "labels": [], "entities": []}, {"text": "This gives more expressive power, as it permits predicates with different syntactic properties and variable word order (e.g. inversion in questions).", "labels": [], "entities": []}, {"text": "A drawback is that a grammar may need a large number of categories and rules.", "labels": [], "entities": []}, {"text": "In GPSG (, and later in HPSG (, this is solved by introducing a feature called subcat for verbs.", "labels": [], "entities": [{"text": "GPSG", "start_pos": 3, "end_pos": 7, "type": "DATASET", "confidence": 0.8888046741485596}]}, {"text": "Verbs taking different arguments differ in the subcat feature but share otherwise the characteristic of being verbs.", "labels": [], "entities": []}, {"text": "In this paper, we will study the syntax and semantics of predication in GF, Grammatical Framework).", "labels": [], "entities": []}, {"text": "We will generalize both over subcategories (as in GPSG and HPSG), and over languages (as customary in GF).", "labels": [], "entities": [{"text": "HPSG", "start_pos": 59, "end_pos": 63, "type": "DATASET", "confidence": 0.817369282245636}]}, {"text": "We use dependent types to control the application of verbs to legitimate arguments, and records to control the placement of arguments in sentences.", "labels": [], "entities": []}, {"text": "The record structure is inspired by the topological model of syntax in.", "labels": [], "entities": []}, {"text": "The approach is designed to apply to all languages in the GF Resource Grammar Library (RGL,), factoring out their typological differences in a modular way.", "labels": [], "entities": [{"text": "GF Resource Grammar Library (RGL", "start_pos": 58, "end_pos": 90, "type": "DATASET", "confidence": 0.909811000029246}]}, {"text": "We have tested the grammar with four languages from three families: Chinese, English, Finnish, and Swedish.", "labels": [], "entities": []}, {"text": "As the implementation reuses old RGL code for all parts but predication, it can be ported to new languages with just a few pages of new GF code.", "labels": [], "entities": []}, {"text": "We have also tested it in wide coverage tasks, with a probabilistic tree model and a lexicon of 60,000 lemmas.", "labels": [], "entities": []}, {"text": "We will start with an introduction to the abstraction mechanisms of GF and conclude with a summary of some recent research.", "labels": [], "entities": []}, {"text": "Section 2 places GF on the map of grammar formalisms.", "labels": [], "entities": []}, {"text": "Section 3 works out an example showing how abstract syntax can be shared between languages.", "labels": [], "entities": []}, {"text": "Section 4 shows how parts of concrete syntax can be shared as well.", "labels": [], "entities": []}, {"text": "Section 5 gives the full picture of predication with dependent types and records, also addressing extraction, coordination, and semantics.", "labels": [], "entities": []}, {"text": "Section 6 gives preliminary evaluation.", "labels": [], "entities": []}, {"text": "1 2 GF: an executive summary GF belongs to a subfamily of categorial grammars inspired by.", "labels": [], "entities": []}, {"text": "These grammars make a distinction between tectogrammar, which specifies the syntactic structures (tree-like representations), and phenogrammar, which relates these structures to linear representations, such as sequences of characters, words, or phonemes.", "labels": [], "entities": []}, {"text": "Other formalisms in this family include ACG () and Lambda grammars.", "labels": [], "entities": []}, {"text": "GF inherits its name from LF, Logical Frameworks, which are type theories used for defining logics.", "labels": [], "entities": []}, {"text": "GF builds on the LF called ALF, Another Logical Framework, which implements MartinL\u00f6f's higher-level type theory (first introduced in the preface of; see Chapter 8 of for more details).", "labels": [], "entities": [{"text": "GF", "start_pos": 0, "end_pos": 2, "type": "DATASET", "confidence": 0.830915093421936}]}, {"text": "Before GF was introduced as an independent formalism in 1998, GF-like applications were built as plugins to ALF).", "labels": [], "entities": []}, {"text": "The idea was that the LF defines the tectogrammar, and the plug-in defines the phenogrammar.", "labels": [], "entities": []}, {"text": "The intended application was natural language interfaces to formal proof systems, in the style of.", "labels": [], "entities": []}, {"text": "GF was born via two additions to the natural language interface idea.", "labels": [], "entities": []}, {"text": "The first one was multilinguality: one and the same tectogrammar can be given multiple phenogrammars.", "labels": [], "entities": []}, {"text": "The second addition was parsing: the phenogrammar, which was initially just linearization (generating strings from type theoretical formulas), was reversed to rules that parse natural language into type theory.", "labels": [], "entities": [{"text": "parsing", "start_pos": 24, "end_pos": 31, "type": "TASK", "confidence": 0.971372663974762}]}, {"text": "The result was a method for translation, which combines parsing the source language with linearization into the target language.", "labels": [], "entities": [{"text": "translation", "start_pos": 28, "end_pos": 39, "type": "TASK", "confidence": 0.9869574308395386}]}, {"text": "This idea was indeed suggested in, and applied before GF in the Rosetta project, which used Montague's analysis trees as tectogrammar.", "labels": [], "entities": [{"text": "GF", "start_pos": 54, "end_pos": 56, "type": "DATASET", "confidence": 0.8153018355369568}]}, {"text": "GF can be seen as a formalization and generalization of Montague grammar.", "labels": [], "entities": []}, {"text": "Formalization, because it introduces a formal notation for the linearization rules that in Montague's work were expressed informally.", "labels": [], "entities": []}, {"text": "Generalization, because of multilinguality and also because the type system for analysis trees has dependent types.", "labels": [], "entities": []}, {"text": "Following the terminology of programming language theory, the tectogrammar is in GF called the abstract syntax whereas the phenogrammar is called the concrete syntax.", "labels": [], "entities": []}, {"text": "As in compilers and logical frameworks, the abstract syntax encodes the structure relevant for semantics, whereas the concrete syntax defines \"syntactic sugar\".", "labels": [], "entities": []}, {"text": "The resulting system turned out to be equivalent to parallel multiple context-free grammars ( and therefore parsable in polynomial time).", "labels": [], "entities": []}, {"text": "Comprehensive grammars have been written for 29 languages, and later work has optimized GF parsing and also added probabilistic disambiguation and robustness, resulting in state-of-the-art performance in wide-coverage deep parsing).", "labels": [], "entities": [{"text": "GF parsing", "start_pos": 88, "end_pos": 98, "type": "TASK", "confidence": 0.7867105901241302}]}, {"text": "3 Example: subject-verb-object sentences Let us start with an important special case of predication: the subject-verb-object structure.", "labels": [], "entities": []}, {"text": "The simplest possible rule is that is, a function that takes a subject NP, a transitive verb TV, and an object NP, and returns a sentence S.", "labels": [], "entities": []}, {"text": "This function builds abstract syntax trees.", "labels": [], "entities": []}, {"text": "Concrete syntax defines linearization rules, which convert trees into strings.", "labels": [], "entities": []}, {"text": "The above rule can give rise to different word orders, such as SVO (as in English), SOV (as in Hindi), and VSO (as in Arabic): where ++ means concatenation.", "labels": [], "entities": []}, {"text": "The above rule builds a sentence in one step.", "labels": [], "entities": []}, {"text": "A more flexible approach is to do it in two steps: complementation, forming a VP (verb phrase) from the verb and the object, and predication proper that provides the subject.", "labels": [], "entities": []}, {"text": "The abstract syntax is where --marks a comment.", "labels": [], "entities": []}, {"text": "However, the VSO order cannot be obtained in this way, because the two parts of the VP are separated by the subject.", "labels": [], "entities": []}, {"text": "The solution is to generalize linearization from strings to records.", "labels": [], "entities": []}, {"text": "Complementation can then return a record that has the verb and the object as separate fields.", "labels": [], "entities": []}, {"text": "Then we can also generate VSO: The dot (.) means projection, picking the value of afield in a record.", "labels": [], "entities": []}, {"text": "Records enable the abstract syntax to abstract away not only from word order, but also from whether a language uses discontinuous constituents.", "labels": [], "entities": []}, {"text": "VP in VSO languages is one example.", "labels": [], "entities": []}, {"text": "Once we enable discontinuous constituents, they turnout useful almost everywhere, as they enable us to delay the decision about linear order.", "labels": [], "entities": []}, {"text": "It can then be varied even inside a single language, if it depends on syntactic context (as e.g. in German; cf.) fora survey).", "labels": [], "entities": []}, {"text": "The next thing to abstract away from is inflection and agreement.", "labels": [], "entities": []}, {"text": "Given the lexicon to represent we love her.", "labels": [], "entities": []}, {"text": "If we swap the subject and the object, we get for she loves us.", "labels": [], "entities": []}, {"text": "Now, these two sentences are built from the same abstract syntax objects, but no single word is shared between them!", "labels": [], "entities": []}, {"text": "This is because the noun phrases inflect for case and the verb agrees to the subject.", "labels": [], "entities": []}, {"text": "In contrast to English, Chinese just reorders the words: women ai ta -\"we love her\" ta ai women -\"she loves us\" Thus the above rules for SVO languages work as they are for Chinese.", "labels": [], "entities": []}, {"text": "But in English, we must include case and agreement as features in the concrete syntax.", "labels": [], "entities": []}, {"text": "Thus the linearization of an NP is a record that includes a table producing the case forms, and agreement as an inherent feature: using the same type of records for VP as for TV, and a one-string record for S.", "labels": [], "entities": []}, {"text": "The Compl rule passes the agreement feature to the verb of the VP, and selects the Acc form of the object (with ! denoting selection from a table).", "labels": [], "entities": []}, {"text": "The Pred rule selects the Nom form of the subject, and attaches to this the VP form selected for np.a, i.e. the agreement feature of the subject.", "labels": [], "entities": [{"text": "Pred", "start_pos": 4, "end_pos": 8, "type": "METRIC", "confidence": 0.9873681664466858}]}], "datasetContent": [{"text": "The dependent type system for verbs, verb phrases, and clauses is a generalization of the old Resource Grammar Library, which has a set of hard-wired verb subcategories and a handful of slash categories.", "labels": [], "entities": []}, {"text": "While it covers \"all usual cases\", many logically possible ones are missing.", "labels": [], "entities": []}, {"text": "Some such cases even appear in the Penn treebank, requiring extra rules in the GF interpretation of the treebank).", "labels": [], "entities": [{"text": "Penn treebank", "start_pos": 35, "end_pos": 48, "type": "DATASET", "confidence": 0.9938247203826904}, {"text": "GF interpretation of the treebank", "start_pos": 79, "end_pos": 112, "type": "DATASET", "confidence": 0.8278578162193299}]}, {"text": "An example is a function of type which is used 12 times, for example in This is designed to get the wagons in a circle and defend the smoking franchise.", "labels": [], "entities": []}, {"text": "It has been easy to write conversion rules showing that the old coverage is preserved.", "labels": [], "entities": [{"text": "conversion", "start_pos": 26, "end_pos": 36, "type": "TASK", "confidence": 0.947737455368042}]}, {"text": "But it remains future work to see what new cases are covered by the increased generality.", "labels": [], "entities": []}, {"text": "How universal are the concrete syntax functor and interface?", "labels": [], "entities": []}, {"text": "In the standard RGL, functorization has only been attempted for families of closely related languages, with Romance languages sharing 75% of syntax code and Scandinavian languages 85%.", "labels": [], "entities": []}, {"text": "The new predication grammar shares code across all languages.", "labels": [], "entities": []}, {"text": "The figure to compare is the percentage of shared code (abstract syntax + functor + interface) of the total code written fora particular language (shared + language-specific).", "labels": [], "entities": []}, {"text": "This percentage is 70 for Chinese, 64 for English, 61 for Finnish, and 76 for Swedish, when calculated as lines of code.", "labels": [], "entities": []}, {"text": "The total amount of shared code is 760 lines.", "labels": [], "entities": []}, {"text": "One example of overrides is negation and questions in English, which are complicated by the need of auxiliaries for some verbs (go) but not for others (be).", "labels": [], "entities": [{"text": "negation", "start_pos": 28, "end_pos": 36, "type": "TASK", "confidence": 0.972079336643219}]}, {"text": "This explains why Swedish shares more of the common code than English.", "labels": [], "entities": []}, {"text": "Dependent types are not integrated in current GF parsers, but checked by postprocessing.", "labels": [], "entities": []}, {"text": "This implies a loss of speed, because many trees are constructed just to be thrown away.", "labels": [], "entities": [{"text": "speed", "start_pos": 23, "end_pos": 28, "type": "METRIC", "confidence": 0.9770495295524597}]}, {"text": "But when we specialized dependent types and rules to nondependent instances needed by the lexicon (using them as metarules in the sense of GPSG), parsing became several times faster than with the old grammar.", "labels": [], "entities": []}, {"text": "An analysis remains to do, but one hypothesis is that the speed-up is due to fixing tense and polarity earlier than in the old RGL: when starting to build VPs, as opposed to when using clauses in full sentences.", "labels": [], "entities": [{"text": "speed-up", "start_pos": 58, "end_pos": 66, "type": "METRIC", "confidence": 0.9687705039978027}]}, {"text": "Dependent types made it easy to test this refactoring, since they reduced the number of rules that had to be written.", "labels": [], "entities": []}, {"text": "Robustness in GF parsing is achieved by introducing metavariables (\"question marks\") when tree nodes cannot be constructed by the grammar (Angelov, 2011).", "labels": [], "entities": [{"text": "GF parsing", "start_pos": 14, "end_pos": 24, "type": "TASK", "confidence": 0.9112985134124756}]}, {"text": "The subtrees under a metavariable node are linearized separately, just like a sequence of chunks.", "labels": [], "entities": []}, {"text": "In translation, this leads to decrease in quality, because dependencies between chunks are not detected.", "labels": [], "entities": [{"text": "translation", "start_pos": 3, "end_pos": 14, "type": "TASK", "confidence": 0.9756801128387451}, {"text": "quality", "start_pos": 42, "end_pos": 49, "type": "METRIC", "confidence": 0.9762934446334839}]}, {"text": "The early application of tense and polarity is an improvement, as it makes verb chunks contain information that was previously detected only if the parser managed to build a whole sentence.", "labels": [], "entities": []}], "tableCaptions": []}