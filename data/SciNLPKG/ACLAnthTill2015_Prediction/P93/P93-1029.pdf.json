{"title": [{"text": "F-PATR: FUNCTIONAL CONSTRAINTS FOR UNIFICATION-BASED GRAMMARS", "labels": [], "entities": [{"text": "F-PATR", "start_pos": 0, "end_pos": 6, "type": "METRIC", "confidence": 0.85672926902771}, {"text": "FUNCTIONAL CONSTRAINTS FOR UNIFICATION-BASED GRAMMARS", "start_pos": 8, "end_pos": 61, "type": "METRIC", "confidence": 0.704813277721405}]}], "abstractContent": [{"text": "Motivation for including relational constraints other than equality within grammatical formalisms has come from discontinuous constituency and partially free word order for natural languages as well as from the need to define combinatory operations at the most basic level for languages with a two-dimensional syntax (e.g., mathematical notation, chemical equations, and various diagramming languages).", "labels": [], "entities": []}, {"text": "This paper presents F-PATR, a generalization of the PATR-II unification-based formalism , which incorporates relational constraints expressed as user-defined functions.", "labels": [], "entities": [{"text": "PATR-II unification-based formalism", "start_pos": 52, "end_pos": 87, "type": "TASK", "confidence": 0.7559582591056824}]}, {"text": "An operational semantics is given for unification that is an adaptation and extension of the approach taken by Ait-Kaci and Nasr (1989).", "labels": [], "entities": [{"text": "unification", "start_pos": 38, "end_pos": 49, "type": "TASK", "confidence": 0.9720535278320312}]}, {"text": "It is designed particularly for unification-based formalisms implemented in functional programming environments such as Lisp.", "labels": [], "entities": []}, {"text": "The application of unification in a chart parser for relational set languages is discussed briefly.", "labels": [], "entities": []}], "introductionContent": [{"text": "For the most part, unification-based grammar formalisms (e.g.,) have adopted string rewriting conventions from context-free grammar rules, assuming string concatenation as the basic combining operator external to the unification process itself.", "labels": [], "entities": [{"text": "unification-based grammar formalisms", "start_pos": 19, "end_pos": 55, "type": "TASK", "confidence": 0.9123921990394592}]}, {"text": "Kay's Functional Unification Grammar, while not borrowing the conventions of CFG rewriting rules, still assumed concatenation of strings as the underlying combining operation.", "labels": [], "entities": []}, {"text": "However, recent work in HPSG (e.g.,) and elsewhere has sought to incorporate constraints for combining operations into the unificationbased representation directly.", "labels": [], "entities": [{"text": "HPSG", "start_pos": 24, "end_pos": 28, "type": "DATASET", "confidence": 0.9191429018974304}]}, {"text": "Part of the motivation for doing so is to accommodate partially free word order and discontinuous constituency without the complication of passing along intermediate \"threading\" information within derivations.", "labels": [], "entities": []}, {"text": "Such exensions to unification grammars require the use of nonequational constraints, i.e., constraints on values other than simple conditions of equality and the logical connectives built with them. has proposed, for example, the relations permutation and sequence union to constrain word sequences in his HPSG fragment for German.", "labels": [], "entities": [{"text": "HPSG fragment for German", "start_pos": 306, "end_pos": 330, "type": "DATASET", "confidence": 0.9150751382112503}]}, {"text": "A different motivation for extending the constraint language for combination within unification grammars comes from languages with a two-dimensional syntax (e.g., mathematical notation, chemical equations, and various diagramming languages).", "labels": [], "entities": []}, {"text": "Approaching such domains from a linguistic perspective requires that grammars be capable of dealing with a richer source of data types than just strings and also with specifying a richer set of combinatory operations than simple string concatenation.", "labels": [], "entities": []}, {"text": "The approach taken by and [hereafter WWT] is to augment declarative, unification-based grammars with relational constraints.", "labels": [], "entities": [{"text": "WWT", "start_pos": 37, "end_pos": 40, "type": "DATASET", "confidence": 0.879230797290802}]}, {"text": "Combinatory operations can then be defined out of the sets of relational constraints present in rule bodies.", "labels": [], "entities": []}, {"text": "The approach in WWT includes a set-valued attribute called cover in feature structures.", "labels": [], "entities": [{"text": "WWT", "start_pos": 16, "end_pos": 19, "type": "DATASET", "confidence": 0.8676480650901794}]}, {"text": "Relations such as above, below, north-east-of, and connected-to are examples that maybe incorporated into cover constraints used in grammars for two-dimensional languages.", "labels": [], "entities": []}, {"text": "These constraints apply to sets of the basic input vocabulary, whose members may themselves be complex objects.", "labels": [], "entities": []}, {"text": "The use of sets in these grammars takes the place of strings, or sequences of words, as used in grammars for natural languages.", "labels": [], "entities": []}, {"text": "This paper presents a generalization of the PATR-II unification-based grammar formalism to incorporate relational constraints.", "labels": [], "entities": [{"text": "PATR-II unification-based grammar formalism", "start_pos": 44, "end_pos": 87, "type": "TASK", "confidence": 0.6719937175512314}]}, {"text": "The extension has been primarily motivated by the demands of combinatory operations in the syntax for two-dimensional languages although such constraints can be used to express more complex combinatory relations on strings as well as for other purposes (see, for example, work in CLG ()).", "labels": [], "entities": []}, {"text": "The approach described here arose as a result of extending a Lisp-based implementation of PATR-II used with a chart parser.", "labels": [], "entities": []}, {"text": "A natural path was provided by Ait-, who proposed integrating logic and functional programming by allowing constraints to be specified with applicative expressions.", "labels": [], "entities": []}, {"text": "This work has subsequently become one of the three cornerstones of the programming language Life.", "labels": [], "entities": []}, {"text": "The key idea is to allow interpreted functional expressions to appear as bonafide arguments in logical statements.", "labels": [], "entities": []}, {"text": "Unification operations then must allow for delaying the evaluation of functional expressions until such time as argument variables become grounded, a process that leads to what Ait-Kaci and Nasr call residuation.", "labels": [], "entities": []}, {"text": "For the most part, the adaptation of Ait-Kaci and Nasr's methods to an extension of PATR-II proved to be straitforward.", "labels": [], "entities": [{"text": "PATR-II", "start_pos": 84, "end_pos": 91, "type": "DATASET", "confidence": 0.825137197971344}]}, {"text": "However, there are two points on which the operational semantics of F-PATR unification as defined here differs from theirs.", "labels": [], "entities": [{"text": "F-PATR unification", "start_pos": 68, "end_pos": 86, "type": "TASK", "confidence": 0.7435095608234406}]}, {"text": "The first, a variation on dereferencing applicative values, was motivated by the demands of caching intermediate results imposed by chart parsing.", "labels": [], "entities": [{"text": "chart parsing", "start_pos": 132, "end_pos": 145, "type": "TASK", "confidence": 0.7084734439849854}]}, {"text": "The second, atomic disjunction, allows for more expressiveness in the grammar and also, again, was motivated by the parsing algorithm we assumed.", "labels": [], "entities": []}, {"text": "We will return to these points in Section 6.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": []}