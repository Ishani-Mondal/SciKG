{"title": [], "abstractContent": [{"text": "Synchronous Context-Free Grammars (SCFGs) have been successfully exploited as translation models in machine translation applications.", "labels": [], "entities": [{"text": "machine translation", "start_pos": 100, "end_pos": 119, "type": "TASK", "confidence": 0.7373790442943573}]}, {"text": "When parsing with an SCFG, computational complexity grows exponentially with the length of the rules, in the worst case.", "labels": [], "entities": [{"text": "parsing", "start_pos": 5, "end_pos": 12, "type": "TASK", "confidence": 0.967678427696228}]}, {"text": "In this paper we examine the problem of factorizing each rule of an input SCFG to a generatively equivalent set of rules, each having the smallest possible length.", "labels": [], "entities": []}, {"text": "Our algorithm works in time O(n log n), for each rule of length n.", "labels": [], "entities": [{"text": "O", "start_pos": 28, "end_pos": 29, "type": "METRIC", "confidence": 0.9634925127029419}]}, {"text": "This improves upon previous results and solves an open problem about recognizing permutations that can be factored.", "labels": [], "entities": []}], "introductionContent": [{"text": "Synchronous Context-Free Grammars (SCFGs) area generalization of the Context-Free Grammar (CFG) formalism to simultaneously produce strings in two languages.", "labels": [], "entities": []}, {"text": "SCFGs have a wide range of applications, including machine translation, word and phrase alignments, and automatic dictionary construction.", "labels": [], "entities": [{"text": "machine translation", "start_pos": 51, "end_pos": 70, "type": "TASK", "confidence": 0.7732719779014587}, {"text": "word and phrase alignments", "start_pos": 72, "end_pos": 98, "type": "TASK", "confidence": 0.6317442953586578}, {"text": "automatic dictionary construction", "start_pos": 104, "end_pos": 137, "type": "TASK", "confidence": 0.6087546249230703}]}, {"text": "Variations of SCFGs go back to's Syntax-Directed Translation Schemata, but also include the Inversion Transduction Grammars in, which restrict grammar rules to be binary, the synchronous grammars in, which use only a single nonterminal symbol, and the Multitext Grammars in, which allow independent rewriting, as well as other tree-based models such as and.", "labels": [], "entities": [{"text": "Syntax-Directed Translation Schemata", "start_pos": 33, "end_pos": 69, "type": "TASK", "confidence": 0.8407204548517863}]}, {"text": "When viewed as a rewriting system, an SCFG generates a set of string pairs, representing some translation relation.", "labels": [], "entities": []}, {"text": "We are concerned herewith the time complexity of parsing such a pair, according to the grammar.", "labels": [], "entities": []}, {"text": "Assume then a pair with each string having a maximum length of N , and consider an SCFG G of size |G|, with abound of n nonterminals in the right-hand side of each rule in a single dimension, which we call below the rank of G.", "labels": [], "entities": []}, {"text": "As an upper bound, parsing can be carried out in time O(|G| N n+4 ) by a dynamic programming algorithm maintaining continuous spans in one dimension.", "labels": [], "entities": [{"text": "parsing", "start_pos": 19, "end_pos": 26, "type": "TASK", "confidence": 0.9772287607192993}]}, {"text": "As a lower bound, parsing strategies with discontinuous spans in both dimensions can take time \u2126(|G| N c \u221a n ) for unfriendly permutations (.", "labels": [], "entities": []}, {"text": "A natural question to ask then is: What if we could reduce the rank of G, preserving the generated translation?", "labels": [], "entities": []}, {"text": "As in the case of CFGs, one way of doing this would be to factorize each single rule into several rules of rank strictly smaller than n.", "labels": [], "entities": []}, {"text": "It is not difficult to see that this would result in anew grammar of size at most 2 \u00b7 |G|.", "labels": [], "entities": []}, {"text": "In the time complexities reported above, we see that such a size increase would be more than compensated by the reduction in the degree of the polynomial in N . We thus conclude that a reduction in the rank of an SCFG would result in more efficient parsing algorithms, for most common parsing strategies.", "labels": [], "entities": [{"text": "parsing", "start_pos": 249, "end_pos": 256, "type": "TASK", "confidence": 0.9812549352645874}, {"text": "parsing", "start_pos": 285, "end_pos": 292, "type": "TASK", "confidence": 0.9632680416107178}]}, {"text": "In the general case, normal forms with bounded rank are not admitted by SCFGs, as shown in.", "labels": [], "entities": []}, {"text": "Nonetheless, an SCFG with a rank of n may not necessarily meet the worst case of.", "labels": [], "entities": []}, {"text": "It is then reasonable to ask if our SCFG G can be factorized, and what is the smallest rank k < n that can be obtained in this way.", "labels": [], "entities": []}, {"text": "This paper answers these two questions, by providing an algorithm that factorizes the rules of an input SCFG, resulting in anew, generatively equivalent, SCFG with rank k as low as possible.", "labels": [], "entities": []}, {"text": "The algorithm works in time O(n log n) for each rule, regardless of the rank k of the factorized rules.", "labels": [], "entities": [{"text": "O", "start_pos": 28, "end_pos": 29, "type": "METRIC", "confidence": 0.9787184000015259}]}, {"text": "As discussed above, in this way we achieve an improvement of the parsing time for SCFGs, obtaining an upper bound of O(|G| N k+4 ) by using a parsing strategy that maintains continuous Figure 1: Two permutation trees.", "labels": [], "entities": [{"text": "parsing", "start_pos": 65, "end_pos": 72, "type": "TASK", "confidence": 0.9637007117271423}, {"text": "O", "start_pos": 117, "end_pos": 118, "type": "METRIC", "confidence": 0.9790741205215454}]}, {"text": "The permutations associated with the leaves can be produced by composing the permutations at the internal nodes.", "labels": [], "entities": []}, {"text": "Previous work on this problem has been presented in, where a method is provided for casting an SCFG to a form with rank k = 2.", "labels": [], "entities": []}, {"text": "If generalized to any value of k, that algorithm would run in time O(n 2 ).", "labels": [], "entities": []}, {"text": "We thus improve existing factorization methods by almost a factor of n.", "labels": [], "entities": []}, {"text": "We also solve an open problem mentioned by, who pose the question of whether irreducible, or simple, permutations can be recognized in timeless than \u0398(n 2 ).", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": []}