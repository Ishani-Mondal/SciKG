{"title": [], "abstractContent": [{"text": "In this paper we relate a number of parsing algorithms which have been developed in very different areas of parsing theory, and which include deterministic algorithms , tabular algorithms, and a parallel algorithm.", "labels": [], "entities": [{"text": "parsing", "start_pos": 36, "end_pos": 43, "type": "TASK", "confidence": 0.9685206413269043}, {"text": "parsing theory", "start_pos": 108, "end_pos": 122, "type": "TASK", "confidence": 0.9735170304775238}]}, {"text": "We show that these algorithms are based on the same underlying ideas.", "labels": [], "entities": []}, {"text": "By relating existing ideas, we hope to provide an opportunity to improve some algorithms based on features of others.", "labels": [], "entities": []}, {"text": "A second purpose of this paper is to answer a question which has come up in the area of tabular parsing , namely how to obtain a parsing algorithm with the property that the table will contain as little entries as possible, but without the possibility that two entries represent the same subderivation.", "labels": [], "entities": [{"text": "tabular parsing", "start_pos": 88, "end_pos": 103, "type": "TASK", "confidence": 0.9208574295043945}]}], "introductionContent": [{"text": "Left-corner (LC) parsing is a parsing strategy which has been used in different guises in various areas of computer science.", "labels": [], "entities": [{"text": "Left-corner (LC) parsing", "start_pos": 0, "end_pos": 24, "type": "TASK", "confidence": 0.6144100785255432}, {"text": "parsing", "start_pos": 30, "end_pos": 37, "type": "TASK", "confidence": 0.9564375877380371}]}, {"text": "Deterministic LC parsing with k symbols of lookahead can handle the class of LC(k) grammars.", "labels": [], "entities": [{"text": "Deterministic LC parsing", "start_pos": 0, "end_pos": 24, "type": "TASK", "confidence": 0.6112992366154989}]}, {"text": "Since LC parsing is a very simple parsing technique and at the same time is able to deal with left recursion, it is often used as an alternative to top-down (TD) parsing, which cannot handle left recursion and is generally less efficient.", "labels": [], "entities": [{"text": "LC parsing", "start_pos": 6, "end_pos": 16, "type": "TASK", "confidence": 0.8163592219352722}]}, {"text": "Nondeterministic LC parsing is the foundation of a very efficient parsing algorithm, related to Tomita's algorithm and Earley's algorithm.", "labels": [], "entities": [{"text": "LC parsing", "start_pos": 17, "end_pos": 27, "type": "TASK", "confidence": 0.6314471662044525}]}, {"text": "It has one disadvantage however, which becomes noticeable when the grammar contains many rules whose right-hand sides begin with the same few grammars symbols, e.g. A ~ c~f~l I ~f~2 I ...", "labels": [], "entities": []}, {"text": "where ~ is not the empty string.", "labels": [], "entities": []}, {"text": "After an LC parser has recognized the first symbol X of such an c~, it will as next step predict all aforementioned rules.", "labels": [], "entities": []}, {"text": "This amounts to much nondeterminism, which is detrimental both to the time-complexity and the space-complexity.", "labels": [], "entities": []}, {"text": "*Supported by the Dutch Organisation for Scientific Research (NWO), under grant 00-62-518 A first attempt to solve this problem is to use predictive LR (PLR) parsing.", "labels": [], "entities": [{"text": "predictive LR (PLR) parsing", "start_pos": 138, "end_pos": 165, "type": "TASK", "confidence": 0.6311510552962621}]}, {"text": "PLR parsing allows simultaneous processing of a common prefix c~, provided that the left-hand sides of the rules are the same.", "labels": [], "entities": [{"text": "PLR parsing", "start_pos": 0, "end_pos": 11, "type": "TASK", "confidence": 0.7953534424304962}]}, {"text": "However, in case we have e.g. the rules A --* c~t31 and B --~ ~/32, where again ~ is not the empty string but now A ~ B, then PLR parsing will not improve the efficiency.", "labels": [], "entities": [{"text": "PLR parsing", "start_pos": 126, "end_pos": 137, "type": "TASK", "confidence": 0.8121088743209839}]}, {"text": "We therefore go one step further and discuss extended LR (ELR) and common-prefix (CP) parsing, which are algorithms capable of simultaneous processing of all common prefixes.", "labels": [], "entities": [{"text": "common-prefix (CP) parsing", "start_pos": 67, "end_pos": 93, "type": "TASK", "confidence": 0.7213496923446655}]}, {"text": "ELR and CP parsing are the foundation of tabular parsing algorithms and a parallel parsing algorithm from the existing literature, but they have not been described in their own right.", "labels": [], "entities": [{"text": "ELR", "start_pos": 0, "end_pos": 3, "type": "DATASET", "confidence": 0.7631579041481018}, {"text": "CP parsing", "start_pos": 8, "end_pos": 18, "type": "TASK", "confidence": 0.6237774938344955}, {"text": "tabular parsing", "start_pos": 41, "end_pos": 56, "type": "TASK", "confidence": 0.7796072363853455}]}, {"text": "To the best of the author's knowledge, the various parsing algorithms mentioned above have not been discussed together in the existing literature.", "labels": [], "entities": []}, {"text": "The main purpose of this paper is to make explicit the connections between these algorithms.", "labels": [], "entities": []}, {"text": "A second purpose of this paper is to show that CP and ELR parsing are obvious solutions to a problem of tabular parsing which can be described as follows.", "labels": [], "entities": [{"text": "ELR parsing", "start_pos": 54, "end_pos": 65, "type": "TASK", "confidence": 0.6097540855407715}, {"text": "tabular parsing", "start_pos": 104, "end_pos": 119, "type": "TASK", "confidence": 0.7862390279769897}]}, {"text": "For each parsing algorithm working on a stack there is a realisation using a parse table, where the parse table allows sharing of computation between different search paths.", "labels": [], "entities": []}, {"text": "For example, Tomita's algorithm can be seen as a tabular realisation of nondeterministic LR parsing.", "labels": [], "entities": [{"text": "LR parsing", "start_pos": 89, "end_pos": 99, "type": "TASK", "confidence": 0.7051810324192047}]}, {"text": "At this point we use the term state to indicate the symbols occurring on the stack of the original algorithm, which also occur as entries in the parse table of its tabular realisation.", "labels": [], "entities": []}, {"text": "In general, powerful algorithms working on a stack lead to efficient tabular parsing algorithms, provided the grammar can be handled almost deterministically.", "labels": [], "entities": [{"text": "tabular parsing", "start_pos": 69, "end_pos": 84, "type": "TASK", "confidence": 0.6448602080345154}]}, {"text": "In case the stack algorithm is very nondeterministic fora certain grammar however, sophistication which increases the number of states may lead to an increasing number of entries in the parse table of the tabular realization.", "labels": [], "entities": []}, {"text": "This can be informally explained by the fact that each state represents the computation of a number of subderivations.", "labels": [], "entities": []}, {"text": "If the number of states is increased then it is inevitable that at some point some states represent an overlapping collection of subderivations, which may lead to work being repeated during parsing.", "labels": [], "entities": []}, {"text": "Furthermore, the parse forest (a compact representation of all parse trees) which is output by a tabular algorithm may in this case not be optimally dense.", "labels": [], "entities": []}, {"text": "We conclude that we have a tradeoff between the case that the grammar allows almost deterministic parsing and the case that the stack algorithm is very nondeterministic fora certain grammar.", "labels": [], "entities": []}, {"text": "In the former case, sophistication leads to less entries in the table, and in the latter case, sophistication leads to more entries, provided this sophistication is realised by an increase in the number of states.", "labels": [], "entities": []}, {"text": "This is corroborated by empirical data from, which deal with tabular LR parsing.", "labels": [], "entities": [{"text": "tabular LR parsing", "start_pos": 61, "end_pos": 79, "type": "TASK", "confidence": 0.6594452261924744}]}, {"text": "As we will explain, CP and ELR parsing are more deterministic than most other parsing algorithms for many grammars, but their tabular realizations can never compute the same subderivation twice.", "labels": [], "entities": [{"text": "ELR parsing", "start_pos": 27, "end_pos": 38, "type": "TASK", "confidence": 0.6002069413661957}]}, {"text": "This represents an optimum in a range of possible parsing algorithms.", "labels": [], "entities": []}, {"text": "This paper is organized as follows.", "labels": [], "entities": []}, {"text": "First we discuss nondeterministic left-corner parsing, and demonstrate how common prefixes in a grammar maybe a source of bad performance for this technique.", "labels": [], "entities": [{"text": "nondeterministic left-corner parsing", "start_pos": 17, "end_pos": 53, "type": "TASK", "confidence": 0.6940544446309408}]}, {"text": "Then, a multitude of parsing techniques which exhibit better treatment of common prefixes is discussed.", "labels": [], "entities": [{"text": "parsing", "start_pos": 21, "end_pos": 28, "type": "TASK", "confidence": 0.9659555554389954}]}, {"text": "These techniques, including nondeterministic PLR, ELR, and CP parsing, have their origins in theory of deterministic, parallel, and tabular parsing.", "labels": [], "entities": [{"text": "CP parsing", "start_pos": 59, "end_pos": 69, "type": "TASK", "confidence": 0.7347694039344788}, {"text": "tabular parsing", "start_pos": 132, "end_pos": 147, "type": "TASK", "confidence": 0.6957972198724747}]}, {"text": "Subsequently, the application to parallel and tabular parsing is investigated more closely.", "labels": [], "entities": [{"text": "tabular parsing", "start_pos": 46, "end_pos": 61, "type": "TASK", "confidence": 0.7695212066173553}]}, {"text": "Further, we briefly describe how rules with empty right-hand sides complicate the parsing process.", "labels": [], "entities": [{"text": "parsing", "start_pos": 82, "end_pos": 89, "type": "TASK", "confidence": 0.9745332598686218}]}, {"text": "The ideas described in this paper can be generalized to head-driven parsing, as argued in.", "labels": [], "entities": [{"text": "head-driven parsing", "start_pos": 56, "end_pos": 75, "type": "TASK", "confidence": 0.6534882187843323}]}, {"text": "We will take some liberty in describing algorithms from the existing literature, since using the original descriptions would blur the similarities of the algorithms to one another.", "labels": [], "entities": []}, {"text": "In particular, we will not treat the use of lookahead, and we will consider all algorithms working on a stack to be nondeterministic.", "labels": [], "entities": []}, {"text": "We will only describe recognition algorithms.", "labels": [], "entities": []}, {"text": "Each of the algorithms can however be easily extended to yield parse trees as a side-effect of recognition.", "labels": [], "entities": []}, {"text": "The notation used in the sequel is for the most part standard and is summarised below.", "labels": [], "entities": []}, {"text": "A context-free grammar G = (T, N, P, S) consists of two finite disjoint sets N and T of nonterminals and terminals, respectively, a start symbol SE N, and a finite set of rules P.", "labels": [], "entities": []}, {"text": "Every rule has the form A --* c~, where the left-hand side (lhs) A is an element from N and the right-hand side (rhs) a is an element from V*, where V denotes (NUT).", "labels": [], "entities": []}, {"text": "P can also be seen as a relation on N \u00d7 V*.", "labels": [], "entities": []}, {"text": "We use symbols A, B, C,...", "labels": [], "entities": []}, {"text": "to range over N, symbols a, b, c,...", "labels": [], "entities": []}, {"text": "to range over T, symbols X, ]I, Z to range over V, symbols c~,.", "labels": [], "entities": []}, {"text": "to range over V*, and v, w, x,...", "labels": [], "entities": []}, {"text": "to range over T*.", "labels": [], "entities": [{"text": "T", "start_pos": 14, "end_pos": 15, "type": "METRIC", "confidence": 0.9724130630493164}]}, {"text": "We let e denote the empty string.", "labels": [], "entities": []}, {"text": "The notation of rules A --* al, A --* a2,.., with the same lhs is often simplified to A ~ c~1]a21...", "labels": [], "entities": []}, {"text": "A rule of the form A --~ e is called an epsilon rule.", "labels": [], "entities": []}, {"text": "We assume grammars do not have epsilon rules unless stated otherwise.", "labels": [], "entities": []}, {"text": "The relation P is extended to a relation ~ on V* \u00d7 V* as usual.", "labels": [], "entities": []}, {"text": "The reflexive and transitive closure of ~ is denoted by --**.", "labels": [], "entities": []}, {"text": "We define: B LA if and only if A --* Be for some a.", "labels": [], "entities": [{"text": "LA", "start_pos": 13, "end_pos": 15, "type": "METRIC", "confidence": 0.5428664684295654}]}, {"text": "The reflexive and transitive closure of / is denoted by /*, and is called the left-corner relation.", "labels": [], "entities": []}, {"text": "We say two rules A --* al and B --* a2 have a common prefix [3 if c~1 = [3\"/1 and a2 = [3'/2, for some '/1 and '/2, where [3 \u00a2 e.", "labels": [], "entities": []}, {"text": "A recognition algorithm can be specified by means of a push-down automaton A = (T, Alph, Init, ~-, Fin), which manipulates configurations of the form (F,v), where F E Alph* is the stack, constructed from left to right, and v \u2022 T* is the remaining input.", "labels": [], "entities": []}, {"text": "The initial configuration is (Init, w), where Init E Alph is a distinguished stack symbol, and w is the input.", "labels": [], "entities": []}, {"text": "The steps of an automaton are specified by means of the relation ~-.", "labels": [], "entities": []}, {"text": "Thus, (F,v) ~-(F',v') denotes that (F',v') is obtainable from (F, v) by one step of the automaton.", "labels": [], "entities": []}, {"text": "The reflexive and transitive closure of ~-is denoted by F-*.", "labels": [], "entities": [{"text": "F", "start_pos": 56, "end_pos": 57, "type": "METRIC", "confidence": 0.9368152022361755}]}, {"text": "The input w is accepted if (Init, w) F-* (Fin, e), where Fin E Alph is a distinguished stack symbol.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": []}