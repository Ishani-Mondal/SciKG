{"title": [], "abstractContent": [{"text": "Interactive spoken dialog provides many new challenges for spoken language systems.", "labels": [], "entities": []}, {"text": "One of the most critical is the prevalence of speech repairs.", "labels": [], "entities": [{"text": "speech repairs", "start_pos": 46, "end_pos": 60, "type": "TASK", "confidence": 0.7876069843769073}]}, {"text": "This paper presents an algorithm that detects and corrects speech repairs based on finding the repair pattern.", "labels": [], "entities": [{"text": "detects and corrects speech repairs", "start_pos": 38, "end_pos": 73, "type": "TASK", "confidence": 0.6024485170841217}]}, {"text": "The repair pattern is built by finding word matches and word replacements, and identifying fragments and editing terms.", "labels": [], "entities": [{"text": "word replacements", "start_pos": 56, "end_pos": 73, "type": "TASK", "confidence": 0.7093098014593124}]}, {"text": "Rather than using a set of pre-built templates, we build the pattern on the fly.", "labels": [], "entities": []}, {"text": "Ina fair test, our method, when combined with a statistical model to filter possible repairs, was successful at detecting and correcting 80% of the repairs, without using prosodic information or a parser.", "labels": [], "entities": []}], "introductionContent": [{"text": "Interactive spoken dialog provides many new challenges for spoken language systems.", "labels": [], "entities": []}, {"text": "One of the most critical is the prevalence of speech repairs.", "labels": [], "entities": [{"text": "speech repairs", "start_pos": 46, "end_pos": 60, "type": "TASK", "confidence": 0.7876069843769073}]}, {"text": "Speech repairs are dysfluencies where some of the words that the speaker utters need to be removed in order to correctly understand the speaker's meaning.", "labels": [], "entities": [{"text": "Speech repairs", "start_pos": 0, "end_pos": 14, "type": "TASK", "confidence": 0.7101283818483353}]}, {"text": "These repairs can be divided into three types: fresh starts, modifications, and abridged.", "labels": [], "entities": []}, {"text": "A fresh start is where the speaker abandons what she was saying and starts again.", "labels": [], "entities": []}, {"text": "the current plan is we take -okay let's say we start with the bananas (d91-2.2 uttl05) A modification repair is where the speech-repair modifies what was said before.", "labels": [], "entities": []}, {"text": "after the orange juice is at -the oranges are at the OJ factory (d93-19.3 utt59) An abridged repair is where the repair consists solely of a fragment and/or editing terms.", "labels": [], "entities": [{"text": "OJ factory", "start_pos": 53, "end_pos": 63, "type": "DATASET", "confidence": 0.9584261476993561}]}, {"text": "we need to -um manage to get the bananas to Dansville more quickly (d93-14.3 utt50) These examples also illustrate how speech repairs can be divided into three intervals: the removed text, the editing terms, and the resumed text (cf.,).", "labels": [], "entities": [{"text": "Dansville", "start_pos": 44, "end_pos": 53, "type": "DATASET", "confidence": 0.9202927350997925}, {"text": "speech repairs", "start_pos": 119, "end_pos": 133, "type": "TASK", "confidence": 0.7060009241104126}]}, {"text": "The removed text, which might end in a word fragment, is the text that the speaker intends to replace.", "labels": [], "entities": []}, {"text": "The end of the removed text is called the interruption point, which is marked in the above examples as \"-\".", "labels": [], "entities": []}, {"text": "This is then followed by editing terms, which can either be filled pauses, such as \"urn\", \"uh\", and \"er\", or cue phrases, such as \"I mean\", \"I guess\", and \"well\".", "labels": [], "entities": []}, {"text": "The last interval is the resumed text, the text that is intended to replace the removed text.", "labels": [], "entities": []}, {"text": "(All three intervals need notbe present in a given speech repair.)", "labels": [], "entities": []}, {"text": "In order to correct a speech repair, the removed text and the editing terms need to be deleted in order to determine what the speaker intends to say.", "labels": [], "entities": []}, {"text": "1 In our corpus of problem solving dialogs, 25% of turns contain at least one repair, 67% of repairs occur with at least one other repair in the turn, and repairs in the same turn occur on average within 6 words of each other.", "labels": [], "entities": [{"text": "problem solving dialogs", "start_pos": 19, "end_pos": 42, "type": "TASK", "confidence": 0.7447371681531271}]}, {"text": "As a result, no spoken language system will perform well without an effective way to detect and correct speech repairs.", "labels": [], "entities": []}, {"text": "We propose that most speech repairs can be detected and corrected using only local clues--it should not be necessary to test the syntactic or semantic well-formedness of the entire utterance.", "labels": [], "entities": [{"text": "speech repairs", "start_pos": 21, "end_pos": 35, "type": "TASK", "confidence": 0.7394656538963318}]}, {"text": "People do not seem to have problems comprehending speech repairs as they occur, and seem to have no problem even when multiple repairs occur in the same utterance.", "labels": [], "entities": [{"text": "comprehending speech repairs", "start_pos": 36, "end_pos": 64, "type": "TASK", "confidence": 0.7434083223342896}]}, {"text": "So, it should be possible to construct an algorithm that runs on-line, processing the input a word at a time, and committing to whether a string of words is a repair by the end of the string.", "labels": [], "entities": []}, {"text": "Such an algorithm could precede a parser, or even operate in lockstep with it.", "labels": [], "entities": []}, {"text": "An ulterior motive for not using higher level syntactic or semantic knowledge is that the coverage of parsers and semantic interpreters is not sufficient for unrestricted dialogs.", "labels": [], "entities": []}, {"text": "Recently, reported syntactic and semantic coverage of 86% for the DARPA Airline reservation corpus (.", "labels": [], "entities": [{"text": "DARPA Airline reservation corpus", "start_pos": 66, "end_pos": 98, "type": "DATASET", "confidence": 0.93547722697258}]}, {"text": "Unrestricted dialogs will present even more difficulties; not only will the speech be less grammatical, but there is also the problem of segmenting the dialog into utterance units (cf.\u2022 If speech repairs can be detected and corrected before parsing and semantic interpretation, this should simplify those modules as well as make them more robust.", "labels": [], "entities": [{"text": "semantic interpretation", "start_pos": 253, "end_pos": 276, "type": "TASK", "confidence": 0.7004106044769287}]}, {"text": "In this paper, we present an algorithm that detects and corrects modification and abridged speech repairs without doing syntactic and semantic processing.", "labels": [], "entities": [{"text": "detects and corrects modification and abridged speech repairs", "start_pos": 44, "end_pos": 105, "type": "TASK", "confidence": 0.584342461079359}]}, {"text": "The algorithm determines the text that needs to be removed by building a repair pattern, based on identification of word fragments, editing ~The removed text and editing terms might still contain pragmatic information, as the following example displays, \"Peter was \u2022..", "labels": [], "entities": []}, {"text": "well.., he was fired.", "labels": [], "entities": []}, {"text": "terms, and word correspondences between the removed and the resumed text (cf..", "labels": [], "entities": []}, {"text": "The resulting potential repairs are then passed to a statistical model that judges the proposal as either fluent speech or an actual repair.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": [{"text": " Table 2 the number of repairs in the", "labels": [], "entities": []}, {"text": " Table 3: Repair Patterns and Occurrences", "labels": [], "entities": [{"text": "Repair Patterns", "start_pos": 10, "end_pos": 25, "type": "TASK", "confidence": 0.9624729156494141}]}, {"text": " Table 4: Results of Pattern Matching", "labels": [], "entities": [{"text": "Pattern Matching", "start_pos": 21, "end_pos": 37, "type": "TASK", "confidence": 0.9631027579307556}]}]}