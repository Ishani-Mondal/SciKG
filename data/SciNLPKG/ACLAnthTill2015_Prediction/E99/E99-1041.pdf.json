{"title": [{"text": "The Treegram Index An Efficient Technique for Retrieval in Linguistic Treebanks", "labels": [], "entities": [{"text": "Treegram Index", "start_pos": 4, "end_pos": 18, "type": "DATASET", "confidence": 0.7966146469116211}]}], "abstractContent": [{"text": "Multiway trees (MT, henceforth) area common and well-understood data structure for describing hierarchical linguistic information.", "labels": [], "entities": []}, {"text": "With the availability of large treebanks, retrieval techniques for highly structured data now become essential.", "labels": [], "entities": []}, {"text": "In this contribution, we investigate the efficient retrieval of MT structures at the cost of a complex index-the Treegram Index.", "labels": [], "entities": [{"text": "MT structures", "start_pos": 64, "end_pos": 77, "type": "TASK", "confidence": 0.8674663305282593}]}, {"text": "We illustrate our approach with the VENONA retrieval system, which handles the BH t (Biblia Hebraica transeripta) treebank comprising 508,650 phrase structure trees with maximum degree eight and maximum height 17, containing altogether 3.3 million Old-Hebrew words.", "labels": [], "entities": [{"text": "BH t (Biblia Hebraica transeripta) treebank", "start_pos": 79, "end_pos": 122, "type": "DATASET", "confidence": 0.7933753728866577}]}], "introductionContent": [], "datasetContent": [{"text": "The treegram-index retrieval method given above encounters the following interesting problems: (A) A single treegram maybe very complex because of its unlimited degree and label strings; this leads to costly look-up operations.", "labels": [], "entities": []}, {"text": "(B) There are many treegrams rooting at a given node in a database tree: To accomodate queries with subtree variables, the index has to contain all matching treegrams for that subtree.", "labels": [], "entities": []}, {"text": "(c) It is quite expensive to intersect the tree sets T(DB, g) for all treegrams g contained in the query q.", "labels": [], "entities": []}, {"text": "VENONA addresses these problems by the following approach: Problem A: Processing of a single treegram: (1) Node labels hash to an integer of a few bytes: We do not consider labels structured; to model the structure of word forms, feature terms should be used 1.", "labels": [], "entities": []}, {"text": "(2) VENONA deals only with treegrams of a maximal degree d; if a tree is of greater degree, it will be transformed automatically to a d-ary tree.", "labels": [], "entities": [{"text": "VENONA", "start_pos": 4, "end_pos": 10, "type": "METRIC", "confidence": 0.5143036842346191}]}, {"text": "2 (3) For describing a single treegram g, VENONA takes each of g's hashed labels and combines it with the position of its corresponding node in a complete d-ary tree; an integer encoding g's structure completes this representation: Structure is at least as essential for tree retrieval as label information.", "labels": [], "entities": [{"text": "VENONA", "start_pos": 42, "end_pos": 48, "type": "METRIC", "confidence": 0.9230086207389832}]}, {"text": "1Due to lack of space, we cannot present our extension of treegram indexing to feature terms in this abstract.", "labels": [], "entities": []}, {"text": "2The employed algorithm is a generalization of the well-known transformation of trees to binary trees.", "labels": [], "entities": []}, {"text": "d's value is a configurable parameter of the indexgeneration.", "labels": [], "entities": []}, {"text": "Problem B VENONA uses only one treegram per node v: the treegram including every node found on the first h levels of the subtree rooted in v.", "labels": [], "entities": [{"text": "VENONA", "start_pos": 10, "end_pos": 16, "type": "METRIC", "confidence": 0.7539631724357605}]}, {"text": "This approach keeps the index small but introduces another problem: A query treegram may not appear in the treegram index as it is.", "labels": [], "entities": []}, {"text": "Therefore, VENONA expands all query treegram structures at runtime; fora given query treegram g, this expansion yields all database treegrams with a structure compatible tog.", "labels": [], "entities": []}, {"text": "That approach keeps the treegram index small and preserves efficiency.", "labels": [], "entities": []}, {"text": "Problem C The evaluation of a given query q is processed along the following steps: (1) According to q's degree and height, VENONA chooses a treegram index among those available for the tree database.", "labels": [], "entities": [{"text": "VENONA", "start_pos": 124, "end_pos": 130, "type": "METRIC", "confidence": 0.8145712018013}]}, {"text": "VENONA collects q's treegrams and represents them by sets of treegram parts.", "labels": [], "entities": []}, {"text": "For a given query treegram, VENONA expands the structure number to a set of index treegram structures and removes those labels that consist of a variable: Variables and the constraints that they impose belong to the matching phase.", "labels": [], "entities": []}, {"text": "VENONA sorts q's treegrams according to their .selectivity by estimating a treegram's selectivity based on the selectivity of its treegram parts.", "labels": [], "entities": []}, {"text": "(4) VENONA estimates how many query treegrams it has to evaluate to yield a candidate set small enough for the tree matcher; only for those it determines the corresponding index treegrams.", "labels": [], "entities": [{"text": "VENONA", "start_pos": 4, "end_pos": 10, "type": "METRIC", "confidence": 0.876250147819519}]}, {"text": "(5) VENONA processes these selected treegrams until the candidate set has the desired size--if necessary, falling back on some of the treegrams put aside.", "labels": [], "entities": [{"text": "VENONA", "start_pos": 4, "end_pos": 10, "type": "METRIC", "confidence": 0.7065106630325317}]}, {"text": "(6) Finally, the tree matcher selects the answer trees from these candidates.", "labels": [], "entities": []}], "tableCaptions": []}