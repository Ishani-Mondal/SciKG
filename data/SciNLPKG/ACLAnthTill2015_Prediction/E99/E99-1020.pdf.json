{"title": [], "abstractContent": [{"text": "We describe several tabular algorithms for Tree Adjoining Grammar parsing, creating a continuum from simple pure bottom-up algorithms to complex pre-dictive algorithms and showing what transformations must be applied to each one in order to obtain the next one in the continuum.", "labels": [], "entities": [{"text": "Tree Adjoining Grammar parsing", "start_pos": 43, "end_pos": 73, "type": "TASK", "confidence": 0.8016829341650009}]}], "introductionContent": [{"text": "Tree Adjoining Grammars area extension of CFG introduced by Joshi in  that use trees instead of productions as the primary representing structure.", "labels": [], "entities": [{"text": "CFG", "start_pos": 42, "end_pos": 45, "type": "DATASET", "confidence": 0.8732593655586243}]}, {"text": "Several parsing algorithms have been proposed for this formalism, most of them based on tabular techniques, ranging from simple bottom-up algorithms to sophisticated extensions of the Earley's algorithm (.", "labels": [], "entities": []}, {"text": "However, it is difficult to inter-relate different parsing algorithms.", "labels": [], "entities": []}, {"text": "In this paper we study several tabular algorithms for TAG parsing, showing their common characteristics and how one algorithm can be derived from another in turn, creating a continuum from simple pure bottom-up to complex predictive algorithms.", "labels": [], "entities": [{"text": "TAG parsing", "start_pos": 54, "end_pos": 65, "type": "TASK", "confidence": 0.9774841070175171}]}, {"text": "Formally, a TAG is a 5-tuple ~ = (VN,VT, S,I,A), where VN is a finite set of non-terminal symbols, VT a finite set of terminal symbols, S the axiom of the grammar, Ia finite set of initial trees and A a finite set of auxiliary trees.", "labels": [], "entities": []}, {"text": "IUA is the set of elementary trees.", "labels": [], "entities": [{"text": "IUA", "start_pos": 0, "end_pos": 3, "type": "DATASET", "confidence": 0.7715867161750793}]}, {"text": "Internal nodes are labeled by non-terminals and leaf nodes by terminals or ~, except for just one leaf per auxiliary tree (the foot) which is labeled by the same non-terminal used as the label of its root node.", "labels": [], "entities": []}, {"text": "The path in an elementary tree from the root node to the foot node is called the spine of the tree.", "labels": [], "entities": []}, {"text": "New trees are derived by adjoining: let a be a tree contaiIiing anode N ~ labeled by A and let bean auxiliary tree whose root and foot nodes are also labeled by A. Then, the adjoining of at the adjunction node N ~ is obtained by excising the subtree of a with root Na, attaching j3 to N \u00b0 and attaching the excised subtree to the foot of ~.", "labels": [], "entities": []}, {"text": "We use ~ E adj(N ~) to denote that a tree ~ maybe adjoined at node N ~ of the elementary tree a.", "labels": [], "entities": []}, {"text": "In order to describe the parsing algorithms for TAG, we must be able to represent the partial recognition of elementary trees.", "labels": [], "entities": [{"text": "TAG", "start_pos": 48, "end_pos": 51, "type": "TASK", "confidence": 0.8486874103546143}]}, {"text": "Parsing algorithms for context-free grammars usually denote partial recognition of productions by dotted productions.", "labels": [], "entities": []}, {"text": "We can extend this approach to the case of TAG by considering each elementary tree q, as formed by a set of context-free productions 7)(7): anode N ~ and its children N~...", "labels": [], "entities": []}, {"text": "N~ are represented by a production N ~ --~ N~...", "labels": [], "entities": []}, {"text": "Thus, the position of the dot in the tree is indicated by the position of the dot in a production in 7)(3' ).", "labels": [], "entities": []}, {"text": "The elements of the productions are the nodes of the tree, except for the case of elements belonging to VT U {E} in the right-hand side of production.", "labels": [], "entities": []}, {"text": "Those elements may not have children and are not candidates to be adjunction nodes, so we identify such nodes labeled by a terminal with that terminal.", "labels": [], "entities": []}, {"text": "To simplify the description of parsing algorithms we consider an additional production -r -+ Ra for each initial tree and the two additional productions T --* R ~ and F ~ ~ 2_ for each auxiliary tree B, where R ~ and F ~ correspond to the root node and the foot node of/3, respectively.", "labels": [], "entities": [{"text": "parsing", "start_pos": 31, "end_pos": 38, "type": "TASK", "confidence": 0.9674187302589417}]}, {"text": "After disabling T and 2_ as adjunction nodes the generative capability of the grammars remains intact.", "labels": [], "entities": []}, {"text": "The relation ~ of derivation on P(7) is defined by 5 ~ u if there are 5', 5\", M ~, v such that 5 = 5'M~5 \", u = 5'v~\" and M \"r --+ v E 7)(3 ') exists.", "labels": [], "entities": []}, {"text": "The reflexive and transitive closure of =~ is denoted :~ . Ina abuse of notation, we also use :~ to represent derivations involving an adjunction.", "labels": [], "entities": []}, {"text": "So, 5 ~ u if there are 5~,~\",M'r,v such that 5 = 5'M~5 '', R ~ ~ viF~v3, ~ E adj(M~), M \"r --+ v2 and v = \u00a2~t?31v2u3 ~tt . Given two pairs (p,q) and (i, j) of integers, (p,q) <_ (i,j) is satisfied if/< p and q _< j.", "labels": [], "entities": []}, {"text": "Given two integers p and q we define p U q asp if q is undefined and as q if p is undefined, being undefined in other case.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": []}