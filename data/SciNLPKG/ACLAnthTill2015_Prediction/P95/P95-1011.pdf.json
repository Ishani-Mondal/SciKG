{"title": [{"text": "Encoding Lexicalized Tree Adjoining Grammars with a Nonmonotonic Inheritance Hierarchy", "labels": [], "entities": [{"text": "Encoding Lexicalized Tree Adjoining Grammars", "start_pos": 0, "end_pos": 44, "type": "TASK", "confidence": 0.7603894948959351}]}], "abstractContent": [{"text": "This paper shows how DATR, a widely used formal language for lexical knowledge representation , can be used to define an I_TAG lexicon as an inheritance hierarchy with internal lexical rules.", "labels": [], "entities": [{"text": "lexical knowledge representation", "start_pos": 61, "end_pos": 93, "type": "TASK", "confidence": 0.6916507085164388}]}, {"text": "A bottom-up featu-ral encoding is used for LTAG trees and this allows lexical rules to be implemented as covariation constraints within feature structures.", "labels": [], "entities": []}, {"text": "Such an approach eliminates the considerable redundancy otherwise associated with an LTAG lexicon.", "labels": [], "entities": []}], "introductionContent": [{"text": "The Tree Adjoining Grammar (lAG) formalism was first introduced two decades ago, and since then there has been a steady stream of theoretical work using the formalism.", "labels": [], "entities": []}, {"text": "But it is only more recently that grammars of non-trivial size have been developed: Abeille, Bishop, Cote & Schabes (1990) describe a feature-based Lexicalized Tree Adjoining Grammar ([_'lAG) for English which subsequently became the basis for the grammar used in the XTAG system, a wide-coverage [_TAG parser.", "labels": [], "entities": []}, {"text": "The advent of such large grammars gives rise to questions of efficient representation, and the fully lexicalized character of the [TAG formalism suggests that recent research into lexical representation might be a place to look for answers (see for example Briscoe ef a/.;).", "labels": [], "entities": []}, {"text": "In this paper we explore this suggestion by showing how the lexical knowledge representation language (LKRL) DA'lR can be used to formulate a compact, hierarchical encoding of an [-'lAG.", "labels": [], "entities": []}, {"text": "The issue of efficient representation for I_'rAG 1 is discussed by, who with all fully lexicMized grammar formalisms, there is really no conceptual distinction to be drawn in I_TAG between the lexicon and the grammar: tile gramrnatical rules are just lexical properties.", "labels": [], "entities": []}, {"text": "draw attention to the considerable redundancy inherent in [-TAG lexicons that are expressed in a flat manner with no sharing of structure or properties across the elementary trees.", "labels": [], "entities": []}, {"text": "For example, XTAG currently includes over 100,000 lexemes, each of which is associated with a family of trees (typically around 20) drawn from a set of over 500 elementary trees.", "labels": [], "entities": []}, {"text": "Many of these trees have structure in common, many of the lexemes have the same tree families, and many of the trees within families are systematically related in ways which other formalisms capture using transformations or metarules.", "labels": [], "entities": []}, {"text": "However, the [TAG formalism itself does not provide any direct support for capturing such regularities.", "labels": [], "entities": []}, {"text": "Vijay-Shanker & Schabes address this problem by introducing a hierarchical lexicon structure with monotonic inheritance and lexical rules, using an approach loosely based on that of but tailored for [TAG trees rather than HPSG subcategorization lists.", "labels": [], "entities": []}, {"text": "proposes a slightly different solution, combining an inheritance component and a set of metarules 2.", "labels": [], "entities": []}, {"text": "We share their perception of the problem and agree that adopting a hierarchical approach provides the best available solution to it.", "labels": [], "entities": []}, {"text": "However, rather than creating a hierarchical lexical formalism that is specific to the [_TAG problem, we have used DATR, an LKR.L that is already quite widely known and used.", "labels": [], "entities": [{"text": "DATR", "start_pos": 115, "end_pos": 119, "type": "METRIC", "confidence": 0.8194454312324524}]}, {"text": "From an [TAG perspective, it makes sense to use an already available LKRL that was specifically designed to address these kinds of representational issues.", "labels": [], "entities": []}, {"text": "From a DATR perspective, I_TAG presents interesting problems arising from its radically lexicalist character: all grammatical relations, including unbounded dependency constructions, are represented lexically and are thus open to lexical generalization.", "labels": [], "entities": [{"text": "I_TAG", "start_pos": 25, "end_pos": 30, "type": "TASK", "confidence": 0.4702211121718089}]}, {"text": "There are also several further benefits to be gained from using an established general purpose LKRL such as DATR.", "labels": [], "entities": [{"text": "DATR", "start_pos": 108, "end_pos": 112, "type": "METRIC", "confidence": 0.7087501883506775}]}, {"text": "First, it makes it easier to compare the resulting [TAG lexicon with those associated with other types oflexical syntax: there are existing DATR 2See Section 6 for further discussion of these approaches.", "labels": [], "entities": [{"text": "DATR 2See Section 6", "start_pos": 140, "end_pos": 159, "type": "DATASET", "confidence": 0.8158625066280365}]}, {"text": "lexicon fragments for HPSG, PATR and Word Grammar, among others.", "labels": [], "entities": [{"text": "HPSG", "start_pos": 22, "end_pos": 26, "type": "DATASET", "confidence": 0.9070948362350464}, {"text": "Word Grammar", "start_pos": 37, "end_pos": 49, "type": "TASK", "confidence": 0.6704661846160889}]}, {"text": "Second, DATR is not restricted to syntactic description, so one can take advantage of existing analyses of other levels of lexical description, such as phonology, prosody, morphology, compositional semantics and lexical semantics 3.", "labels": [], "entities": []}, {"text": "Third, one can exploit existing formal and implementation work on the language 4.", "labels": [], "entities": []}, {"text": "The principal unit of (syntactic) information associated with an LTAG entry is a tree structure in which the tree nodes are labeled with syntactic categories and feature information and there is at least one leaf node labeled with a lexical category (such lexical leaf nodes are known as anchors).", "labels": [], "entities": []}, {"text": "For example, the canonical tree fora ditransitive verb such as give is shown in.", "labels": [], "entities": []}, {"text": "Following LTAG conventions (for the time being), the node labels here are gross syntactic category specifications to which additional featural information maybe added 5, and are annotated to indicate node type: <> indicates an anchor node, and I indicates a substitution node (where a 3See, for example,,,,,, Fraser &= Corbett (in press),,,,.", "labels": [], "entities": []}, {"text": "4See, for example, on compilation, on coding DAGs, on dynamic querying, Langer (1994) on reverse querying, and,, and on automatic acquisition.", "labels": [], "entities": [{"text": "automatic acquisition", "start_pos": 120, "end_pos": 141, "type": "TASK", "confidence": 0.7302521169185638}]}, {"text": "And there are at least a dozen different DATR implementations available, on various platforms and programming languages.", "labels": [], "entities": []}, {"text": "Sin fact, [TAG commonly distinguishes two sets of features at each node (top and bottota), but for simplicity we shall assume just one set in this paper.", "labels": [], "entities": []}, {"text": "fully specified tree with a compatible root label maybe attached) 6.", "labels": [], "entities": []}, {"text": "In representing such a tree in DATR, we do two things.", "labels": [], "entities": [{"text": "DATR", "start_pos": 31, "end_pos": 35, "type": "DATASET", "confidence": 0.5699021816253662}]}, {"text": "First, in keeping with the radically lexicalist character of LTAG, we describe the tree structure from its (lexical) anchor upwards 7, using a variant of bottom-up encoding of trees.", "labels": [], "entities": []}, {"text": "In this encoding, a tree is described relative to a particular distinguished leaf node (here the anchor node), using binary relations paxent, left and right, relating the node to the subtrees associated with its parent, and immediate-left and -right sisters, encoded in the same way.", "labels": [], "entities": []}, {"text": "Second, we embed the resulting tree structure (i.e., the node relations and type information) in the feature structure, so that the tree relations (left, right and parent) become features.", "labels": [], "entities": []}, {"text": "The obvious analogy here is the use of first/rest features to encode subcategorisation lists in frameworks like HPSG.", "labels": [], "entities": [{"text": "HPSG", "start_pos": 112, "end_pos": 116, "type": "DATASET", "confidence": 0.9386060833930969}]}, {"text": "Thus the syntactic feature information directly associated with the entry forgive relates to the label for the v node (for example, the value of its cat feature is v, the value of type is emchor), while specifications of subfeatures of parent relate to the label of the vP node.", "labels": [], "entities": []}, {"text": "A simple bottom-up DATR representation for the whole tree (apart from the node type information) follows: This says that Give is a verb, with vp as its parent, an s as its grandparent and an NP to the left of its parent.", "labels": [], "entities": []}, {"text": "It also has an NP to its right, and a tree rooted in a P to the right of that, with a PP parent and NP right sister.", "labels": [], "entities": []}, {"text": "The implied bottom-up tree structure is shown graphically in.", "labels": [], "entities": []}, {"text": "Here the nodes are laid out just as in, but related via parent, left and right links, rather than the more usual (implicitly ordered) daughter links.", "labels": [], "entities": []}, {"text": "Notice in particular that the right link from the object noun-phrase node points to the preposition node, not its phrasal parent -this whole subtree is itself encoded bottom-up.", "labels": [], "entities": []}, {"text": "Nevertheless, the full tree structure is completely and accurately represented by this encoding.", "labels": [], "entities": []}, {"text": "s LTAG's other tree-building operation is adjunetion, which allows a tree-fragment to be spliced into the body of a tree.", "labels": [], "entities": []}, {"text": "However, we only need to concern ourselves herewith the representation of the trees involved, not with the substitution/adjunction distinction.", "labels": [], "entities": []}, {"text": "rThe tree in has more than one anchor -in such cases it is generally easy to decide which anchor is the most appropriate root for the tree (here, the verb anchor).", "labels": [], "entities": []}, {"text": "Once we adopt this representational strategy, writing an LTAG lexicon in DATR becomes similar to writing any other type of lexicalist grammar's lexicon in an inheritance-based LKRL.", "labels": [], "entities": []}, {"text": "In HPSG, for example, the subcategorisation frames are coded as lists of categories, whilst in LTAG they are coded as trees.", "labels": [], "entities": [{"text": "HPSG", "start_pos": 3, "end_pos": 7, "type": "DATASET", "confidence": 0.9512647390365601}, {"text": "LTAG", "start_pos": 95, "end_pos": 99, "type": "DATASET", "confidence": 0.8807156682014465}]}, {"text": "But, in both cases, the problem is one of concisely describing feature structures associated with lexical entries and relationships between lexical entries.", "labels": [], "entities": []}, {"text": "The same kinds of generalization arise and the same techniques are applicable.", "labels": [], "entities": []}, {"text": "Of course, the presence of complete trees and the fully lexicalized approach provide scope for capturing generalizations lexically that are not available to approaches that only identify parent and sibling nodes, say, in the lexical entries.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": []}