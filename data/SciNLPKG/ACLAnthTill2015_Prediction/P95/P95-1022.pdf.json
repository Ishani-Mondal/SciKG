{"title": [{"text": "The intersection of Finite State Automata and Definite Clause Grammars Gertjan van Noord", "labels": [], "entities": []}], "abstractContent": [{"text": "Bernard Lang defines parsing as ~ calculation of the intersection of a FSA (the input) and a CFG.", "labels": [], "entities": [{"text": "parsing", "start_pos": 21, "end_pos": 28, "type": "TASK", "confidence": 0.9710277915000916}, {"text": "FSA", "start_pos": 71, "end_pos": 74, "type": "METRIC", "confidence": 0.5097127556800842}, {"text": "CFG", "start_pos": 93, "end_pos": 96, "type": "DATASET", "confidence": 0.9217381477355957}]}, {"text": "Viewing the input for parsing as a FSA rather than as a string combines well with some approaches in speech understanding systems, in which parsing takes a word lattice as input (rather than a word string).", "labels": [], "entities": [{"text": "parsing as a FSA", "start_pos": 22, "end_pos": 38, "type": "TASK", "confidence": 0.6481771916151047}, {"text": "speech understanding", "start_pos": 101, "end_pos": 121, "type": "TASK", "confidence": 0.7036223709583282}]}, {"text": "Furthermore, certain techniques for robust parsing can be modelled as finite state transducers.", "labels": [], "entities": []}, {"text": "In this paper we investigate how we can generalize this approach for unification grammars.", "labels": [], "entities": [{"text": "unification grammars", "start_pos": 69, "end_pos": 89, "type": "TASK", "confidence": 0.9342383444309235}]}, {"text": "In particular we will concentrate on how we might the calculation of the intersection of a FSA and a DCG.", "labels": [], "entities": [{"text": "FSA", "start_pos": 91, "end_pos": 94, "type": "DATASET", "confidence": 0.6319561004638672}]}, {"text": "It is shown that existing parsing algorithms can be easily extended for FSA inputs.", "labels": [], "entities": [{"text": "FSA inputs", "start_pos": 72, "end_pos": 82, "type": "TASK", "confidence": 0.7200106084346771}]}, {"text": "However, we also show that the termination properties change drastically: we show that it is undecidable whether the intersection of a FSA and a DCG is empty (even if the DCG is off-line parsable).", "labels": [], "entities": []}, {"text": "Furthermore we discuss approaches to cope with the problem.", "labels": [], "entities": []}], "introductionContent": [{"text": "In this paper we are concerned with the syntactic analysis phase of a natural language understanding system.", "labels": [], "entities": [{"text": "syntactic analysis", "start_pos": 40, "end_pos": 58, "type": "TASK", "confidence": 0.725035548210144}, {"text": "natural language understanding", "start_pos": 70, "end_pos": 100, "type": "TASK", "confidence": 0.658024658759435}]}, {"text": "Ordinarily, the input of such a system is a sequence of words.", "labels": [], "entities": []}, {"text": "However, following Bernard Lang we argue that it might be fruitful to take the input more generally as a finite state automaton (FSA) to model cases in which we are uncertain about the actual input.", "labels": [], "entities": []}, {"text": "Parsing uncertain input might be necessary in case of ill-formed textual input, or in case of speech input.", "labels": [], "entities": [{"text": "Parsing uncertain input", "start_pos": 0, "end_pos": 23, "type": "TASK", "confidence": 0.8859025239944458}]}, {"text": "For example, if a natural language understanding system is interfaced with a speech recognition component, chances are that this co~t is uncertain about the actual string of words that has been uttered, and thus produces a word lattice of the most promising hypotheses, rather than a single sequence of words.", "labels": [], "entities": []}, {"text": "FSA of course generalizes such word lattices.", "labels": [], "entities": [{"text": "FSA", "start_pos": 0, "end_pos": 3, "type": "DATASET", "confidence": 0.9692689776420593}]}, {"text": "As another example, certain techniques to deal with ill-formed input can be characterized as finite state transducers; the composition of an input string with such a finite state transducer results in a FSA that can then be input for syntactic parsing.", "labels": [], "entities": [{"text": "FSA", "start_pos": 203, "end_pos": 206, "type": "METRIC", "confidence": 0.7689129710197449}, {"text": "syntactic parsing", "start_pos": 234, "end_pos": 251, "type": "TASK", "confidence": 0.6955780535936356}]}, {"text": "Such an approach allows for the treatment of missing, extraneous, interchanged or misused words.", "labels": [], "entities": [{"text": "treatment of missing, extraneous, interchanged or misused words", "start_pos": 32, "end_pos": 95, "type": "TASK", "confidence": 0.7440170466899871}]}, {"text": "Such techniques might be of use both in the case of written and spoken language input.", "labels": [], "entities": []}, {"text": "In the latter case another possible application concerns the treatment of phenomena such as repairs.", "labels": [], "entities": []}, {"text": "Note that we allow the input to be a full FSA (possibly including cycles, etc.) since some of the above-mentioned techniques indeed result in cycles.", "labels": [], "entities": [{"text": "FSA", "start_pos": 42, "end_pos": 45, "type": "DATASET", "confidence": 0.3546963334083557}]}, {"text": "Whereas an ordinary word-graph always defines a finite language, a FSA of course can easily define an infinite number of sentences.", "labels": [], "entities": [{"text": "FSA", "start_pos": 67, "end_pos": 70, "type": "DATASET", "confidence": 0.7652389407157898}]}, {"text": "Cycles might emerge to treat unknown sequences of words, i.e. sentences with unknown parts of unknown lengths.", "labels": [], "entities": []}, {"text": "As suggested by an ACL reviewer, one could also try to model haplology phenomena (such as the's in English sentences like 'The chef at Joe's hat', where 'Joe's\" is the name of a restaurant) using a finite state transducer.", "labels": [], "entities": []}, {"text": "Ina straightforward approach this would also lead to a finite-state automaton with cycles.", "labels": [], "entities": []}, {"text": "It can be shown that the computation of the intersection of a FSA and a CFG requires only a rain-imal generalization of existing parsing algorithms.", "labels": [], "entities": [{"text": "FSA", "start_pos": 62, "end_pos": 65, "type": "DATASET", "confidence": 0.788106381893158}, {"text": "CFG", "start_pos": 72, "end_pos": 75, "type": "DATASET", "confidence": 0.8151918053627014}]}, {"text": "We simply replace the usual string positions with the names of the states in the FSA.", "labels": [], "entities": [{"text": "FSA", "start_pos": 81, "end_pos": 84, "type": "DATASET", "confidence": 0.9583645462989807}]}, {"text": "It is also straightforward to show that the complexity of this process is cubic in the number of states of the FSA (in the case of ordinary parsing the number of states equals n + 1)) (assuming the right-hand-sides of grammar rules have at most two categories).", "labels": [], "entities": [{"text": "FSA", "start_pos": 111, "end_pos": 114, "type": "DATASET", "confidence": 0.6183040142059326}]}, {"text": "In this paper we investigate whether the same techniques can be applied in case the grammar is a constraint-based grammar rather than a CFG.", "labels": [], "entities": [{"text": "CFG", "start_pos": 136, "end_pos": 139, "type": "DATASET", "confidence": 0.8730501532554626}]}, {"text": "For specificity we will take the grammar to be a Definite Clause Grammar (DCG).", "labels": [], "entities": []}, {"text": "A DCG is a simple example of a family of constraintbased grammar formalisms that are widely used in natural language analysis (and generation).", "labels": [], "entities": [{"text": "natural language analysis", "start_pos": 100, "end_pos": 125, "type": "TASK", "confidence": 0.6628669599692026}]}, {"text": "The main findings of this paper can be extended to other members of that family of constraint-based grammar formalisms.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": []}