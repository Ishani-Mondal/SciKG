{"title": [{"text": "Incremental Interpretation of Categorial Grammar*", "labels": [], "entities": [{"text": "Incremental Interpretation of Categorial Grammar", "start_pos": 0, "end_pos": 48, "type": "TASK", "confidence": 0.9061679005622864}]}], "abstractContent": [{"text": "The paper describes a parser for Categorial Grammar which provides fully word byword incremental interpretation.", "labels": [], "entities": [{"text": "Categorial Grammar", "start_pos": 33, "end_pos": 51, "type": "TASK", "confidence": 0.7884503901004791}]}, {"text": "The parser does not require fragments of sentences to form constituents, and thereby avoids problems of spurious ambiguity.", "labels": [], "entities": []}, {"text": "The paper includes a brief discussion of the relationship between basic Categorial Grammar and other formalisms such as HPSG, Dependency Grammar and the Lambek Calculus.", "labels": [], "entities": [{"text": "HPSG", "start_pos": 120, "end_pos": 124, "type": "DATASET", "confidence": 0.8102766871452332}, {"text": "Lambek Calculus", "start_pos": 153, "end_pos": 168, "type": "DATASET", "confidence": 0.9537307322025299}]}, {"text": "It also includes a discussion of some of the issues which arise when parsing lexicalised grammars, and the possibilities for using statistical techniques for tuning to particular languages .", "labels": [], "entities": [{"text": "parsing lexicalised grammars", "start_pos": 69, "end_pos": 97, "type": "TASK", "confidence": 0.897269050280253}]}], "introductionContent": [{"text": "There is a large body of psycholinguistic evidence which suggests that meaning can be extracted before the end of a sentence, and before the end of phrasal constituents (e.g. Marslen-).", "labels": [], "entities": []}, {"text": "There is also recent evidence suggesting that, during speech processing, partial interpretations can be built extremely rapidly, even before words are completed 1.", "labels": [], "entities": []}, {"text": "There are also potential computational applications for incremental interpretation, including early parse filtering using statistics based on logical form plausibility, and interpretation of fragments of dialogues (a survey is provided by, henceforth referred to as M&:C).", "labels": [], "entities": [{"text": "incremental interpretation", "start_pos": 56, "end_pos": 82, "type": "TASK", "confidence": 0.7191168963909149}, {"text": "parse filtering", "start_pos": 100, "end_pos": 115, "type": "TASK", "confidence": 0.8688753247261047}, {"text": "interpretation of fragments of dialogues", "start_pos": 173, "end_pos": 213, "type": "TASK", "confidence": 0.8732205390930176}]}, {"text": "In the current computational and psycholinguistic literature there are two main approaches to the incremental construction of logical forms.", "labels": [], "entities": []}, {"text": "One approach is to use a grammar with 'non-standard' *This research was supported by the U.K. Science and Engineering Research Council, grant RR30718.", "labels": [], "entities": [{"text": "U.K. Science and Engineering Research Council", "start_pos": 89, "end_pos": 134, "type": "DATASET", "confidence": 0.7301573952039083}, {"text": "RR30718", "start_pos": 142, "end_pos": 149, "type": "DATASET", "confidence": 0.4840364456176758}]}, {"text": "I am grateful to Patrick Sturt, Carl Vogel, and the reviewers for comments on an earlier version.", "labels": [], "entities": []}, {"text": "1Spivey-Knowlton et al. reported 3 experiments.", "labels": [], "entities": []}, {"text": "One showed effects before the end of a word when there was no other appropriate word with the same initial phonology.", "labels": [], "entities": []}, {"text": "Another showed on-line effects from adjectives and determiners during noun phrase processing.", "labels": [], "entities": [{"text": "noun phrase processing", "start_pos": 70, "end_pos": 92, "type": "TASK", "confidence": 0.7342715859413147}]}, {"text": "constituency, so that an initial fragment of a sentence, such as John likes, can be treated as a constituent, and hence be assigned a type and a semantics.", "labels": [], "entities": []}, {"text": "This approach is exemplified by Combinatory Categorial Grammar, CCG, which takes a basic CG with just application, and adds various new ways of combining elements together 2.", "labels": [], "entities": []}, {"text": "Incremental interpretation can then be achieved using a standard bottom-up shift reduce parser, working from left to right along the sentence.", "labels": [], "entities": [{"text": "Incremental interpretation", "start_pos": 0, "end_pos": 26, "type": "TASK", "confidence": 0.7978114187717438}]}, {"text": "The alternative approach, exemplified by the work of Stabler on top-down parsing, and Pulman on left-corner parsing) is to associate a semantics directly with the partial structures formed during a topdown or left-corner parse.", "labels": [], "entities": []}, {"text": "For example, a syntax tree missing a noun phrase, such as the following s /\\ np vp John / \\ v np\" likes can be given a semantics as a function from entities to truth values i.e., without having to say that John likes is a constituent.", "labels": [], "entities": []}, {"text": "Neither approach is without problems.", "labels": [], "entities": []}, {"text": "If a grammar is augmented with operations which are powerful enough to make most initial fragments constituents, then there maybe unwanted interactions with the rest of the grammar (examples of this in the case of CCG and the Lambek Calculus are given in Section 2).", "labels": [], "entities": [{"text": "Lambek Calculus", "start_pos": 226, "end_pos": 241, "type": "DATASET", "confidence": 0.9048281908035278}]}, {"text": "The addition of extra operations also means that, for any given reading of a sentence there will generally be many different possible derivations (so-called 'spurious' ambiguity), making simple parsing strategies such as shift-reduce highly inefficient.", "labels": [], "entities": []}, {"text": "The limitations of the parsing approaches become evident when we consider grammars with left recursion.", "labels": [], "entities": []}, {"text": "In such cases a simple top-down parser will be incomplete, and a left corner parser will resort to buffering the input (so won't be fully 2Note that CCG doesn't provide a type for all initial fragments of sentences.", "labels": [], "entities": []}, {"text": "For example, it gives a type to John thinks Mary, but not to John thinks each.", "labels": [], "entities": []}, {"text": "In contrast the Lambek Calculus (Lambek 1958) provides an infinite number of types for any initial sentence fragment.", "labels": [], "entities": [{"text": "Lambek Calculus (Lambek 1958)", "start_pos": 16, "end_pos": 45, "type": "DATASET", "confidence": 0.8760645389556885}]}, {"text": "M&C illustrate the problem by considering the fragment Mary thinks John.", "labels": [], "entities": []}, {"text": "This has a small number of possible semantic representations (the exact number depending upon the grammar) e.g. ),P.thinks (mary, P (john)) AP.AQ.", "labels": [], "entities": [{"text": "AP.AQ", "start_pos": 140, "end_pos": 145, "type": "METRIC", "confidence": 0.8839070200920105}]}, {"text": "Q (thinks(mary,P (john))) ),P.AR.", "labels": [], "entities": []}, {"text": "(R(Ax.thinks(x,P (john)))) (mary) The second representation is appropriate if the sentence finishes with a sentential modifier.", "labels": [], "entities": []}, {"text": "The third allows thereto be a verb phrase modifier.", "labels": [], "entities": []}, {"text": "If the semantic representation is to be read off syntactic structure, then the parser must provide a single syntax tree (possibly with empty nodes).", "labels": [], "entities": []}, {"text": "However, there are actually any number of such syntax trees corresponding to, for example, the first semantic representation, since the np and the scan be arbitrarily far apart.", "labels": [], "entities": []}, {"text": "The following tree is suitable for the sentence Mary thinks John shaves but not for e.g..", "labels": [], "entities": []}, {"text": "One further possibility is to choose a single syntax tree, and to use destructive tree operations later in the parse a.", "labels": [], "entities": []}, {"text": "The approach which we will adopt here is based on.", "labels": [], "entities": []}, {"text": "Partial syntax trees can be regarded as performing two main roles.", "labels": [], "entities": []}, {"text": "The first is to provide syntactic information which guides how the rest of the sentence can be integrated into the tree.", "labels": [], "entities": []}, {"text": "The second is to provide a basis fora semantic representation.", "labels": [], "entities": []}, {"text": "The first role can be captured using syntactic types, where each type corresponds to a potentially infinite number of partial syntax trees.", "labels": [], "entities": []}, {"text": "The second role can be captured by the parser constructing semantic representations directly.", "labels": [], "entities": []}, {"text": "The general processing model therefore consists of transitions of the form: Syntactic type i -+ Syntactic typei+ 1 Semantic repi Semantic repi+ 1 3This might turnout to be similar to one view of Tree Adjoining Grammar, where adjunction adds into a pre-existing well-formed tree structure.", "labels": [], "entities": []}, {"text": "It is also closer to some methods for incremental adaptation of discourse structures, where additions are allowed to the right-frontier of a tree structure (e.g..", "labels": [], "entities": []}, {"text": "There are however problems with this kind of approach when features are considered (see e.g..", "labels": [], "entities": []}, {"text": "This provides a state-transition or dynamic model of processing, with each state being a pair of a syntactic type and a semantic value.", "labels": [], "entities": []}, {"text": "The main difference between our approach and that of is that it is based on a more expressive grammar formalism, Applicative Categorial Grammar, as opposed to Lexicalised Dependency Grammar.", "labels": [], "entities": []}, {"text": "Applicative Categorial Grammars allow categories to have arguments which are themselves functions (e.g. very can be treated as a function of a function, and given the type (n/n)/(n/n) when used as an adjectival modifier).", "labels": [], "entities": [{"text": "Applicative Categorial Grammars", "start_pos": 0, "end_pos": 31, "type": "TASK", "confidence": 0.6732130547364553}]}, {"text": "The ability to deal with functions of functions has advantages in enabling more elegant linguistic descriptions, and in providing one kind of robust parsing: the parser never fails until the last word, since there could always be a final word which is a function overall the constituents formed so far.", "labels": [], "entities": []}, {"text": "However, there is a corresponding problem of far greater non-determinism, with even unambiguous words allowing many possible transitions.", "labels": [], "entities": []}, {"text": "It therefore becomes crucial to either perform some kind of ambiguity packing, or language tuning.", "labels": [], "entities": [{"text": "ambiguity packing", "start_pos": 60, "end_pos": 77, "type": "TASK", "confidence": 0.7564016580581665}, {"text": "language tuning", "start_pos": 82, "end_pos": 97, "type": "TASK", "confidence": 0.7648042738437653}]}, {"text": "This will be discussed in the final section of the paper.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": []}