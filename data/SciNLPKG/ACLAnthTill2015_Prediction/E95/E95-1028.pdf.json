{"title": [{"text": "Rapid Development of Morphological Descriptions for Full Language Processing Systems", "labels": [], "entities": []}], "abstractContent": [{"text": "I describe a compiler and development environment for feature-augmented two-level morphology rules integrated into a full NLP system.", "labels": [], "entities": []}, {"text": "The compiler is optimized fora class of languages including many or most European ones, and for rapid development and debug-ging of descriptions of new languages.", "labels": [], "entities": []}, {"text": "The key design decision is to compose morphophonological and morphosyntac-tic information, but not the lexicon, when compiling the description.", "labels": [], "entities": []}, {"text": "This results in typical compilation times of about a minute, and has allowed a reasonably full, feature-based description of French inflectional morphology to be developed in about a month by a linguist new to the system.", "labels": [], "entities": []}], "introductionContent": [{"text": "The paradigm of two-level morphology) has become popular for handling word formation phenomena in a variety of languages.", "labels": [], "entities": [{"text": "word formation phenomena", "start_pos": 70, "end_pos": 94, "type": "TASK", "confidence": 0.7930611073970795}]}, {"text": "The original formulation has been extended to allow morphotactic constraints to be expressed by feature specification) rather than Koskenniemi's less perspicuous device of continuation classes.", "labels": [], "entities": []}, {"text": "Methods for the automatic compilation of rules from a notation convenient for the rule-writer into finitestate automata have also been developed, allowing the efficient analysis and synthesis of word forms.", "labels": [], "entities": []}, {"text": "The automata maybe derived from the rules alone, or involve composition with the lexicon.", "labels": [], "entities": []}, {"text": "However, there is often a trade-off between runtime efficiency and factors important for rapid and accurate system development, such as perspicuity of notation, ease of debugging, speed of compilation and the size of its output, and the independence of the morphological and lexical components.", "labels": [], "entities": []}, {"text": "In compilation, one may compose any or all of (a) the two-level rule set, (b) the set of affixes and their allowed combinations, and (c) the lexicon; see for an exposition of the mathematical basis.", "labels": [], "entities": []}, {"text": "The type of compilation appropriate for rapid development and acceptable run-time performance depends on, at least, the nature of the language being described and the number of base forms in the lexicon; that is, on the position in the three-dimensional space defined by (a), (b) and (c).", "labels": [], "entities": []}, {"text": "For example, English inflectional morphology is relatively simple; dimensions (a) and (b) are fairly small, so if (c), the lexicon, is known in advance and is of manageable size, then the entire task of morphological anMysis can be carried out at compile time, producing a list of analysed word forms which need only be looked up at run time, or a network which can be traversed very simply.", "labels": [], "entities": [{"text": "English inflectional morphology", "start_pos": 13, "end_pos": 44, "type": "TASK", "confidence": 0.682099719842275}]}, {"text": "Alternatively, there maybe no need to provide as powerful a mechanism as two-level morphology at all; a simpler device such as affix stripping) or merely listing all inflected forms explicitly maybe preferable.", "labels": [], "entities": []}, {"text": "For agglutinative languages such as Korean,, dimension (b) is very large, so creating an exhaustive word list is out of the question unless the lexicon is trivial.", "labels": [], "entities": [{"text": "dimension (b)", "start_pos": 45, "end_pos": 58, "type": "METRIC", "confidence": 0.9358066767454147}]}, {"text": "Compilation to a network may still make sense, however, and because these languages tend to exhibit few non-eoncatenative morphophonological phenomena other than vowel harmony, the continuation class mechanism may suffice to describe the allowed affix sequences at the surface level.", "labels": [], "entities": []}, {"text": "Many European languages are of the inflecting type, and occupy still another region of the space of difficulty.", "labels": [], "entities": []}, {"text": "They are too complex morphologically to yield easily to the simpler techniques that can work for English.", "labels": [], "entities": []}, {"text": "The phonological or orthographic changes involved in affixation maybe quite complex, so dimension (a) can be laige, and a feature mechanism maybe needed to handle such varied but interrelated morphosyn-tactic phenomena such as umlaut, case, number, gender, and different morphological paradigms.", "labels": [], "entities": []}, {"text": "On the other hand, while there maybe many different affixes, their possibilities for combination within a word are fairly limited, so dimension (b) is quite manageable.", "labels": [], "entities": [{"text": "dimension (b)", "start_pos": 134, "end_pos": 147, "type": "METRIC", "confidence": 0.9251973778009415}]}, {"text": "This paper describes a representation and associated compiler intended for two-level morphological descriptions of the written forms of inflecting languages.", "labels": [], "entities": []}, {"text": "The system described is a component of the Core Language Engine (CLE; AIshawi, 1992), a general-purpose language analyser and generator implemented in Prolog which supports both a built-in lexicon and access to large external lexical databases.", "labels": [], "entities": [{"text": "Core Language Engine (CLE; AIshawi, 1992)", "start_pos": 43, "end_pos": 84, "type": "DATASET", "confidence": 0.6428459465503693}]}, {"text": "In this context, highly efficient word analysis and generation at run-time are less important than ensuring that the morphology mechanism is expressive, is easy to debug, and allows relatively quick compilation.", "labels": [], "entities": [{"text": "word analysis", "start_pos": 34, "end_pos": 47, "type": "TASK", "confidence": 0.7339252084493637}]}, {"text": "Morphology also needs to be well integrated with other processing levels.", "labels": [], "entities": [{"text": "Morphology", "start_pos": 0, "end_pos": 10, "type": "TASK", "confidence": 0.8687448501586914}]}, {"text": "In particular, it should be possible to specify relations among morphosyntactic and morphophonological rules and lexical entries; for the convenience of developers, this is done by means of feature equations.", "labels": [], "entities": []}, {"text": "Further, it cannot be assumed that the lexicon has been fully specified when the morphology rules are compiled.", "labels": [], "entities": []}, {"text": "Developers may wish to add and test further lexical entries without frequently recompiling the rules, and it may also be necessary to deal with unknown words at run time, for example by querying a large external lexical database or attempting spelling correction.", "labels": [], "entities": [{"text": "spelling correction", "start_pos": 243, "end_pos": 262, "type": "TASK", "confidence": 0.8662352561950684}]}, {"text": "Also, both analysis and generation of word forms are required.", "labels": [], "entities": []}, {"text": "Run-time speed need only be enough to make the time spent on morphology small compared to sententia] and contextual processing.", "labels": [], "entities": []}, {"text": "These parameters -languages with a complex morphology/syntax interface but a limited number of affix combinations, tasks where the lexicon is not necessarily known at compile time, bidirectional processing, and the need to ease development rather than optimize run-time efficiencydictate the design of the morphology compiler described in this paper, in which spelling rules and possible affix combinations (items (a) and (b)), but not the lexicon (item (c)), are composed in the compilation phase.", "labels": [], "entities": []}, {"text": "Descriptions of French, Polish and English inflectional morphology have been developed for it, and I show how various aspeers of the mechanism allow phenomena in these languages to be handled.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": []}