{"title": [{"text": "A Meta-Algorithm for the Generation of Referring Expressions", "labels": [], "entities": []}], "abstractContent": [{"text": "This paper describes anew approach to the generation of referring expressions.", "labels": [], "entities": []}, {"text": "We propose to formalize a scene as a labeled directed graph and describe content selection as a subgraph construction problem.", "labels": [], "entities": []}, {"text": "Cost functions are used to guide the search process and to give preference to some solutions over others.", "labels": [], "entities": []}, {"text": "The resulting graph algorithm can be seen as a meta-algorithm in the sense that defining cost functions in different ways allows us to mimic-and even improve-a number of well-known algorithms.", "labels": [], "entities": []}], "introductionContent": [{"text": "The generation of referring expressions is one of the most common tasks in natural language generation, and has been addressed by many researchers in the past two decades.", "labels": [], "entities": [{"text": "natural language generation", "start_pos": 75, "end_pos": 102, "type": "TASK", "confidence": 0.6716196537017822}]}, {"text": "As a result, there are many different algorithms for the generation of referring expressions, each with its own objectives: some aim at producing the shortest possible description, others focus on efficiency or realistic output.", "labels": [], "entities": []}, {"text": "The degree of detail in which the various algorithms are described differs considerably, and as a result it is often difficult to compare the various proposals.", "labels": [], "entities": []}, {"text": "In addition, most of the algorithms are primarily concerned with the generation of descriptions only using properties of the target object.", "labels": [], "entities": []}, {"text": "Consequently, the problem of generating relational descriptions (i.e., descriptions which incorporate references to other objects to single out the target object) has not received the attention it deserves.", "labels": [], "entities": []}, {"text": "In this paper, we describe a general, graphtheoretic approach to the generation of referring expressions.", "labels": [], "entities": []}, {"text": "We propose to formalize a scene (i.e., a domain of objects and their properties and relations) as a labeled directed graph and describe the content selection problem -which properties and relations to include in a description for an object?-as a subgraph construction problem.", "labels": [], "entities": []}, {"text": "The graph perspective has three main advantages.", "labels": [], "entities": []}, {"text": "The first one is that there are many attractive algorithms for dealing with graph structures.", "labels": [], "entities": []}, {"text": "In this paper, we describe a branch and bound algorithm for finding the relevant subgraphs, where we use cost functions to guide the search process.", "labels": [], "entities": []}, {"text": "Arguably, the proposed algorithm is a metaalgorithm, in the sense that by defining the cost function in different ways, we can mimic various well-known algorithms for the generation of referring expressions.", "labels": [], "entities": []}, {"text": "A second advantage of the graph-theoretical framework is that it does not run into problems with relational descriptions, due to the fact that properties and relations are formalized in the same way, namely as edges in a graph.", "labels": [], "entities": []}, {"text": "The third advantage is that the combined usage of graphs and cost-functions paves the way fora natural integration of traditional rule-based approaches to generation with more recent statistical approaches (e.g.,) in a single algorithm.", "labels": [], "entities": []}, {"text": "The outline of this paper is as follows.", "labels": [], "entities": []}, {"text": "In section 2, we describe how scenes can be described as labeled directed graphs and show how content selection can be formalized as a subgraph construction problem.", "labels": [], "entities": []}, {"text": "Section 3 contains a sketch of the branch and bound algorithm, which is illustrated with a worked example.", "labels": [], "entities": []}, {"text": "In section 4 it is argued that by defining cost functions in different ways, we can mimic various well-known algorithms for the generation of referring expressions.", "labels": [], "entities": []}, {"text": "We end with some concluding remarks in section 5.", "labels": [], "entities": []}, {"text": "DC E be the set of labels (with and disjoint, i.e.,.", "labels": [], "entities": []}, {"text": "Keep in mind that the labels are only added to ease reference to nodes.", "labels": [], "entities": []}, {"text": "Notice also that properties (such as being a dog) are always modelled as loops, i.e., edges which start and end in the same node, while relations may (but need not) have different start and end nodes.", "labels": [], "entities": []}, {"text": "Now the content determination problem for referring expressions can be formulated as a graph construction task.", "labels": [], "entities": [{"text": "content determination", "start_pos": 8, "end_pos": 29, "type": "TASK", "confidence": 0.6993463635444641}]}, {"text": "In order to decide which information to include in a referring expression for an object c p q S , we construct a connected directed labeled graph over the set of labels @ and an arbitrary set of nodes, but including . This graph can be understood as the \"meaning representation\" from which a referring expression can be generated by a linguistic realizer.", "labels": [], "entities": []}, {"text": "Informally, we say that a graph refers to a given entity iff the graph can be \"placed over\" the scene graph in such away that the node being referred to is \"placed over\" the given entity and each edge can be \"placed over\" an edge labeled with the same label.", "labels": [], "entities": []}, {"text": "Furthermore, a graph is distinguishing iff it refers to exactly one node in the scene graph.", "labels": [], "entities": []}, {"text": "Consider the three graphs in.", "labels": [], "entities": []}, {"text": "Here and elsewhere circled nodes stand for the intended referent.", "labels": [], "entities": []}, {"text": "Graph (i) refers to all nodes of the graph in (every object in the scene is next to some other object), graph (ii) can refer to both r ! and , and graph (iii) is distinguishing in that it can only refer tor ! .", "labels": [], "entities": []}, {"text": "Notice that the three graphs might be realized as something next to something else, a chihuahua and the dog in the doghouse respectively.", "labels": [], "entities": []}, {"text": "In this paper, we will concentrate on the generation of distinguishing graphs.", "labels": [], "entities": []}, {"text": "It is easily seen that there area number of such pairs, three of which are depicted in.", "labels": [], "entities": []}, {"text": "We would like to have a mechanism which allows us to give certain solutions preference over other solutions.", "labels": [], "entities": []}, {"text": "For this purpose we shall use cost-functions.", "labels": [], "entities": []}, {"text": "In general, a cost function is a function which assigns to each subgraph of a scene graph a positive number.", "labels": [], "entities": []}, {"text": "As we shall see, by defining cost functions in different ways, we can mimic various algorithms for the generation of referring expressions known from the literature.", "labels": [], "entities": []}, {"text": "A note on problem complexity The basic decision problem for subgraph isomorphism (i.e., testing whether a graphs is isomorphic to a subgraph of P ) is known to be NP complete (see e.g.,.", "labels": [], "entities": []}, {"text": "Here we are interested in connected s , but unfortunately that restriction does not reduce the theoretical complexity.", "labels": [], "entities": []}, {"text": "However, as soon as we define an upper bound \u0092 on the number of edges in a distinguishing graph, the problem loses its intractability and becomes solvable in polynomial Such a restriction is rather harmless for our current purposes, as it would only prohibit the generation of distinguishing descriptions with more than \u0092 properties, for an arbitrary large \u0092 . In general, there are various classes of graphs for which the subgraph isomorphism problem can be solved much more efficiently, without postulating upper bounds.", "labels": [], "entities": []}, {"text": "For instance, if P and s are planar graphs the problem can be solved in time linear in the number of nodes of P (Eppstein 1999).", "labels": [], "entities": []}, {"text": "Basically, a planar graph is one which can be drawn on a plane in such away that there are no crossing edges (thus, for instance, the graph in is planar).", "labels": [], "entities": []}, {"text": "It is worth investigating to what extent planar graphs suffice for the generation of referring expressions.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": []}