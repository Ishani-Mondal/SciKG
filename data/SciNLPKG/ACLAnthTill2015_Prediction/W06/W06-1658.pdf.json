{"title": [{"text": "Entity Annotation based on Inverse Index Operations", "labels": [], "entities": [{"text": "Inverse Index", "start_pos": 27, "end_pos": 40, "type": "DATASET", "confidence": 0.6222181767225266}]}], "abstractContent": [{"text": "Entity annotation involves attaching a label such as 'name' or 'organization' to a sequence of tokens in a document.", "labels": [], "entities": [{"text": "Entity annotation", "start_pos": 0, "end_pos": 17, "type": "TASK", "confidence": 0.8212335109710693}]}, {"text": "All the current rule-based and machine learning-based approaches for this task operate at the document level.", "labels": [], "entities": []}, {"text": "We present anew and generic approach to entity annotation which uses the inverse index typically created for rapid keyword based searching of a document collection.", "labels": [], "entities": [{"text": "entity annotation", "start_pos": 40, "end_pos": 57, "type": "TASK", "confidence": 0.7206649482250214}]}, {"text": "We define a set of operations on the inverse index that allows us to create annotations defined by cascading regular expressions.", "labels": [], "entities": []}, {"text": "The entity annotations for an entire document corpus can be created purely of the index with no need to access the original documents.", "labels": [], "entities": []}, {"text": "Experiments on two publicly available data sets show very significant performance improvements over the document-based annotators.", "labels": [], "entities": []}], "introductionContent": [{"text": "Entity Annotation associates a well-defined label such as 'person name', 'organization', 'place', etc., with a sequence of tokens in unstructured text.", "labels": [], "entities": []}, {"text": "The dominant paradigm for annotating a document collection is to annotate each document separately.", "labels": [], "entities": []}, {"text": "The computational complexity of annotating the collection in this paradigm, depends linearly on the number of documents and the cost of annotating each document.", "labels": [], "entities": []}, {"text": "More precisely, it depends on the total number of tokens in the document collection.", "labels": [], "entities": []}, {"text": "It is not uncommon to have millions of documents in a collection.", "labels": [], "entities": []}, {"text": "Using this paradigm, it can take hours or days to annotate such big collections even with highly parallel server farms.", "labels": [], "entities": []}, {"text": "Another drawback of this paradigm is that the entire document collection needs to be reprocessed whenever new annotations are required.", "labels": [], "entities": []}, {"text": "In this paper, we propose an alternative paradigm for entity annotation.", "labels": [], "entities": [{"text": "entity annotation", "start_pos": 54, "end_pos": 71, "type": "TASK", "confidence": 0.7839218974113464}]}, {"text": "We build an index for the tokens in the document collection first.", "labels": [], "entities": []}, {"text": "Using a set of operators on the index, we can generate new index entries for sequences of tokens that match any given regular expression.", "labels": [], "entities": []}, {"text": "Since a large class of annotators (e.g.,)) can be built using cascading regular expressions, this approach allows us to support annotation of the document collection purely from the index.", "labels": [], "entities": []}, {"text": "We show both theoretically and experimentally that this approach can lead to substantial reductions in computational complexity, since the order of computation is dependent on the size of the indexes and not the number of tokens in the document collection.", "labels": [], "entities": []}, {"text": "In most cases, the index sizes used for computing the annotations will be a small fraction of the total number of tokens.", "labels": [], "entities": []}, {"text": "In () the authors develop a method for speeding up the evaluation of a regular expression 'R' on a large text corpus by use of an optimally constructed multi-gram index to filter documents that will match 'R'.", "labels": [], "entities": [{"text": "evaluation of a regular expression 'R'", "start_pos": 55, "end_pos": 93, "type": "TASK", "confidence": 0.6552830897271633}]}, {"text": "Unfortunately, their method requires access to the document collection for the final match of 'R' to the filtered document set, which can be very time consuming.", "labels": [], "entities": []}, {"text": "The other bodies of related prior work concern indexing annotated data (;) and methods for document level annotation).", "labels": [], "entities": [{"text": "indexing annotated", "start_pos": 47, "end_pos": 65, "type": "TASK", "confidence": 0.877986878156662}]}, {"text": "The work on indexing annotated data is not directly relevant, since our method creates the index to the annotations directly as part of the algorithm for computing the annotation.) has a good survey of existing document level IE methods.", "labels": [], "entities": []}, {"text": "The relevance to our work is that only a certain class of annotators can be implemented using our method: namely anything that can be implemented using cascading weighted regular expressions.", "labels": [], "entities": []}, {"text": "Fortu-nately, this is still powerful enough to enable a large class of highly effective entity annotators.", "labels": [], "entities": []}, {"text": "The rest of the paper is organized as follows.", "labels": [], "entities": []}, {"text": "In Section 2, we present an overview of the proposed approach for entity annotation.", "labels": [], "entities": [{"text": "entity annotation", "start_pos": 66, "end_pos": 83, "type": "TASK", "confidence": 0.81096351146698}]}, {"text": "In Section 3, we construct an algorithm for implementing a deterministic finite automaton (DFA) using an inverse index of a document collection.", "labels": [], "entities": []}, {"text": "We also compare the complexity of this approach against the direct approach of running the DFA over the document collection, and show that under typical conditions, the index-based approach will bean order of magnitude faster.", "labels": [], "entities": []}, {"text": "In Section 4, we develop an alternative algorithm which is based on translating the original regular expression directly into an ordered AND/OR graph with an associated set of index level operators.", "labels": [], "entities": []}, {"text": "This has the advantage of operating directly on the much more compact regular expressions instead of the equivalent DFA (which can become very large as a result of the NFA to DFA conversion and epsilon removal steps).", "labels": [], "entities": []}, {"text": "We provide details of our experiments on two publicly available data sets in Section 5.", "labels": [], "entities": [{"text": "Section 5", "start_pos": 77, "end_pos": 86, "type": "DATASET", "confidence": 0.7986123561859131}]}, {"text": "Finally we present our conclusions in Section 6.", "labels": [], "entities": []}, {"text": "shows the process for entity annotation presented in the paper.", "labels": [], "entities": [{"text": "entity annotation", "start_pos": 22, "end_pos": 39, "type": "TASK", "confidence": 0.7621721923351288}]}, {"text": "A given document collection Dis tokenized and segmented into sentences.", "labels": [], "entities": []}, {"text": "The tokens are stored in an inverse index I.", "labels": [], "entities": []}, {"text": "The inverse index I has an ordered list U of the unique tokens u 1 , u 2 , ..u W that occur in the collection, where Wis the number of tokens in I.", "labels": [], "entities": []}, {"text": "Additionally, for each unique token", "labels": [], "entities": []}], "datasetContent": [{"text": "In this section, we present empirical comparison of performance of the index-based annotation technique (Section 4) against annotation based on the 'document paradigm' using GATE.", "labels": [], "entities": []}, {"text": "The experiments were performed on two data sets, viz., (i) the enron email data set 2 and (ii) a combination of Reuters-21578 data set 3 and the 20 Newsgroups data set 4 . After cleaning, the former data set was 2.3 GB while the latter was 93 MB in size.", "labels": [], "entities": [{"text": "enron email data set", "start_pos": 63, "end_pos": 83, "type": "DATASET", "confidence": 0.8383194655179977}, {"text": "Reuters-21578 data set", "start_pos": 112, "end_pos": 134, "type": "DATASET", "confidence": 0.975114663441976}, {"text": "20 Newsgroups data set", "start_pos": 145, "end_pos": 167, "type": "DATASET", "confidence": 0.7548161298036575}]}, {"text": "Our code is entirely in Java.", "labels": [], "entities": []}, {"text": "The experiments were performed on a dual 3.2GHz Xeon server with 4 GB RAM.", "labels": [], "entities": []}, {"text": "The code for creation of the index was custom-built in Java.", "labels": [], "entities": []}, {"text": "Prior to indexing, the sentence segmentation and tokenization of each data set was performed using in-house Java versions of standard tools 5 .", "labels": [], "entities": [{"text": "indexing", "start_pos": 9, "end_pos": 17, "type": "TASK", "confidence": 0.9694290161132812}, {"text": "sentence segmentation", "start_pos": 23, "end_pos": 44, "type": "TASK", "confidence": 0.7299318015575409}]}], "tableCaptions": [{"text": " Table 1: Time (in milliseconds) for computing an- notations using the two techniques", "labels": [], "entities": [{"text": "Time", "start_pos": 10, "end_pos": 14, "type": "METRIC", "confidence": 0.9916286468505859}]}, {"text": " Table 2: Time (in milliseconds) for computing  postings lists of entity types", "labels": [], "entities": [{"text": "Time", "start_pos": 10, "end_pos": 14, "type": "METRIC", "confidence": 0.9694761037826538}]}, {"text": " Table 3: Time (in milliseconds) for computing an- notations using the two techniques for the addi- tional 4 rules", "labels": [], "entities": [{"text": "Time", "start_pos": 10, "end_pos": 14, "type": "METRIC", "confidence": 0.9851157069206238}]}]}