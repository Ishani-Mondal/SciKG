{"title": [{"text": "Generating XTAG Parsers from Algebraic Specifications *", "labels": [], "entities": [{"text": "Generating XTAG Parsers", "start_pos": 0, "end_pos": 23, "type": "TASK", "confidence": 0.5465672612190247}]}], "abstractContent": [{"text": "In this paper, a generic system that generates parsers from parsing schemata is applied to the particular case of the XTAG English grammar.", "labels": [], "entities": [{"text": "XTAG English grammar", "start_pos": 118, "end_pos": 138, "type": "DATASET", "confidence": 0.8649253646532694}]}, {"text": "In order to be able to generate XTAG parsers, some transformations are made to the grammar, and TAG parsing schemata are extended with feature structure unification support and a simple tree filtering mechanism.", "labels": [], "entities": [{"text": "XTAG parsers", "start_pos": 32, "end_pos": 44, "type": "TASK", "confidence": 0.6686287522315979}, {"text": "TAG parsing", "start_pos": 96, "end_pos": 107, "type": "TASK", "confidence": 0.6646125316619873}, {"text": "feature structure unification", "start_pos": 135, "end_pos": 164, "type": "TASK", "confidence": 0.714144210020701}]}, {"text": "The generated implementations allow us to study the performance of different TAG parsers when working with a large-scale, wide-coverage grammar.", "labels": [], "entities": [{"text": "TAG parsers", "start_pos": 77, "end_pos": 88, "type": "TASK", "confidence": 0.9032697379589081}]}], "introductionContent": [{"text": "Since Tree Adjoining Grammars (TAG) were introduced, several different parsing algorithms for these grammars have been developed, each with its peculiar characteristics.", "labels": [], "entities": [{"text": "Tree Adjoining Grammars (TAG)", "start_pos": 6, "end_pos": 35, "type": "TASK", "confidence": 0.6833411753177643}]}, {"text": "Identifying the advantages and disadvantages of each of them is not trivial, and there are no comparative studies between them in the literature that work with reallife, wide coverage grammars.", "labels": [], "entities": []}, {"text": "In this paper, we use a generic tool based on parsing schemata to generate implementations of several TAG parsers and compare them by parsing with the XTAG English Grammar).", "labels": [], "entities": [{"text": "XTAG English Grammar", "start_pos": 151, "end_pos": 171, "type": "DATASET", "confidence": 0.9268168807029724}]}, {"text": "The parsing schemata formalism) is a framework that allows us to describe parsers in a simple and declarative way.", "labels": [], "entities": []}, {"text": "A parsing schema * Partially supported by Ministerio de Educaci\u00f3n y Ciencia and FEDER (TIN2004-07246-C03-01, TIN2004-07246-C03-02), Xunta de Galicia (PGIDIT05PXIC30501PN, PGIDIT05PXIC10501PN, PGIDIT05SIN044E and PGIDIT05SIN059E), and Programa de becas FPU (Ministerio de Educaci\u00f3n y Ciencia).", "labels": [], "entities": [{"text": "FEDER", "start_pos": 80, "end_pos": 85, "type": "METRIC", "confidence": 0.8079060912132263}]}, {"text": "We are grateful to Eric Villemonte de la Clergerie and Fran\u00e7ois Barthelemy for their help in converting the XTAG grammar to XML. is a representation of a parsing algorithm as a set of inference rules which are used to perform deductions on intermediate results called items.", "labels": [], "entities": []}, {"text": "These items represent sets of incomplete parse trees which the algorithm can generate.", "labels": [], "entities": []}, {"text": "An input sentence to be analyzed produces an initial set of items.", "labels": [], "entities": []}, {"text": "Additionally, a parsing schema must define a criterion to determine which items are final, i.e. which items correspond to complete parses of the input sentence.", "labels": [], "entities": []}, {"text": "If it is possible to obtain a final item from the set of initial items by using the schema's inference rules (called deductive steps), then the input sentence belongs to the language defined by the grammar.", "labels": [], "entities": []}, {"text": "The parse forest can then be retrieved from the intermediate items used to infer the final items, as in.", "labels": [], "entities": []}, {"text": "As an example, we introduce a CYK-based algorithm for TAG.", "labels": [], "entities": [{"text": "TAG", "start_pos": 54, "end_pos": 57, "type": "TASK", "confidence": 0.9323332905769348}]}, {"text": "Given a tree adjoining grammar G = (V T , V N , S, I, A) 1 and a sentence of length n which we denote by a 1 a 2 . .", "labels": [], "entities": []}, {"text": "an 2 , we denote by P (G) the set of productions {N \u03b3 \u2192 N \u03b3 1 N \u03b3 2 . .", "labels": [], "entities": []}, {"text": "N \u03b3 r } such that N \u03b3 is an inner node of a tree \u03b3 \u2208 (I \u222a A), and N \u03b3 1 N \u03b3 2 . .", "labels": [], "entities": []}, {"text": "a j of the string is being recognized, and positions p and q denote the substring dominated by \u03b3's foot node.", "labels": [], "entities": []}, {"text": "The final item set would be {[R \u03b1 , 0, n, \u2212, \u2212, adj] | \u03b1 \u2208 I} for the presence of such an item would indicate that there exists a valid parse tree with yield a 1 a 2 . .", "labels": [], "entities": []}, {"text": "an and rooted at R \u03b1 , the root of an initial tree; and therefore there exists a complete parse tree for the sentence.", "labels": [], "entities": []}, {"text": "A deductive step \u03b7 1 ...\u03b7m \u03be \u03a6 allows us to infer the item specified by its consequent \u03be from those in its antecedents \u03b7 1 . .", "labels": [], "entities": []}, {"text": "\u03b7 m . Side conditions (\u03a6) specify the valid values for the variables appearing in the antecedents and consequent, and may refer to grammar rules or specify other constraints that must be verified in order to infer the consequent.", "labels": [], "entities": []}, {"text": "The deductive steps for our CYK-based parser are shown in.", "labels": [], "entities": []}, {"text": "The steps D Scan CYK and D \ud97b\udf59 CYK are used to start the bottom-up parsing process by recognizing a terminal symbol for the input string, or none if we are using a tree with an epsilon node.", "labels": [], "entities": []}, {"text": "The D Binary CYK step (where the operation p \u222a p returns p if p is defined, and p otherwise) represents the bottom-up parsing operation which joins two subtrees into one, and is analogous to one of the deductive steps of the CYK parser for CFG.", "labels": [], "entities": [{"text": "CFG", "start_pos": 240, "end_pos": 243, "type": "DATASET", "confidence": 0.9323534965515137}]}, {"text": "The D Unary CYK step is used to handle unary branching productions.", "labels": [], "entities": []}, {"text": "D Foot CYK and D Adj CYK implement the adjunction operation, where a tree \u03b2 is adjoined into anode N \u03b3 ; their side condition \u03b2 \u2208 adj(N \u03b3 ) means that \u03b2 must be adjoinable into the node N \u03b3 (which involves checking that N \u03b3 is an adjunction node, comparing its label to R \u03b2 's and verifying that no adjunction constraint disallows the operation).", "labels": [], "entities": [{"text": "D Foot CYK", "start_pos": 0, "end_pos": 10, "type": "DATASET", "confidence": 0.9071947932243347}]}, {"text": "Finally, the D Subs CYK step implements the substitution operation in grammars supporting it.", "labels": [], "entities": []}, {"text": "As can be seen from the example, parsing schemata are simple, high-level descriptions that convey the fundamental semantics of parsing algorithms while abstracting implementation details: they define a set of possible intermediate results and allowed operations on them, but they don't specify data structures for storing the results or an order for the operations to be executed.", "labels": [], "entities": []}, {"text": "This high abstraction level makes schemata useful for defining, comparing and analyzing parsers in pencil and paper without worrying about implementation details.", "labels": [], "entities": []}, {"text": "However, if we want to actually execute the parsers and analyze their results and performance in a computer, they must be implemented in a programming language, making it necessary to lose the high level of abstraction in order to obtain functional and efficient implementations.", "labels": [], "entities": []}, {"text": "In order to bridge this gap between theory and practice, we have designed and implemented a system able to automatically transform parsing schemata into efficient Java implementations of their corresponding algorithms.", "labels": [], "entities": []}, {"text": "The input to this system is a simple and declarative representation of a parsing schema, which is practically equal to the formal notation that we used previously.", "labels": [], "entities": []}, {"text": "For example, this is the D Binary CYK deductive step shown in figure 1 in a format readable by our compiler: The parsing schemata compilation technique used by our system is based on the following fundamental ideas (): \u2022 Each deductive step is compiled to a Java class containing code to match and search for antecedent items and generate the corresponding conclusions from the consequent.", "labels": [], "entities": [{"text": "parsing schemata compilation", "start_pos": 113, "end_pos": 141, "type": "TASK", "confidence": 0.9103933572769165}]}, {"text": "\u2022 The step classes are coordinated by a deductive parsing engine, as the one described in (.", "labels": [], "entities": []}, {"text": "This algorithm ensures a sound and complete deduction process, guaranteeing that all items that can be generated from the initial items will be obtained.", "labels": [], "entities": []}, {"text": "\u2022 To attain efficiency, an automatic analysis of the schema is performed in order to create indexes allowing fast access to items.", "labels": [], "entities": []}, {"text": "As each different parsing schema needs to perform different searches for antecedent items, the index structures we generate are schema-specific.", "labels": [], "entities": []}, {"text": "In this way, we guarantee constant-time access to items so that the computational complexity of our generated implementations is never above the theoretical complexity of the parsers.", "labels": [], "entities": []}, {"text": "\u2022 Since parsing schemata have an open notation, for any mathematical object can potentially appear inside items, the system includes an extensibility mechanism which can be used to define new kinds of objects to use in schemata.", "labels": [], "entities": []}, {"text": "Figure 1: A CYK-based parser for TAG.", "labels": [], "entities": [{"text": "TAG", "start_pos": 33, "end_pos": 36, "type": "TASK", "confidence": 0.690241277217865}]}], "datasetContent": [], "tableCaptions": [{"text": " Table 1: Runtimes in ms of an Earley-based parser using two different unification strategies: unification  during and after parsing. The following data are shown: mean, trimmed means (10 and 20%), quartiles,  standard deviation, and p-value for the Wilcoxon paired signed rank test (the p-value of 0.4545 indicates  that no statistically significant difference was found between the medians).", "labels": [], "entities": []}]}