{"title": [{"text": "The ALLIGATOR Theorem Prover for Dependent Type Systems: Description and Proof Sample", "labels": [], "entities": []}], "abstractContent": [{"text": "This paper introduces the Alligator theorem prover for Dependent Type Systems (dts).", "labels": [], "entities": []}, {"text": "We start with highlighting a number of properties of dts that make them specifically suited for computational semantics.", "labels": [], "entities": []}, {"text": "We then briefly introduce dts and our implementation.", "labels": [], "entities": []}, {"text": "The paper concludes with an example of a dts proof that illustrates the suitability of dts for modelling anaphora resolution.", "labels": [], "entities": [{"text": "modelling anaphora resolution", "start_pos": 95, "end_pos": 124, "type": "TASK", "confidence": 0.7996534109115601}]}], "introductionContent": [{"text": "Automated symbolic inference requires a formal language as the substratum for reasoning.", "labels": [], "entities": [{"text": "Automated symbolic inference", "start_pos": 0, "end_pos": 28, "type": "TASK", "confidence": 0.6270828545093536}]}, {"text": "Blackburn and Bos () make a good case for the use of First Order Predicate Logic (fopl) in computational semantics, citing both practical (availability of high performance theorem provers and to a lesser extent model builders) and theoretical reasons (they discuss a range of interesting phenomena which can be dealt within fopl).", "labels": [], "entities": [{"text": "First Order Predicate Logic (fopl)", "start_pos": 53, "end_pos": 87, "type": "TASK", "confidence": 0.6274504278387342}]}, {"text": "We agree with the idea that fopl is a good starting point, but also think that for computational semantics to develop further as afield, extensions going beyond fopl should be actively explored.", "labels": [], "entities": []}, {"text": "In this paper, a research tool is described that takes such explorations in one particular direction.", "labels": [], "entities": []}, {"text": "The tool -alligator -is a theorem prover for Dependent Type Systems (dts).", "labels": [], "entities": []}, {"text": "The Sicstus Prolog source code of this prover is available, free of charge, for research purposes ().", "labels": [], "entities": [{"text": "Sicstus Prolog source code", "start_pos": 4, "end_pos": 30, "type": "DATASET", "confidence": 0.942883238196373}]}, {"text": "dts are an attractive option for computational semantics fora number of reasons: (i) Dynamic potential (cf.) The notion of a context that is built up incrementally is inherent to dts.", "labels": [], "entities": []}, {"text": "(ii) Flexibility: By varying a limited number of parameters, it is possible to switch from, for example, propositional to predicate logic, or first order to higher order logics.", "labels": [], "entities": []}, {"text": "Additionally, although the basic underlying logic is constructive, dts allows for the flexible use of axioms to regain full classical logic, or more fine-grained alternatives.", "labels": [], "entities": []}, {"text": "For example, it is possible to specify for individual predicates whether they are bivalent.", "labels": [], "entities": []}, {"text": "(iii) Extensibility: A dts-context includes what is known as the signature in fopl.", "labels": [], "entities": []}, {"text": "Consequently, the signature can be extended incrementally, making it possible to model the acquisition of new concepts by language users.", "labels": [], "entities": []}, {"text": "(iv) Proof-objects: In dts, Gentzen-style natural deduction proofs are first-class citizens.", "labels": [], "entities": []}, {"text": "This gives us the following advantages: (a) Reliability: It allows us to heed the de Bruijn criterion for reliable proof systems: \"A proof assistant satisfies the de Bruijn criterion if it generates 'proof-objects' (of some form) that can be checked by an easy algorithm.\"", "labels": [], "entities": [{"text": "Reliability", "start_pos": 44, "end_pos": 55, "type": "METRIC", "confidence": 0.975037693977356}]}, {"text": "(cited from) (b) Naturalness: dts proofs correspond with natural deduction proofs.", "labels": [], "entities": []}, {"text": "This is of interest if one is concerned with models of human reasoning in natural language understanding.", "labels": [], "entities": [{"text": "natural language understanding", "start_pos": 74, "end_pos": 104, "type": "TASK", "confidence": 0.669804036617279}]}, {"text": "In psychology, some schools of thought argue that natural deduction is a good approximation of human reasoning (see, e.g.,).", "labels": [], "entities": []}, {"text": "(c) Relevance: Proof objects can help to identify proofs which are valid but spurious in the sense that they do not really consume their premises (see).", "labels": [], "entities": []}, {"text": "(d) Justification of behaviour: Explicit proof objects provide direct access to the justifications that an agent has for the conclusions and the interpretations that it constructs.", "labels": [], "entities": [{"text": "Justification of behaviour", "start_pos": 4, "end_pos": 30, "type": "TASK", "confidence": 0.8888293902079264}]}, {"text": "This is particularly useful for dialogue agents that need to respond to utterances of other agents.", "labels": [], "entities": []}, {"text": "Such responses can themselves again be queried, for example, through clarificatory questions (cf.) and why questions (A:p, B: no, \u00acp, A: Why \u00acp?).", "labels": [], "entities": []}, {"text": "In order to respond appropriately, the agent needs to access its own background knowledge and how it was used to draw conclusions.", "labels": [], "entities": []}, {"text": "dts proof objects provide a compact representation of this information.", "labels": [], "entities": []}, {"text": "(v) Applications: dts-style analyses exist fora wide range of linguistic phenomena including donkey sentences (), anaphoric expressions and temporal reference (), belief revision (), bridging anaphora (), clarification ellipsis (), metonymy (), inter-agent communication, knowledge and observation (), ontological reasoning for feedback dialogues (), and human-machine dialogue ().", "labels": [], "entities": [{"text": "belief revision", "start_pos": 163, "end_pos": 178, "type": "TASK", "confidence": 0.7179074734449387}]}, {"text": "Additionally, there is research on relating dts proof-theoretic natural language semantics to model-theoretic approaches (), and there are studies employing the related formalism of labelled deduction to natural language semantics ().", "labels": [], "entities": []}, {"text": "In 2005, the 2 nd Workshop on Lambda-Calculus, Type Theory, and Natural Language took place at King's College London ().", "labels": [], "entities": [{"text": "Type Theory", "start_pos": 47, "end_pos": 58, "type": "TASK", "confidence": 0.8776825666427612}, {"text": "King's College London", "start_pos": 95, "end_pos": 116, "type": "DATASET", "confidence": 0.8705922961235046}]}, {"text": "We concede that none of the properties we have listed is on its own unique to dts.", "labels": [], "entities": []}, {"text": "However, to the best of our knowledge, no extant logical calculus combines all these properties in a single system with well-understood meta-mathematical properties (dts play a central role in theoretical computer science, see).", "labels": [], "entities": []}, {"text": "That is, given a set of assumptions \u0393, also known as the context, they provide rules for determining whether a particular object, say a, belongs to a given type, say t.", "labels": [], "entities": []}, {"text": "We write \u0393 \u22a2 a : t, if, given the context \u0393, a is of type t, i.e., a inhabits type t.", "labels": [], "entities": []}, {"text": "The objects that are classified using type systems are (normalizing) terms of the \u03bb-calculus.", "labels": [], "entities": []}, {"text": "\u0393 is a sequence of statements x 1 : t 1 , . .", "labels": [], "entities": []}, {"text": ", x n : tn (with n \u2265 0).", "labels": [], "entities": []}, {"text": "Dependency is the second feature of dts, and it comes in two forms.", "labels": [], "entities": []}, {"text": "First, there is dependency between statements in the context: in order to use a type t k to classify an object x k , this type t k needs to have been introduced in that part of the context that precedes it or t k has to be a sort.", "labels": [], "entities": []}, {"text": "In other words, t k can only be used if (1) it itself inhabits a type or can be constructed from other types that are available in the context preceding it, or (2) it belongs to a fixed and usually small set of designated types that are called sorts.", "labels": [], "entities": []}, {"text": "Because sorts need no preceding context, they make it possible to keep contexts finite.", "labels": [], "entities": []}, {"text": "Second, there is a variety of dependency that occurs inside types.", "labels": [], "entities": []}, {"text": "Since type systems are used to classify terms of the \u03bb-calculus, they can also deal with functions.", "labels": [], "entities": []}, {"text": "A function f from objects of type t 1 to objects of type t 2 inhabits the function type t 1 \u2192 t 2 . Dependent function types area generalization of function types: a dependent function type is a function type where the range of the function changes depending on the object to which the function is applied.", "labels": [], "entities": []}, {"text": "The notation for dependent function types is \u03a0x : A.B (we also use our own alternative 'arrow notation': [x : A] \u21d2 B).", "labels": [], "entities": []}, {"text": "If we apply an inhabitant of this function type, say f , to an object of type A, then the resulting object fa (f applied to a) is of type B, but with all free occurrences of x in B substituted with a (that is, the type off a is B[x := a]).", "labels": [], "entities": []}, {"text": "One way to make the leap from type systems to logic is as follows.", "labels": [], "entities": []}, {"text": "From a logical point of view, we are interested in propositions as the constituents of deductive arguments.", "labels": [], "entities": []}, {"text": "In classical logic, one focuses on judgements of the following form: the truth of proposition q follows/can be derived from the truth of the propositions p 1 , . .", "labels": [], "entities": []}, {"text": ", p n . We reason from the truth of the premises to the truth of the conclusion.", "labels": [], "entities": []}, {"text": "To do logic in a dts, we move from truth to proof: we, now, reason from the proofs that we (assume to) have for the premises to a proof for the conclusion.", "labels": [], "entities": []}, {"text": "In other words, we are interested in judgements of the following form: a is proof of proposition q follows/can be derived assuming that a 1 is a proof of p 1 , a 2 is a proof of p 2 , . .", "labels": [], "entities": []}, {"text": "., and an is a proof p n . Such a judgement can be formalized in a dts as a 1 : p 1 , . .", "labels": [], "entities": []}, {"text": ", an : p n \u22a2 a : p.", "labels": [], "entities": []}, {"text": "Thus, we read a : p as 'a is a proof for p'.", "labels": [], "entities": []}, {"text": "Thus, we model proofs as (\u03bb-calculus) terms and propositions as (a certain class of) types in dts.", "labels": [], "entities": []}, {"text": "This is known as the Curry-Howard-de Bruijn embedding.", "labels": [], "entities": []}, {"text": "The embedding is grounded in the Brouwer-Heyting-Kolmogorov interpretation of proofs as constructions; e.g., a proof fora conditional p \u2192 q is identified with a method that transforms a proof of pinto a proof for q.", "labels": [], "entities": []}, {"text": "Ina dts, this is formalized by modelling the proof f fora type p \u2192 q as a function from objects of type p to objects of type q, such that if a is a proof of p, then f applied to a is a proof of q (i.e., fa : q).", "labels": [], "entities": []}, {"text": "Universal quantification is dealt with along the same lines.", "labels": [], "entities": []}, {"text": "Ina dts, the counterpart for universal quantification is the dependent function type.", "labels": [], "entities": []}, {"text": "In particular, \u2200x \u2208 A : P (x) becomes (\u03a0x : A.P x).", "labels": [], "entities": []}, {"text": "A proof for this type is a function f which, given any object a : A, returns the proof fa for Pa.", "labels": [], "entities": []}, {"text": "Pure Type Systems (pts;) are of particular interest, because of their generality.", "labels": [], "entities": []}, {"text": "With a small number of parameters, pts can be tailored to match a wide variety of dts.", "labels": [], "entities": []}, {"text": "Alligator implements an extension of pts with \u03a3 types.", "labels": [], "entities": []}, {"text": "\u03a3 types are also known as dependent product types and can be used to model \u2227 and \u2203.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": []}