{"title": [{"text": "Semantic Role Labeling via Tree Kernel Joint Inference", "labels": [], "entities": [{"text": "Semantic Role Labeling", "start_pos": 0, "end_pos": 22, "type": "TASK", "confidence": 0.764530599117279}]}], "abstractContent": [{"text": "Recent work on Semantic Role Labeling (SRL) has shown that to achieve high accuracy a joint inference on the whole predicate argument structure should be applied.", "labels": [], "entities": [{"text": "Semantic Role Labeling (SRL)", "start_pos": 15, "end_pos": 43, "type": "TASK", "confidence": 0.8419317503770193}, {"text": "accuracy", "start_pos": 75, "end_pos": 83, "type": "METRIC", "confidence": 0.9922420978546143}]}, {"text": "In this paper, we used syntactic sub-trees that span potential argument structures of the target predicate in tree kernel functions.", "labels": [], "entities": []}, {"text": "This allows Support Vector Machines to discern between correct and incorrect predicate structures and to re-rank them based on the joint probability of their arguments.", "labels": [], "entities": []}, {"text": "Experiments on the PropBank data show that both classification and re-ranking based on tree kernels can improve SRL systems.", "labels": [], "entities": [{"text": "PropBank data", "start_pos": 19, "end_pos": 32, "type": "DATASET", "confidence": 0.9735968708992004}, {"text": "SRL", "start_pos": 112, "end_pos": 115, "type": "TASK", "confidence": 0.9935027956962585}]}], "introductionContent": [{"text": "Recent work on Semantic Role Labeling (SRL)) has shown that to achieve high labeling accuracy a joint inference on the whole predicate argument structure should be applied.", "labels": [], "entities": [{"text": "Semantic Role Labeling (SRL))", "start_pos": 15, "end_pos": 44, "type": "TASK", "confidence": 0.8067255963881811}, {"text": "accuracy", "start_pos": 85, "end_pos": 93, "type": "METRIC", "confidence": 0.9509481191635132}]}, {"text": "For this purpose, we need to extract features from the sentence's syntactic parse tree that encodes the target semantic structure.", "labels": [], "entities": []}, {"text": "This task is rather complex since we do not exactly know which are the syntactic clues that capture the relation between the predicate and its arguments.", "labels": [], "entities": []}, {"text": "For example, to detect the interesting context, the modeling of syntax/semantics-based features should take into account linguistic aspects like ancestor nodes or semantic dependencies ().", "labels": [], "entities": []}, {"text": "A viable approach to generate a large number of features has been proposed in), where convolution kernels were used to implicitly define a tree substructure space.", "labels": [], "entities": []}, {"text": "The selection of the relevant structural features was left to the Voted Perceptron learning algorithm.", "labels": [], "entities": [{"text": "Voted Perceptron learning", "start_pos": 66, "end_pos": 91, "type": "DATASET", "confidence": 0.8132506807645162}]}, {"text": "Such successful experimentation shows that tree kernels are very promising for automatic feature engineering, especially when the available knowledge about the phenomenon is limited.", "labels": [], "entities": [{"text": "automatic feature engineering", "start_pos": 79, "end_pos": 108, "type": "TASK", "confidence": 0.6267951329549154}]}, {"text": "Ina similar way, we can model SRL systems with tree kernels to generate large feature spaces.", "labels": [], "entities": [{"text": "SRL", "start_pos": 30, "end_pos": 33, "type": "TASK", "confidence": 0.9842851758003235}]}, {"text": "More in detail, most SRL systems split the labeling process into two different steps: Boundary Detection (i.e. to determine the text boundaries of predicate arguments) and Role Classification (i.e. labeling such arguments with a semantic role, e.g. Arg0 or Arg1 as defined in).", "labels": [], "entities": [{"text": "SRL", "start_pos": 21, "end_pos": 24, "type": "TASK", "confidence": 0.9741665720939636}, {"text": "Role Classification", "start_pos": 172, "end_pos": 191, "type": "TASK", "confidence": 0.7532540559768677}, {"text": "Arg1", "start_pos": 257, "end_pos": 261, "type": "METRIC", "confidence": 0.710637629032135}]}, {"text": "The former relates to the detection of syntactic parse tree nodes associated with constituents that correspond to arguments, whereas the latter considers the boundary nodes for the assignment of the suitable label.", "labels": [], "entities": []}, {"text": "Both steps require the design and extraction of features from parse trees.", "labels": [], "entities": []}, {"text": "As capturing the tightly interdependent relations among a predicate and its arguments is a complex task, we can apply tree kernels on the subtrees that span the whole predicate argument structure to generate the feature space of all the possible subtrees.", "labels": [], "entities": []}, {"text": "In this paper, we apply the traditional boundary (T BC) and role (T RC) classifiers (), which are based on binary predicate/argument relations, to label all parse tree nodes corresponding to potential arguments.", "labels": [], "entities": []}, {"text": "Then, we ex-tract the subtrees which span the predicate-argument dependencies of such arguments, i.e. Argument Spanning Trees (AST s).", "labels": [], "entities": []}, {"text": "These are used in a tree kernel function to generate all possible substructures that encode n-ary argument relations, i.e. we carryout an automatic feature engineering process.", "labels": [], "entities": []}, {"text": "To validate our approach, we experimented with our model and Support Vector Machines for the classification of valid and invalid AST s.", "labels": [], "entities": [{"text": "classification of valid and invalid AST", "start_pos": 93, "end_pos": 132, "type": "TASK", "confidence": 0.6072774032751719}]}, {"text": "The results show that this classification problem can be learned with high accuracy.", "labels": [], "entities": [{"text": "classification", "start_pos": 27, "end_pos": 41, "type": "TASK", "confidence": 0.9719335436820984}, {"text": "accuracy", "start_pos": 75, "end_pos": 83, "type": "METRIC", "confidence": 0.9958091974258423}]}, {"text": "Moreover, we modeled SRL as a re-ranking task inline with ().", "labels": [], "entities": [{"text": "SRL", "start_pos": 21, "end_pos": 24, "type": "TASK", "confidence": 0.9417291879653931}]}, {"text": "The large number of complex features provided by tree kernels for structured learning allows SVMs to reach the state-of-the-art accuracy.", "labels": [], "entities": [{"text": "accuracy", "start_pos": 128, "end_pos": 136, "type": "METRIC", "confidence": 0.9985413551330566}]}, {"text": "The paper is organized as follows: Section 2 introduces the Semantic Role Labeling based on SVMs and the tree kernel spaces; Section 3 formally defines the AST sand the algorithm for their classification and re-ranking; Section 4 shows the comparative results between our approach and the traditional one; Section 5 presents the related work; and finally, Section 6 summarizes the conclusions.", "labels": [], "entities": [{"text": "Semantic Role Labeling", "start_pos": 60, "end_pos": 82, "type": "TASK", "confidence": 0.7828283707300822}]}], "datasetContent": [{"text": "The experiments were carried out within the setting defined in the).", "labels": [], "entities": []}, {"text": "In particular, we adopted the Charniak parse trees available at www.lsi.upc.edu/\u223csrlconll/ along with the official performance evaluator.", "labels": [], "entities": [{"text": "Charniak parse trees", "start_pos": 30, "end_pos": 50, "type": "DATASET", "confidence": 0.6528719067573547}]}, {"text": "All the experiments were performed with the SVM-light-TK software available at http://ai-nlp.info.uniroma2.it/moschitti/ which encodes ST and SST kernels in SVM-light).", "labels": [], "entities": []}, {"text": "For T BC and T RC, we used the linear kernel with a regularization parameter (option -c) equal to 1.", "labels": [], "entities": []}, {"text": "A cost factor (option -j) of 10 was adopted for T BC to have a higher Recall, whereas for T RC, the cost factor was parameterized according to the maximal accuracy of each argument class on the validation set.", "labels": [], "entities": [{"text": "Recall", "start_pos": 70, "end_pos": 76, "type": "METRIC", "confidence": 0.9991958737373352}, {"text": "accuracy", "start_pos": 155, "end_pos": 163, "type": "METRIC", "confidence": 0.9853537082672119}]}, {"text": "For the AST -based classifiers we used a \u03bb equal to 0.4 (see).: AST , AST -Ord, and AST -Arg performance on sections 21 and 23.", "labels": [], "entities": [{"text": "AST", "start_pos": 64, "end_pos": 67, "type": "DATASET", "confidence": 0.48915648460388184}, {"text": "AST -Ord", "start_pos": 70, "end_pos": 78, "type": "METRIC", "confidence": 0.45111314455668133}, {"text": "AST -Arg", "start_pos": 84, "end_pos": 92, "type": "METRIC", "confidence": 0.4250496526559194}]}], "tableCaptions": [{"text": " Table 1: AST , AST -Ord, and AST -Arg perfor- mance on sections 21 and 23.", "labels": [], "entities": [{"text": "AST", "start_pos": 10, "end_pos": 13, "type": "TASK", "confidence": 0.5562223196029663}, {"text": "AST -Ord", "start_pos": 16, "end_pos": 24, "type": "METRIC", "confidence": 0.5497401257356008}, {"text": "AST -Arg", "start_pos": 30, "end_pos": 38, "type": "METRIC", "confidence": 0.5708239475886027}]}, {"text": " Table 2: Semantic Role Labeling performance on automatic trees using AST -based classifiers.", "labels": [], "entities": [{"text": "Semantic Role Labeling", "start_pos": 10, "end_pos": 32, "type": "TASK", "confidence": 0.7994455695152283}]}]}