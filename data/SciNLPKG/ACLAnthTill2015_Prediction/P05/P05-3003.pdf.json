{"title": [{"text": "Efficient solving and exploration of scope ambiguities", "labels": [], "entities": [{"text": "Efficient solving", "start_pos": 0, "end_pos": 17, "type": "TASK", "confidence": 0.5220586061477661}]}], "abstractContent": [{"text": "We present the currently most efficient solver for scope underspecification; it also converts between different underspecifica-tion formalisms and counts readings.", "labels": [], "entities": [{"text": "solver", "start_pos": 40, "end_pos": 46, "type": "TASK", "confidence": 0.961844801902771}]}, {"text": "Our tool makes the practical use of large-scale grammars with (underspecified) semantic output more feasible, and can be used in grammar debugging.", "labels": [], "entities": [{"text": "grammar debugging", "start_pos": 129, "end_pos": 146, "type": "TASK", "confidence": 0.6999436765909195}]}], "introductionContent": [{"text": "One of the most exciting recent developments in computational linguistics is that large-scale grammars which compute semantic representations are becoming available.", "labels": [], "entities": [{"text": "computational linguistics", "start_pos": 48, "end_pos": 73, "type": "TASK", "confidence": 0.7498696148395538}]}, {"text": "Examples for such grammars are the HPSG English Resource Grammar (ERG)) and the LFG ParGram grammars); a similar resource is being developed for the XTAG grammar (.", "labels": [], "entities": [{"text": "HPSG English Resource Grammar (ERG))", "start_pos": 35, "end_pos": 71, "type": "DATASET", "confidence": 0.9417293752942767}, {"text": "LFG ParGram grammars", "start_pos": 80, "end_pos": 100, "type": "DATASET", "confidence": 0.8447019656499227}]}, {"text": "But with the advent of such grammars, a phenomenon that is sometimes considered a somewhat artificial toy problem of theoretical semanticists becomes a very practical challenge: the presence of scope ambiguities.", "labels": [], "entities": []}, {"text": "Because grammars often uniformly treat noun phrases as quantifiers, even harmless-looking sentences can have surprisingly many readings.", "labels": [], "entities": []}, {"text": "The median number of scope readings for the sentences in the Rondane Treebank (distributed with the ERG) is 55, but the treebank also contains extreme cases such as (1) below, which according to the ERG has about 2.4 trillion (10 12 ) readings: (1) Myrdal is the mountain terminus of the Fl\u00e5m rail line (or Fl\u00e5msbana) which makes its way down the lovely Fl\u00e5m Valley (Fl\u00e5msdalen) to its sea-level terminus at Fl\u00e5m.", "labels": [], "entities": [{"text": "Rondane Treebank", "start_pos": 61, "end_pos": 77, "type": "DATASET", "confidence": 0.8984284996986389}, {"text": "Fl\u00e5m Valley (Fl\u00e5msdalen)", "start_pos": 354, "end_pos": 378, "type": "DATASET", "confidence": 0.8885828852653503}, {"text": "Fl\u00e5m", "start_pos": 408, "end_pos": 412, "type": "DATASET", "confidence": 0.9175088405609131}]}, {"text": "(Rondane 650) In order to control such an explosion of readings (and also to simplify the grammar design process), the developers of large-scale grammars typically use methods of packing or underspecification to specify the syntax-semantics interface.", "labels": [], "entities": []}, {"text": "The general idea is that the parser doesn't compute all the individual scope readings, but only a compact underspecified description, from which the individual readings can then be extracted at a later stage of processing -but the underspecified description could also be used as a platform for the integration of lexical and context information, so as to restrict the set of possible readings without enumerating the wrong ones.", "labels": [], "entities": []}, {"text": "Such an approach is only feasible if we have access to efficient tools that support the most important operations on underspecified descriptions.", "labels": [], "entities": []}, {"text": "We present utool, the Swiss Army Knife of Underspecification, which sets out to do exactly this.", "labels": [], "entities": [{"text": "Swiss Army Knife", "start_pos": 22, "end_pos": 38, "type": "DATASET", "confidence": 0.9450005292892456}]}, {"text": "It supports the following operations: 1.", "labels": [], "entities": []}, {"text": "enumerate all scope readings represented by an underspecified description; 2.", "labels": [], "entities": []}, {"text": "check whether a description has any readings, and compute how many readings it has without explicitly enumerating them; 3.", "labels": [], "entities": []}, {"text": "convert underspecified descriptions between different underspecification formalisms (at this point, Minimal Recursion Semantics (Copestake et al., 2003), Hole Semantics, and dominance constraints/graphs ().", "labels": [], "entities": []}, {"text": "Our system is the fastest solver for underspecificied description available today; that is, it is fastest at solving Task 1 above (about 100.000 readings per second on a modern PC).", "labels": [], "entities": [{"text": "solver for underspecificied description", "start_pos": 26, "end_pos": 65, "type": "TASK", "confidence": 0.603534072637558}]}, {"text": "It achieves this by implementing an efficient algorithm for solving dominance graphs () and caching intermediate results in a chart data structure.", "labels": [], "entities": []}, {"text": "To our knowledge, it is the only system that can do Tasks 2 and 3.", "labels": [], "entities": []}, {"text": "It is only because utool can compute the number of readings without enumerating them that we even know that (1) has trillions of readings; even utool would take about a year to enumerate and count the readings individually.", "labels": [], "entities": []}, {"text": "utool is implemented in C++, efficient and portable, open source, and freely downloadable from http://utool.sourceforge.net.", "labels": [], "entities": [{"text": "utool", "start_pos": 0, "end_pos": 5, "type": "DATASET", "confidence": 0.937822163105011}]}], "datasetContent": [], "tableCaptions": []}