{"title": [], "abstractContent": [{"text": "The logic behind parsers for categorial grammars can be formalized in several different ways.", "labels": [], "entities": []}, {"text": "Lam-bek Calculus (LC) constitutes an example fora natural deduction 1 style parsing method.", "labels": [], "entities": [{"text": "Lam-bek Calculus (LC)", "start_pos": 0, "end_pos": 21, "type": "DATASET", "confidence": 0.8732699871063232}, {"text": "natural deduction 1 style parsing", "start_pos": 50, "end_pos": 83, "type": "TASK", "confidence": 0.6167128205299377}]}, {"text": "In natural language processing, the task of a parser usually consists in finding derivations for all different readings of a sentence.", "labels": [], "entities": [{"text": "natural language processing", "start_pos": 3, "end_pos": 30, "type": "TASK", "confidence": 0.6811156868934631}]}, {"text": "The original Lam-bek Calculus, when it is used as a parser/theorem prover, has the undesirable property of allowing for the derivation of more than one proof fora reading of a sentence, in the general case.", "labels": [], "entities": []}, {"text": "In order to overcome this inconvenience and to turn Lambek Calculus into a reasonable parsing method, we show the existence of \"relative\" normal form proof trees and make use of their properties to constrain the proof procedure in the desired way.", "labels": [], "entities": [{"text": "Lambek Calculus", "start_pos": 52, "end_pos": 67, "type": "DATASET", "confidence": 0.9312196969985962}]}], "introductionContent": [{"text": "Sophisticated techniques have been developed for the implementation of parsers for (augmented) context-free grammars.", "labels": [], "entities": []}, {"text": "[Pereira/ gave a characterization of these parsers as being resolution based theorem provers.", "labels": [], "entities": []}, {"text": "Resolution might betaken as an instance of Hilbert-style theorem proving, where there is one inference rule (e.g. Modus Ponens or some other kind of Cul Rule) which allows for deriving theorems from a set of axioms.", "labels": [], "entities": [{"text": "Resolution", "start_pos": 0, "end_pos": 10, "type": "TASK", "confidence": 0.9656389355659485}, {"text": "Hilbert-style theorem proving", "start_pos": 43, "end_pos": 72, "type": "TASK", "confidence": 0.6697045465310415}]}, {"text": "In the case of parsing, the grammar rules and the lexicon would be the axioms.", "labels": [], "entities": []}, {"text": "When categorial grammars were discovered for computational linguistics, the most obvious way to design parsers for categorial grammars seemed 1 \"natural deduction\" is used herein its broad sense, i.e. natural deduction as opposed to Hilbert-style deduction to apply the existing methods: The few combination rules and the lexicon constitute the set of axioms, from which theorems are derived by a resolution rule.", "labels": [], "entities": []}, {"text": "However, this strategy leads to unsatisfactory results, in so far as extended categorial grammars, which make use of combination rules like functional composition and type raising, provide fora proliferation of derivations for the same reading of a sentence.", "labels": [], "entities": [{"text": "type raising", "start_pos": 167, "end_pos": 179, "type": "TASK", "confidence": 0.7350409179925919}]}, {"text": "This phenomenon has been dubbed the spurious ambiguity problem.", "labels": [], "entities": []}, {"text": "One solution to this problem is to describe normal forms for equivalent derivations and to use this knowledge to prune the search space of the parsing process.", "labels": [], "entities": [{"text": "parsing process", "start_pos": 143, "end_pos": 158, "type": "TASK", "confidence": 0.9012253880500793}]}, {"text": "Other approaches to cope with the problem of spurious ambiguity take into account the pecularities of categorial grammars compared to grammars With \"context-free skeleton\".", "labels": [], "entities": []}, {"text": "One characteristic of categorial grammars is the shift of information from the grammar rules into the lexicon: grammar rules are mere combination schemata whereas syntactic categories do not have to be atomic items as in the \"context-free\" formalisms, but can also be structured objects as well.", "labels": [], "entities": []}, {"text": "The inference rule of a Hilbert-style deduction system does not refer to the internal structure of the propositions which it deals with.", "labels": [], "entities": []}, {"text": "The alternative to Hilbert-style deduction is natural deduction (in the broad sense of the word) which is \"natural\" in so far as at least some of the inference rules of a natural deduction system describe explicitly how logical operators have to be treated.", "labels": [], "entities": []}, {"text": "Therefore natural deduction style proof systems are in principle good candidates to function as a framework for categorial grammar parsers.", "labels": [], "entities": []}, {"text": "If one considers categories as formulae, then a proof system would have to refer to the operators which are used in those formulae.", "labels": [], "entities": []}, {"text": "The natural deduction approach to parsing with categorial grammars splits up into two general mainstreams both of which use the Gentzen sequent representation to state the corresponding calculi.", "labels": [], "entities": []}, {"text": "The first alternative is to take a general purpose calculus and propose an adequate translation of categories into formulae of this logic.", "labels": [], "entities": []}, {"text": "An example for this approach has been carried out by,].", "labels": [], "entities": []}, {"text": "On the other hand, one might use a specialized calculus.", "labels": [], "entities": []}, {"text": "Lambek proposed such a calculus for categorial grammar more than three decades ago].", "labels": [], "entities": []}, {"text": "The aim of this paper is to describe how Lambek Calculus can be implemented in such away that it serves as an efficient parsing mechanism.", "labels": [], "entities": [{"text": "Lambek Calculus", "start_pos": 41, "end_pos": 56, "type": "DATASET", "confidence": 0.9020270109176636}]}, {"text": "To achieve this goal, the main drawback of the original Lambek Calculus, which consists of aversion of the \"spurious ambiguity problem\", has to be overcome.", "labels": [], "entities": [{"text": "Lambek Calculus", "start_pos": 56, "end_pos": 71, "type": "DATASET", "confidence": 0.9456674456596375}]}, {"text": "In Lambek Calculus, this overgeneration of derivations is due to the fact that the calculus itself does not giye enough constraints on the order in which the inference rules have to be applied.", "labels": [], "entities": [{"text": "Lambek Calculus", "start_pos": 3, "end_pos": 18, "type": "DATASET", "confidence": 0.9002193510532379}]}, {"text": "In section 2 of the paper, we present Lambek Calculus in more detail.", "labels": [], "entities": [{"text": "Lambek Calculus", "start_pos": 38, "end_pos": 53, "type": "DATASET", "confidence": 0.8356082141399384}]}, {"text": "Section 3 consists of the proof for the existence of normal form proof trees relative to the readings of a sentence.", "labels": [], "entities": []}, {"text": "Based on this result, the parsing mechanism is described in section 4.", "labels": [], "entities": [{"text": "parsing", "start_pos": 26, "end_pos": 33, "type": "TASK", "confidence": 0.9866287708282471}]}, {"text": "head of a complex category is the head of its value category.", "labels": [], "entities": []}, {"text": "The category in the succedens of a sequent is called goal category.", "labels": [], "entities": []}, {"text": "v, T -T --(=\\v) T non-empty sequence of categories; U, V sequences; x, y, z categories.", "labels": [], "entities": []}, {"text": "In the following, we restrain ourselves to cutfree and product-free Lambek Calculus, a calculus which still allows us to infer infinitely many derived rules such as Geach-rule, functional composition etc.", "labels": [], "entities": []}, {"text": "The cut-free and productfree Lambek Calculus is given in figures 1 and 2.", "labels": [], "entities": [{"text": "Lambek Calculus", "start_pos": 29, "end_pos": 44, "type": "DATASET", "confidence": 0.946999192237854}]}, {"text": "Be aware of the fact that we did not adopt Lambek's representation of complex categories.", "labels": [], "entities": []}, {"text": "Proofs in Lambek Calculus can be represented as trees whose nodes are annotated with sequents.", "labels": [], "entities": [{"text": "Lambek Calculus", "start_pos": 10, "end_pos": 25, "type": "DATASET", "confidence": 0.9566728472709656}]}, {"text": "An example is given in.", "labels": [], "entities": []}, {"text": "A lexical lookup step which replaces lexemes by their corresponding categories has to precede the actual theorem proving process.", "labels": [], "entities": [{"text": "theorem proving", "start_pos": 105, "end_pos": 120, "type": "TASK", "confidence": 0.7059007585048676}]}, {"text": "For this reason, the categories in the antecedens of the input sequent will also be called lezical categories.", "labels": [], "entities": []}, {"text": "We introduce the notions of head, goal category, and current fanctor: The head of a category is its \"innermost\" value category: The head of a basic category is the category itself.", "labels": [], "entities": []}, {"text": "The np ~ np n, n\\n -.* n n ---* n n ---* n Lambek Calculus, as such, is a propositional calculus.", "labels": [], "entities": []}, {"text": "There is no room to express additional constraints concerning the combination of categories.", "labels": [], "entities": []}, {"text": "Clearly, some kind of feature handling mechanism is needed to enable the grammar writer to state e.g. conditions on the agreement of morpho-syntactic features or to describe control phenomena.", "labels": [], "entities": []}, {"text": "For the reason of linguistic expressiveness and to facilitate the description of the parsing algorithm below, we extend Lambek Calculus to Unification Lambek Calculus (ULC).", "labels": [], "entities": []}, {"text": "First, the definition of basic category must be adapted: a basic category consists of anatomic category name and feature description.", "labels": [], "entities": []}, {"text": "(For the definition of feature descriptions or feature terms see].)", "labels": [], "entities": []}, {"text": "For complex categories, the same recursive definition applies as before.", "labels": [], "entities": []}, {"text": "The syntax for categories in ULC is given informally in which shows the category of a control verb like \"persuade\".", "labels": [], "entities": []}, {"text": "We assume that variable names for feature descriptions are local to each category", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": []}