{"title": [], "abstractContent": [{"text": "We show how unification can be used to specify the semantic interpretation of natural-language expressions, including problematical constructions involving long-distance dependencies.", "labels": [], "entities": []}, {"text": "We also sketch a theoretical foundation for unification-based semantic interpretation, and compare the unification-based approach with more conventional techniques based on the lambda calculus.", "labels": [], "entities": [{"text": "unification-based semantic interpretation", "start_pos": 44, "end_pos": 85, "type": "TASK", "confidence": 0.891035278638204}]}], "introductionContent": [{"text": "Over the past several years, unification-based formalisms have come to be widely used for specifying the syntax of natural languages, particularly among computational linguists.", "labels": [], "entities": [{"text": "specifying the syntax of natural languages", "start_pos": 90, "end_pos": 132, "type": "TASK", "confidence": 0.7741999427477518}]}, {"text": "It is less widely realized by computational linguists that unification can also be a powerful tool for specifying the semantic interpretation of natural languages.", "labels": [], "entities": [{"text": "specifying the semantic interpretation of natural languages", "start_pos": 103, "end_pos": 162, "type": "TASK", "confidence": 0.8161514912332807}]}, {"text": "While many of the techniques described in this paper are fairly well known among natural-language researchers working with logic grammars, they have not been extensively discussed in the literature, perhaps the only systematic presentation being that of.", "labels": [], "entities": []}, {"text": "This paper goes into many issues in greater detail than do Pereira and Shieber, however, and sketches what maybe the first theoretical analysis of unification-based semantic interpretation.", "labels": [], "entities": [{"text": "unification-based semantic interpretation", "start_pos": 147, "end_pos": 188, "type": "TASK", "confidence": 0.9217185179392496}]}, {"text": "We begin by reviewing the basic ideas behind unification-based grammar formalisms, which will also serve to introduce the style of notation to be used throughout the paper.", "labels": [], "entities": []}, {"text": "The notation is that used in the Core Language Engine (CLE) developed by SKI's Cambridge Computer Science Research Center in Cambridge, England, a system whose semantic-interpretation component makes use of many of the ideas presented here.", "labels": [], "entities": [{"text": "SKI's Cambridge Computer Science Research Center", "start_pos": 73, "end_pos": 121, "type": "DATASET", "confidence": 0.6921836733818054}]}, {"text": "Fundamentally, unification grammar is a generalization of context-free phrase structure grammar in which grammatical:category expressions are not simply atomic symbols, but have sets of features with constraints on their values.", "labels": [], "entities": [{"text": "unification grammar", "start_pos": 15, "end_pos": 34, "type": "TASK", "confidence": 0.9587084949016571}, {"text": "phrase structure grammar", "start_pos": 71, "end_pos": 95, "type": "TASK", "confidence": 0.6998022198677063}]}, {"text": "Such constraints are commonly specified using sets of equations.", "labels": [], "entities": []}, {"text": "Our notation uses equations of a very simple format--just ~eal;ure=value--and permits only one equation per feature per constituent, but we can indicate constraints that would be expressed in other formalisms using more complex equations by letting the value of a feature contain a variable that appears in more than one equation.", "labels": [], "entities": []}, {"text": "The CLE is written in Prolog, to take advantage of the efficiency of Prolog unification in implementing category unification, so our grammar rules are written as Prolog assertions, and we follow Prolog conventions in that constants, such as category and feature names, start with lowercase letters, and variables start with uppercase letters.", "labels": [], "entities": [{"text": "Prolog", "start_pos": 22, "end_pos": 28, "type": "DATASET", "confidence": 0.9304463267326355}, {"text": "Prolog unification", "start_pos": 69, "end_pos": 87, "type": "TASK", "confidence": 0.8159997463226318}, {"text": "category unification", "start_pos": 104, "end_pos": 124, "type": "TASK", "confidence": 0.7645091116428375}]}, {"text": "As an example, a simplified version of the rule for the basic subject-predicate sentence form might be written in our notation as The predicate syn indicates that this is a syntax rule, and the first argument s_npovp is a rule identifier that lets us key the semantic-interpretation rules to the syntax rules.", "labels": [], "entities": []}, {"text": "The second argument of syn is a list of category expressions that makeup the content of the rule, the first specifying the category of the mother constituent and the rest specifying the categories of the daughter constituents.", "labels": [], "entities": []}, {"text": "This rule, then, says that a tensed sentence (s:) can consist of a noun phrase (rip) followed by a verb phrase (vp), with the restrictions that the verb phrase must be tensed (type=tensed), and that the noun phrase and verb phrase must agree in person and number--that is, the person and num features of the noun phrase must have the same respective values as the person and mm features of the verb phrase.", "labels": [], "entities": []}, {"text": "These constraints are checked in the process of parsing a sentence by unifying the values of features specified in the rule with the values of features in the constituents found in the input.", "labels": [], "entities": []}, {"text": "Suppose, for instance, that we are parsing the sentence Mary runs using a left-corner parser.", "labels": [], "entities": [{"text": "parsing the sentence Mary runs", "start_pos": 35, "end_pos": 65, "type": "TASK", "confidence": 0.8469566702842712}]}, {"text": "If Mary is parsed as a constituent of category np:[person=3rd,num=sing], then unifying this category expression with np : in applying the sentence rule above will force the variables P and N to take on the values 3rd and s~_ug, respectively.", "labels": [], "entities": []}, {"text": "Thus when we try to parse the verb phrase, we know that it must be of the category vp : [type=tensed, person=3rd,num=sing].", "labels": [], "entities": []}, {"text": "Our notation for semantic-interpretation rules is a slight generalization of the notation for syntax rules.", "labels": [], "entities": []}, {"text": "The only change is that in each position where a syntax rule would have a category expression, a semantic rule has a pair consisting of a \"logical-form\" expression and a category expression, where the logical-form expression specifies the semantic interpretation of the corresponding constituent.", "labels": [], "entities": []}, {"text": "A semantic-interpretation rule corresponding to syntax rule (1) might look hke the following: The predicate sere means that this is a semanticinterpretation rule, and the rule identifier s..up_vp indicates that this rule applies to structures built by the syntax rule with the same identifier.", "labels": [], "entities": []}, {"text": "The list of pairs of logical-form expressions and category expressions specifies the logical form of the mother constituent in terms of the logical forms and feature values of the daughter constituents.", "labels": [], "entities": []}, {"text": "In this case the rule says that the logical form of a sentence generated by the s_np_vp rule is an applicative expression with the logical form of the verb phrase as the functor and the logical form of the noun phrase as the argument.", "labels": [], "entities": []}, {"text": "(The dummy functor apply is introduced because Prolog syntax does not allow variables in functor position.)", "labels": [], "entities": []}, {"text": "Note that there are no feature restrictions on any of the category expressions occurring in the rule.", "labels": [], "entities": []}, {"text": "They are unnecessary in this case because the semantic rule applies only to structures built by the s_np_vp syntax rule, and thus inherits all the restrictions applied by that rule.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": []}