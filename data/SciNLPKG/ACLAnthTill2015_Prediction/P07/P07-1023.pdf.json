{"title": [{"text": "Parsing and Generation as Datalog Queries", "labels": [], "entities": [{"text": "Parsing and Generation", "start_pos": 0, "end_pos": 22, "type": "TASK", "confidence": 0.7937256892522176}]}], "abstractContent": [{"text": "We show that the problems of parsing and surface realization for grammar formalisms with \"context-free\" derivations, coupled with Mon-tague semantics (under a certain restriction) can be reduced in a uniform way to Datalog query evaluation.", "labels": [], "entities": [{"text": "surface realization", "start_pos": 41, "end_pos": 60, "type": "TASK", "confidence": 0.7494467198848724}]}, {"text": "As well as giving a polynomial-time algorithm for computing all derivation trees (in the form of a shared forest) from an input string or input logical form, this reduction has the following complexity-theoretic consequences for all such formalisms: (i) the decision problem of recognizing grammaticality (surface realizability) of an input string (logical form) is in LOGCFL; and (ii) the search problem of finding one logical form (surface string) from an input string (logical form) is in functional LOGCFL.", "labels": [], "entities": []}, {"text": "Moreover, the generalized supplementary magic-sets rewriting of the Datalog program resulting from the reduction yields efficient Earley-style algorithms for both parsing and generation.", "labels": [], "entities": []}], "introductionContent": [{"text": "The representation of context-free grammars (augmented with features) in terms of definite clause programs is well-known.", "labels": [], "entities": []}, {"text": "In the case of a bare-bone CFG, the corresponding program is in the functionfree subset of logic programming, known as Datalog.", "labels": [], "entities": []}, {"text": "For example, determining whether a string John found a unicorn belongs to the language of the CFG in is equivalent to deciding whether the Datalog program in together with the database in (1) can derive the query \"?\u2212 S(0, 4).\"", "labels": [], "entities": [{"text": "CFG", "start_pos": 94, "end_pos": 97, "type": "DATASET", "confidence": 0.9605327248573303}]}, {"text": "(1) John(0, 1). found.", "labels": [], "entities": []}, {"text": "a(2, 3). unicorn.", "labels": [], "entities": []}, {"text": "By naive (or seminaive) bottom-up evaluation (see, e.g.,), the answer to such a query can be computed in polynomial time in the size of the database for any Datalog program.", "labels": [], "entities": []}, {"text": "By recording rule instances rather than derived facts, a packed representation of the complete set of Datalog derivation trees fora given query can also be obtained in polynomial time by the same technique.", "labels": [], "entities": []}, {"text": "Since a Datalog derivation tree uniquely determines a grammar derivation tree, this gives a reduction of context-free recognition and parsing to query evaluation in In this paper, we show that a similar reduction to Datalog is possible for more powerful grammar formalisms with \"context-free\" derivations, such as (multi-component) tree-adjoining grammars, IO macro grammars, and (parallel) multiple contextfree grammars.", "labels": [], "entities": [{"text": "context-free recognition and parsing", "start_pos": 105, "end_pos": 141, "type": "TASK", "confidence": 0.5797063857316971}]}, {"text": "For instance, the TAG in is represented by the Datalog program in.", "labels": [], "entities": []}, {"text": "Moreover, the method of reduc-176  tion extends to the problem of tactical generation (surface realization) for these grammar formalisms coupled with Montague semantics (under a certain restriction).", "labels": [], "entities": [{"text": "tactical generation (surface realization", "start_pos": 66, "end_pos": 106, "type": "TASK", "confidence": 0.7430513024330139}]}, {"text": "Our method essentially relies on the encoding of different formalisms in terms of abstract categorial grammars ().", "labels": [], "entities": []}, {"text": "The reduction to Datalog makes it possible to apply to parsing and generation sophisticated evaluation techniques for Datalog queries; in particular, an application of generalized supplementary magicsets rewriting) automatically yields Earley-style algorithms for both parsing and generation.", "labels": [], "entities": [{"text": "Datalog", "start_pos": 17, "end_pos": 24, "type": "DATASET", "confidence": 0.9596436619758606}, {"text": "parsing", "start_pos": 55, "end_pos": 62, "type": "TASK", "confidence": 0.9834262132644653}]}, {"text": "The reduction can also be used to obtain a tight upper bound, namely LOGCFL, on the computational complexity of the problem of recognition, both for grammaticality of input strings and for surface realizability of input logical forms.", "labels": [], "entities": [{"text": "LOGCFL", "start_pos": 69, "end_pos": 75, "type": "METRIC", "confidence": 0.9960999488830566}]}, {"text": "With regard to parsing and recognition of input strings, polynomial-time algorithms and the LOGCFL upper bound on the computational complexity are already known for the grammar formalisms covered by our results; nevertheless, we believe that our reduction to Datalog offers valuable insights.", "labels": [], "entities": [{"text": "parsing and recognition of input strings", "start_pos": 15, "end_pos": 55, "type": "TASK", "confidence": 0.7386609415213267}, {"text": "LOGCFL", "start_pos": 92, "end_pos": 98, "type": "METRIC", "confidence": 0.9784858226776123}]}, {"text": "Concerning generation, our results seem to be entirely new.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": []}