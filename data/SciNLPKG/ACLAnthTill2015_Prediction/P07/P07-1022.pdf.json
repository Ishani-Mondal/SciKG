{"title": [{"text": "Transforming Projective Bilexical Dependency Grammars into efficiently-parsable CFGs with Unfold-Fold", "labels": [], "entities": [{"text": "Transforming Projective Bilexical Dependency Grammars", "start_pos": 0, "end_pos": 53, "type": "TASK", "confidence": 0.8653116703033448}]}], "abstractContent": [{"text": "This paper shows how to use the Unfold-Fold transformation to transform Projective Bilexical Dependency Grammars (PBDGs) into ambiguity-preserving weakly equivalent Context-Free Grammars (CFGs).", "labels": [], "entities": []}, {"text": "These CFGs can be parsed in O(n 3) time using a CKY algorithm with appropriate indexing, rather than the O(n 5) time required by a naive encoding.", "labels": [], "entities": [{"text": "CFGs", "start_pos": 6, "end_pos": 10, "type": "DATASET", "confidence": 0.8080264925956726}]}, {"text": "Informally, using the CKY algorithm with such a CFG mimics the steps of the Eisner-Satta O(n 3) PBDG parsing algorithm.", "labels": [], "entities": []}, {"text": "This transformation makes all of the techniques developed for CFGs available to PBDGs.", "labels": [], "entities": [{"text": "PBDGs", "start_pos": 80, "end_pos": 85, "type": "DATASET", "confidence": 0.8754048347473145}]}, {"text": "We demonstrate this by describing a maximum posterior parse decoder for PBDGs.", "labels": [], "entities": []}], "introductionContent": [{"text": "Projective Bilexical Dependency Grammars (PBDGs) have attracted attention recently for two reasons.", "labels": [], "entities": [{"text": "Projective Bilexical Dependency Grammars (PBDGs)", "start_pos": 0, "end_pos": 48, "type": "TASK", "confidence": 0.7291341849735805}]}, {"text": "First, because they capture bilexical head-tohead dependencies they are capable of producing extremely high-quality parses: state-of-the-art discriminatively trained PBDG parsers rival the accuracy of the very best statistical parsers available today).", "labels": [], "entities": [{"text": "accuracy", "start_pos": 189, "end_pos": 197, "type": "METRIC", "confidence": 0.9960674047470093}]}, {"text": "Second, Eisner-Satta O(n 3 ) PBDG parsing algorithms are extremely fast.", "labels": [], "entities": [{"text": "PBDG parsing", "start_pos": 29, "end_pos": 41, "type": "TASK", "confidence": 0.6587254106998444}]}, {"text": "This paper investigates the relationship between Context-Free Grammar (CFG) parsing and the Eisner/Satta PBDG parsing algorithms, including their extension to second-order PBDG parsing).", "labels": [], "entities": [{"text": "Context-Free Grammar (CFG) parsing", "start_pos": 49, "end_pos": 83, "type": "TASK", "confidence": 0.6377119272947311}]}, {"text": "Specifically, we show how to use an off-line preprocessing step, the Unfold-Fold transformation, to transform a PBDG into an equivalent CFG that can be parsed in O(n 3 ) time using aversion of the CKY algorithm with suitable indexing, and extend this transformation so that it captures second-order PBDG dependencies as well.", "labels": [], "entities": []}, {"text": "The transformations are ambiguity-preserving, i.e., there is a one-toone mapping between dependency parses and CFG parses, so it is possible to map the CFG parses back to the PBDG parses they correspond to.", "labels": [], "entities": []}, {"text": "The PBDG to CFG reductions make techniques developed for CFGs available to PBDGs as well.", "labels": [], "entities": [{"text": "CFG reductions", "start_pos": 12, "end_pos": 26, "type": "TASK", "confidence": 0.6874920427799225}]}, {"text": "For example, incremental CFG parsing algorithms can be used with the CFGs produced by this transform, as can the Inside-Outside estimation algorithm) and more exotic methods such as estimating adjoined hidden states ().", "labels": [], "entities": [{"text": "CFG parsing", "start_pos": 25, "end_pos": 36, "type": "TASK", "confidence": 0.7741219699382782}]}, {"text": "As an example application, we describe a maximum posterior parse decoder for PBDGs in Section 8.", "labels": [], "entities": []}, {"text": "The Unfold-Fold transformation is a calculus for transforming functional and logic programs into equivalent but (hopefully) faster programs (.", "labels": [], "entities": []}, {"text": "We use it hereto transform CFGs encoding dependency grammars into other CFGs that are more efficiently parsable.", "labels": [], "entities": [{"text": "CFGs encoding dependency grammars", "start_pos": 27, "end_pos": 60, "type": "TASK", "confidence": 0.6783648133277893}]}, {"text": "Since CFGs can be expressed as Horn-clause logic programs and the UnfoldFold transformation is provably correct for such programs, it follows that its application to CFGs is provably correct as well.", "labels": [], "entities": []}, {"text": "The Unfold-Fold transformation is used hereto derive the CFG schemata presented in sections 5-7.", "labels": [], "entities": [{"text": "CFG schemata", "start_pos": 57, "end_pos": 69, "type": "DATASET", "confidence": 0.9307175576686859}]}, {"text": "A system that uses these schemata (such as the one described in section 8) can implementthese schemata directly, so the Unfold-Fold transformation plays a theoretical role in this work, justifying the resulting CFG schemata.", "labels": [], "entities": [{"text": "CFG schemata", "start_pos": 211, "end_pos": 223, "type": "DATASET", "confidence": 0.8732701241970062}]}, {"text": "The closest related work we are aware of is, which also describes a reduction of PBDGs to efficiently-parsable CFGs and directly inspired this work.", "labels": [], "entities": []}, {"text": "However, the CFGs produced by McAllester's transformation include epsilon-productions so they require a specialized CFG parsing algorithm, while the CFGs produced by the transformations described here have binary productions so they can be parsed with standard CFG parsing algorithms.", "labels": [], "entities": [{"text": "CFG parsing", "start_pos": 116, "end_pos": 127, "type": "TASK", "confidence": 0.6308799684047699}, {"text": "CFG parsing", "start_pos": 261, "end_pos": 272, "type": "TASK", "confidence": 0.6187047362327576}]}, {"text": "Further, our approach extends to second-order PBDG parsing, while McAllester only discusses first-order PBDGs.", "labels": [], "entities": [{"text": "PBDG parsing", "start_pos": 46, "end_pos": 58, "type": "TASK", "confidence": 0.7377107441425323}]}, {"text": "The rest of this paper is structured as follows.", "labels": [], "entities": []}, {"text": "Section 2 defines projective dependency graphs and grammars and Section 3 reviews the \"naive\" encoding of PBDGs as CFGs with an O(n 5 ) parse time, where n is the length of the string to be parsed.", "labels": [], "entities": []}, {"text": "Section 4 introduces the \"split-head\" CFG encoding of PBDGs, which has an O(n 4 ) parse time and serves as the input to the Unfold-Fold transform.", "labels": [], "entities": [{"text": "O(n 4 ) parse time", "start_pos": 74, "end_pos": 92, "type": "METRIC", "confidence": 0.8310221433639526}]}, {"text": "Section 5 uses the Unfold-Fold transform to obtain a weaklyequivalent CFG encoding of PBDGs which can be parsed in O(n 3 ) time, and presents timing results showing that the transformation does speed parsing.", "labels": [], "entities": []}, {"text": "Sections 6 and 7 apply Unfold-Fold in slightly more complex ways to obtain CFG encodings of PBDGs that also make second-order dependencies available in O(n 3 ) time parsable CFGs.", "labels": [], "entities": [{"text": "O(n 3 ) time parsable CFGs", "start_pos": 152, "end_pos": 178, "type": "TASK", "confidence": 0.5274864956736565}]}, {"text": "Section 8 applies a PBDG to CFG transform to obtain a maximum posterior decoding parser for PBDGs.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": []}