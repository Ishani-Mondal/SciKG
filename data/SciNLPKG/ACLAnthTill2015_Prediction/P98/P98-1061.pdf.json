{"title": [{"text": "A structure-sharing parser for lexicalized grammars", "labels": [], "entities": []}], "abstractContent": [{"text": "In wide-coverage lexicalized grammars many of the elementary structures have substructures in common.", "labels": [], "entities": []}, {"text": "This means that in conventional parsing algorithms some of the computation associated with different structures is duplicated.", "labels": [], "entities": []}, {"text": "In this paper we describe a precompilation technique for such grammars which allows some of this computation to be shared.", "labels": [], "entities": []}, {"text": "In our approach the elementary structures of the grammar are transformed into finite state automata which can be merged and minimised using standard algorithms , and then parsed using an automaton-based parser.", "labels": [], "entities": []}, {"text": "We present algorithms for constructing automata from elementary structures, merging and minimising them, and string recognition and parse recovery with the resulting grammar.", "labels": [], "entities": [{"text": "string recognition", "start_pos": 109, "end_pos": 127, "type": "TASK", "confidence": 0.8107973039150238}, {"text": "parse recovery", "start_pos": 132, "end_pos": 146, "type": "TASK", "confidence": 0.884304016828537}]}], "introductionContent": [{"text": "It is well-known that fully lexicalised grammar formalisms such as LTAG are difficult to parse with efficiently.", "labels": [], "entities": []}, {"text": "Each word in the parser's input string introduces an elementary tree into the parse table for each of its possible readings, and there is often a substantial overlap in structure between these trees.", "labels": [], "entities": []}, {"text": "A conventional parsing algorithm views the trees as independent, and so is likely to duplicate the processing of this common structure.", "labels": [], "entities": []}, {"text": "Parsing could be made more efficient (empirically if not formally), if the shared structure could be identified and processed only once.", "labels": [], "entities": [{"text": "Parsing", "start_pos": 0, "end_pos": 7, "type": "TASK", "confidence": 0.9680083990097046}]}, {"text": "Recent work by and addresses this problem from two different perspectives.", "labels": [], "entities": []}, {"text": "Evans and outline a technique for compiling LTAG grammars into automata which are then merged to introduce some sharing of structure.", "labels": [], "entities": []}, {"text": "Chen and Vijay-Shanker (1997) use underspecified tree descriptions to represent sets of trees during parsing.", "labels": [], "entities": []}, {"text": "The present paper takes the former approach, but extends our previous work by: \u2022 showing how merged automata can be minimised, so that they share as much structure as possible; \u2022 showing that by precompiling additional information, parsing can be broken down into recognition followed by parse recovery; \u2022 providing a formal treatment of the algorithms for transforming and minimising the grammar, recognition and parse recovery.", "labels": [], "entities": [{"text": "parse recovery", "start_pos": 288, "end_pos": 302, "type": "TASK", "confidence": 0.8822092413902283}, {"text": "parse recovery", "start_pos": 414, "end_pos": 428, "type": "TASK", "confidence": 0.8423007428646088}]}, {"text": "In the following sections we outline the basic approach, and describe informally our improvements to the previous account.", "labels": [], "entities": []}, {"text": "We then give a formal account of the optimisation process and a possible parsing algorithm that makes use of it 1 . 2 Automaton-based parsing Conventional LTAG parsers) maintain a parse table, a set of items corresponding to complete and partial constituents.", "labels": [], "entities": [{"text": "parsing", "start_pos": 73, "end_pos": 80, "type": "TASK", "confidence": 0.9648462533950806}]}, {"text": "Parsing proceeds by first seeding the table with items anchored on the input string, and then repeatedly scanning The main types of parser actions are: 1.", "labels": [], "entities": [{"text": "Parsing", "start_pos": 0, "end_pos": 7, "type": "TASK", "confidence": 0.9589989185333252}]}, {"text": "extending a constituent by incorporating a complete subconstituent (on the left or 1However, due to lack of space, no proofs and only minimal informal descriptions are given in this paper. right); 2.", "labels": [], "entities": []}, {"text": "extending a constituent by adjoining a surrounding complete auxiliary constituent; 3.", "labels": [], "entities": []}, {"text": "predicting the span of the foot node of an auxiliary constituent (to the left or right).", "labels": [], "entities": []}, {"text": "Parsing is complete when all possible parser actions have been executed.", "labels": [], "entities": [{"text": "Parsing", "start_pos": 0, "end_pos": 7, "type": "TASK", "confidence": 0.9113059043884277}]}, {"text": "Ina completed parse table it is possible to trace the sequence of items corresponding to the recognition of an elementary tree from its lexical anchor upwards.", "labels": [], "entities": []}, {"text": "Each item in the sequence corresponds to anode in the tree (with the sequence as a whole corresponding to a complete traversal of the tree), and each step corresponds to the parser action that licensed the next item, given the current one.", "labels": [], "entities": []}, {"text": "From this perspective, parser actions can be restated relative to the items in such a sequence as: 1.", "labels": [], "entities": []}, {"text": "substitute a complete subconstituent (on the left or right); 2.", "labels": [], "entities": []}, {"text": "adjoin a surrounding complete auxiliary constituent; 3.", "labels": [], "entities": []}, {"text": "predict the span of the tree's foot node (to the left or right).", "labels": [], "entities": []}, {"text": "The recognition of the tree can thus be viewed as the computation of a finite state automaton, whose states correspond to a traversal of the tree and whose input symbols are these relao tivised parser actions.", "labels": [], "entities": []}, {"text": "This perspective suggests a re-casting of the conventional LTAG parser in terms of such automata 2.", "labels": [], "entities": []}, {"text": "For this automaton-based parser, the grammar structures are not trees, but automata corresponding to tree traversals whose inputs are strings of relativised parser actions.", "labels": [], "entities": []}, {"text": "Items in the parse table reference automaton states instead of tree addresses, and if the automaton state is final, the item represents a complete constituent.", "labels": [], "entities": []}, {"text": "Parser actions arise as before, but are executed by relativising them with respect to the incomplete item participating in the action, and passing this relativised parser action as the next input symbol for the automaton referenced by that item.", "labels": [], "entities": []}, {"text": "The resulting state of that automaton is then used as the referent of the newly licensed item.", "labels": [], "entities": []}, {"text": "On a first pass, this re-casting is exactly that: it does nothing new or different from the original 2Evans and Weir (1997) provides a longer informal introduction to this approach.", "labels": [], "entities": [{"text": "2Evans", "start_pos": 101, "end_pos": 107, "type": "DATASET", "confidence": 0.9300793409347534}]}, {"text": "parser on the original grammar.", "labels": [], "entities": []}, {"text": "However there area number of subtle differences3: \u2022 the automata are more abstract than the trees: the only grammatical information they contain are the input symbols and the root node labels, indicating the category of the constituent the automaton recognises; \u2022 automata for several trees can be merged together and optimised using standard well-studied techniques, resulting in a single automaton that recognises many trees at once, sharing as many of the common parser actions as possible.", "labels": [], "entities": []}, {"text": "It is this final point which is the focus of this paper.", "labels": [], "entities": []}, {"text": "By representing trees as automata, we can merge trees together and apply standard optimisation techniques to share their common structure.", "labels": [], "entities": []}, {"text": "The parser will remain unchanged, but will operate more efficiently where structure has been shared.", "labels": [], "entities": []}, {"text": "Additionally, because the automata are more abstract than the trees, capturing precisely the parser's view of the trees, sharing may occur between trees which are structurally quite different, but which happen to have common parser actions associated with them.", "labels": [], "entities": []}, {"text": "3 Merging and minimising automata Combining the automata for several trees can be achieved using a variety of standard algorithms).", "labels": [], "entities": []}, {"text": "However any transformations must respect one important feature: once the parser reaches a final state it needs to know what tree it has just recognised 4.", "labels": [], "entities": []}, {"text": "When automata for trees with different root categories are merged, the resulting automaton needs to somehow indicate to the parser what trees are associated with its final states.", "labels": [], "entities": []}, {"text": "In, we combined automata by introducing anew initial state with e-transitions to each of the original initial states, 3A further difference is that the traversal encoded in the automaton captures part of the parser's control strategy.", "labels": [], "entities": []}, {"text": "However for simplicity we assume here a fixed parser control strategy (bottom-up, anchor-out) and do not pursue this point further -Evans and Weir (1997) offers some discussion.", "labels": [], "entities": []}, {"text": "4For recognition alone it only needs to know the root category of the tree, but to recover the parse it needs to identify the tree itself. and then determinising the resulting automaton to induce some sharing of structure.", "labels": [], "entities": []}, {"text": "To recover trees, final automaton states were annotated with the number of the tree the final state is associated with, which the parser can then readily access.", "labels": [], "entities": []}, {"text": "However, the drawback of this approach is that differently annotated final states can never be merged, which restricts the scope for structure sharing (minimisation, for example, is not possible since all the final states are distinct).", "labels": [], "entities": []}, {"text": "To overcome this, we propose an alternative approach as follows: \u2022 each automaton transition is annotated with the set of trees which pass through it: when transitions are merged in automaton optimisation, their annotations are unioned; \u2022 the parser maintains for each item in the table the set of trees that are valid for the item: initially this is all the valid trees for the automaton, but gets intersected with the annotation of any transition followed; also if two paths through the automaton meet (i.e., an item is about to be added fora second time), their annotations get unioned.", "labels": [], "entities": []}, {"text": "This approach supports arbitrary merging of states, including merging all the final states into one.", "labels": [], "entities": []}, {"text": "The parser maintains a dynamic record of which trees are valid for states (in particular final states) in the parse table.", "labels": [], "entities": []}, {"text": "This means that we can minimise our automata as well as determinising them, and so share more structure (for example, common processing at the end of the recognition process as well as the beginning).", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": [{"text": " Table 1: DTG compaction results (from Carroll et al. (1998)).", "labels": [], "entities": [{"text": "DTG compaction", "start_pos": 10, "end_pos": 24, "type": "TASK", "confidence": 0.6554120928049088}]}]}