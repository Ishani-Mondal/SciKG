{"title": [{"text": "Evolving optimal inspectable strategies for spoken dialogue systems", "labels": [], "entities": []}], "abstractContent": [{"text": "We report on a novel approach to generating strategies for spoken dialogue systems.", "labels": [], "entities": []}, {"text": "We present a series of experiments that illustrate how an evolutionary reinforcement learning algorithm can produce strategies that are both optimal and easily inspectable by human developers.", "labels": [], "entities": []}, {"text": "Our experimental strategies achieve a mean performance of 98.9% with respect to a pre-defined evaluation metric.", "labels": [], "entities": []}, {"text": "Our approach also produces a dramatic reduction in strategy size when compared with conventional reinforcement learning techniques (87% in one experiment).", "labels": [], "entities": []}, {"text": "We conclude that this algorithm can be used to evolve optimal inspectable dialogue strategies.", "labels": [], "entities": []}], "introductionContent": [{"text": "Developing a dialogue management strategy fora spoken dialogue system is often a complex and timeconsuming task.", "labels": [], "entities": [{"text": "dialogue management", "start_pos": 13, "end_pos": 32, "type": "TASK", "confidence": 0.7336913645267487}]}, {"text": "This is because the number of unique conversations that can occur between a user and the system is almost unlimited.", "labels": [], "entities": []}, {"text": "Consequently, a system developer may spend a lot of time anticipating how potential users might interact with the system before deciding on the appropriate system response.", "labels": [], "entities": []}, {"text": "Recent research has focused on generating dialogue strategies automatically.", "labels": [], "entities": []}, {"text": "This work is based on modelling dialogue as a markov decision process, formalised by a finite state space S, a finite action set A, a set of transition probabilities T and a reward function R.", "labels": [], "entities": []}, {"text": "Using this model an optimal dialogue strategy \u03c0 * is represented by a mapping between the state space and the action set.", "labels": [], "entities": []}, {"text": "That is, for each state s \u2208 S this mapping defines its optimal action a * s . How is this mapping constructed?", "labels": [], "entities": []}, {"text": "Previous approaches have employed reinforcement learning (RL) algorithms to estimate an optimal value function Q * ().", "labels": [], "entities": [{"text": "reinforcement learning (RL)", "start_pos": 34, "end_pos": 61, "type": "TASK", "confidence": 0.6921784162521363}]}, {"text": "For each state this function predicts the future reward associated with each action available in that state.", "labels": [], "entities": []}, {"text": "This function makes it easy to extract the optimal strategy (policy in the RL literature).", "labels": [], "entities": [{"text": "RL literature", "start_pos": 75, "end_pos": 88, "type": "DATASET", "confidence": 0.8676075637340546}]}, {"text": "Progress has been made with this approach but some important challenges remain.", "labels": [], "entities": []}, {"text": "For instance, very little success has been achieved with the large state spaces that are typical of real-life systems.", "labels": [], "entities": []}, {"text": "Similarly, work on summarising learned strategies for interpretation by human developers has so far only been applied to tasks where each state-action pair is explicitly represented.", "labels": [], "entities": [{"text": "summarising learned strategies for interpretation by human developers", "start_pos": 19, "end_pos": 88, "type": "TASK", "confidence": 0.7905630096793175}]}, {"text": "This tabular representation severely limits the size of the state space.", "labels": [], "entities": []}, {"text": "We propose an alternative approach to finding optimal dialogue policies.", "labels": [], "entities": []}, {"text": "We make use of XCS, an evolutionary reinforcement learning algorithm that seeks to represent a policy as a compact set of stateaction rules.", "labels": [], "entities": []}, {"text": "We suggest that this algorithm could overcome both the challenge of large state spaces and the desire for strategy inspectability.", "labels": [], "entities": []}, {"text": "In this paper, we focus on the issue of inspectability.", "labels": [], "entities": []}, {"text": "We present a series of experiments that illustrate how XCS can be used to evolve dialogue strategies that are both optimal and easily inspectable.", "labels": [], "entities": []}], "datasetContent": [{"text": "In this section we present a simple slot-filling system based on the hotel booking domain.", "labels": [], "entities": []}, {"text": "The goal of the system is to acquire the values for three slots: the check-in date, the number of nights the user wishes to stay and the type of room required (single, twin etc.).", "labels": [], "entities": []}, {"text": "In slot-filling dialogues, an optimal strategy is one that interacts with the user in a satisfactory way while trying to minimise the length of the dialogue.", "labels": [], "entities": [{"text": "slot-filling dialogues", "start_pos": 3, "end_pos": 25, "type": "TASK", "confidence": 0.8471968472003937}]}, {"text": "A fundamental component of user satisfaction is the system's prevention and repair of any miscommunication between it and the user.", "labels": [], "entities": []}, {"text": "Consequently, our hotel booking system focuses on evolving essential slot confirmation strategies.", "labels": [], "entities": [{"text": "slot confirmation", "start_pos": 69, "end_pos": 86, "type": "TASK", "confidence": 0.8109748065471649}]}, {"text": "We devised an experimental framework for modelling the hotel system as a sequential decision task and used XCS to evolve three behaviours.", "labels": [], "entities": []}, {"text": "Firstly, the system should execute its dialogue acts in a logical sequence.", "labels": [], "entities": []}, {"text": "In other words, the system should greet the user, ask for the slot information, present the query results and then finish the dialogue, in that order (Experiment 1).", "labels": [], "entities": []}, {"text": "Secondly, the system should try to acquire the slot values as quickly as possible while taking account of the possibility of misrecognition (Experiments 2a and 2b).", "labels": [], "entities": []}, {"text": "Thirdly, to increase the likelihood of acquiring the slot values correctly, each one should be confirmed at least once (Experiments 3 and 4).", "labels": [], "entities": []}, {"text": "The reward function for Experiments 1, 2a and 2b was the same.", "labels": [], "entities": []}, {"text": "During a dialogue, each nonterminal system action received a reward value of zero.", "labels": [], "entities": []}, {"text": "At the end of each dialogue, the final reward comprised three parts: (i) -1000 for each system turn; (ii) 100,000 if all slots were filled; (iii) 100,000 if the first system act was a greeting.", "labels": [], "entities": []}, {"text": "In Experiments 3 and 4, an additional reward of 100,000 was assigned if all slots were confirmed.", "labels": [], "entities": []}, {"text": "The transition probabilities were modelled using two versions of a handcoded simulated user.", "labels": [], "entities": []}, {"text": "Avery large number of test dialogues are usually required for learning optimal dialogue strategies; simulated users area practical alternative to employing human test users).", "labels": [], "entities": []}, {"text": "Simulated user A represented a fully cooperative user, always giving the slot information that was asked.", "labels": [], "entities": []}, {"text": "User B was less cooperative, giving no response 20% of the time.", "labels": [], "entities": []}, {"text": "This allowed us to perform a two-fold cross validation of the evolved strategies.", "labels": [], "entities": []}, {"text": "For each experiment we allowed the system's strategy to evolve over 100,000 dialogues with each simulated user.", "labels": [], "entities": []}, {"text": "Dialogues were limited to a maximum of 30 system turns.", "labels": [], "entities": []}, {"text": "We then tested each strategy with a further 10,000 dialogues.", "labels": [], "entities": []}, {"text": "We logged the total reward (payoff) for each test dialogue.", "labels": [], "entities": [{"text": "total reward (payoff)", "start_pos": 14, "end_pos": 35, "type": "METRIC", "confidence": 0.6913743257522583}]}, {"text": "Each experiment was repeated ten times.", "labels": [], "entities": []}, {"text": "In each experiment, the presentation of the query results and closure of the dialogue were combined into a single dialogue act.", "labels": [], "entities": []}, {"text": "Therefore, the dialogue acts available to the system for the first experiment were: Greeting, Query+Goodbye, Ask(Date), Ask(Duration) and Ask(RoomType).", "labels": [], "entities": [{"text": "Ask(Duration)", "start_pos": 120, "end_pos": 133, "type": "METRIC", "confidence": 0.8895103484392166}, {"text": "Ask", "start_pos": 138, "end_pos": 141, "type": "METRIC", "confidence": 0.9160529971122742}]}, {"text": "Four boolean variables were used to represent the state of the dialogue: GreetingFirst, DateFilled, DurationFilled, RoomFilled.", "labels": [], "entities": []}, {"text": "Experiment 2 added anew dialogue act: Ask(All).", "labels": [], "entities": []}, {"text": "The goal here was to ask for all three slot values if the probability of getting the slot values was reasonably high.", "labels": [], "entities": []}, {"text": "If the probability was low, the system should ask for the slots one at a time as before.", "labels": [], "entities": []}, {"text": "This information was modelled in the simulated users by 2 variables: Prob1SlotCorrect and Prob3SlotsCorrect.", "labels": [], "entities": [{"text": "Prob1SlotCorrect", "start_pos": 69, "end_pos": 85, "type": "DATASET", "confidence": 0.9104422330856323}, {"text": "Prob3SlotsCorrect", "start_pos": 90, "end_pos": 107, "type": "DATASET", "confidence": 0.944822371006012}]}, {"text": "The values for these variables in Experiments 2a and 2b respectively were: 0.9 and 0.729 (=0.9 3 ); 0.5 and 0.125 (=0.5 3 ).", "labels": [], "entities": []}, {"text": "Experiment 3 added three new dialogue acts: Explicit Confirm(Date), Explicit Confirm(Duration), Explicit Confirm(RoomType) and three new state variables: DateConfirmed, DurationConfirmed, RoomConfirmed.", "labels": [], "entities": []}, {"text": "The goal here was for the system to learn to confirm each of the slot values after the user has first given them.", "labels": [], "entities": []}, {"text": "Experiment 4 sought to reduce the dialogue length further by allowing the system to confirm one slot value while asking for another.", "labels": [], "entities": []}, {"text": "Two new dialogue acts were available in this last experiment: Implicit Confirm(Date)+Ask(Duration) and Implicit Confirm(Duration)+Ask(RoomType).", "labels": [], "entities": [{"text": "Implicit Confirm(Date)+Ask(Duration)", "start_pos": 62, "end_pos": 98, "type": "METRIC", "confidence": 0.8274880250295004}]}, {"text": "lists the total reward (payoff) averaged over the 10 cross-validated test trials for each experiment, expressed as a percentage of the maximum payoff.", "labels": [], "entities": [{"text": "reward (payoff) averaged", "start_pos": 16, "end_pos": 40, "type": "METRIC", "confidence": 0.7129817128181457}]}, {"text": "In these experiments, the maximum payoff represents the shortest possible successful dialogue.", "labels": [], "entities": []}, {"text": "For example, the maximum payoff for Experiment 1 is 195,000: 100,000 for filling the slots plus 100,000 for greeting the user at the start of the dialogue minus 5000 for the minimum number of turns (five) taken to complete the dialogue successfully.", "labels": [], "entities": []}, {"text": "The average payoff for the 10 trials trained on simulated user A and tested on user B was 193,877 -approximately 99.4% of the maximum possible.", "labels": [], "entities": []}, {"text": "In light of these results and the stochastic user responses, we suggest that these evolved strategies would compare favourably with any handcoded strategies.", "labels": [], "entities": []}, {"text": "It is instructive to compare the rate of convergence for different strategies.", "labels": [], "entities": []}, {"text": "shows the average payoff for the 100,000 dialogues trained with simulated user A in Experiments 3 and 4.", "labels": [], "entities": []}, {"text": "It shows that Experiment 3 approached the optimal policy after approximately 20,000 dialogues whereas Experiment 4 converged after approximately 5000 dialogues.", "labels": [], "entities": []}, {"text": "This is encouraging because it suggests that XCS remains focused on finding the shortest successful dialogue even when the number of available actions increases.", "labels": [], "entities": []}, {"text": "Finally, we look at how to represent an optimal strategy.", "labels": [], "entities": []}, {"text": "From the logs of the test dialogues we extracted the state-action rules (classifiers) that were executed.", "labels": [], "entities": []}, {"text": "For example, in Experiment 4, the op-: A summary of the optimal strategy for Experiment 4.", "labels": [], "entities": []}, {"text": "timal strategy is represented by 17 classifiers.", "labels": [], "entities": []}, {"text": "By comparison, a purely RL-based strategy would define an optimal action for every theoretically possible state (i.e. 128).", "labels": [], "entities": []}, {"text": "In this example, the evolutionary approach has reduced the number of rules from 128 to 17 (a reduction of 87%) and is therefore much more easily inspectable.", "labels": [], "entities": []}, {"text": "In fact, the size of the optimal strategy can be reduced further by selecting the most general classifier for each action).", "labels": [], "entities": []}, {"text": "These rules are sufficient since they cover the 60 states that could actually occur while following the optimal strategy.", "labels": [], "entities": []}], "tableCaptions": [{"text": " Table 1: Payoff results for the evolved strategies.", "labels": [], "entities": [{"text": "Payoff", "start_pos": 10, "end_pos": 16, "type": "METRIC", "confidence": 0.9049544930458069}]}]}