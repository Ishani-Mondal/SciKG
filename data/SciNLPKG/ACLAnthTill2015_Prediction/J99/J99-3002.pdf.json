{"title": [{"text": "The Computational Complexity of the Correct-Prefix Property for TAGs", "labels": [], "entities": [{"text": "TAGs", "start_pos": 64, "end_pos": 68, "type": "TASK", "confidence": 0.5195614695549011}]}], "abstractContent": [{"text": "A new upper bound is presented for the computational complexity of the parsing problem for TAGs, under the constraint that input is read from left to right in such away that errors in the input are observed as soon as possible, which is called the \"correct-prefix property.\"", "labels": [], "entities": [{"text": "parsing problem", "start_pos": 71, "end_pos": 86, "type": "TASK", "confidence": 0.9306840598583221}]}, {"text": "The former upper bound, O(n9), is now improved to O(n6), which is the same as that of practical parsing algorithms for TAGs without the additional constraint of the correct-prefix property.", "labels": [], "entities": [{"text": "O", "start_pos": 24, "end_pos": 25, "type": "METRIC", "confidence": 0.9846550226211548}, {"text": "O", "start_pos": 50, "end_pos": 51, "type": "METRIC", "confidence": 0.9891732931137085}]}], "introductionContent": [{"text": "Traditionally, parsers and recognizers for regular and context-free languages process input from left to right.", "labels": [], "entities": []}, {"text": "If a syntax error occurs in the input they often detect that error immediately after its position is reached.", "labels": [], "entities": []}, {"text": "The position of the syntax error can be defined as the rightmost symbol of the shortest prefix of the input that cannot be extended to be a correct sentence in the language L.", "labels": [], "entities": []}, {"text": "In formal notation, this prefix fora given erroneous input w ~ L is defined as the string va, where w = vax, for some x, such that vy E L, for some y, but vaz ~ L, for any z.", "labels": [], "entities": []}, {"text": "(The symbols v, w .... denote strings, and a denotes an input symbol.)", "labels": [], "entities": []}, {"text": "The occurrence of a in w indicates the error position.", "labels": [], "entities": [{"text": "error", "start_pos": 39, "end_pos": 44, "type": "METRIC", "confidence": 0.9618541598320007}]}, {"text": "If the error is detected as soon as it is reached, then all prefixes of the input that have been processed at preceding stages are correct prefixes, or more precisely, they are prefixes of some correct strings in the language.", "labels": [], "entities": []}, {"text": "Hence, we speak of the correct-prefix property.", "labels": [], "entities": []}, {"text": "An important application can be found in the area of grammar checking: upon finding an ungrammatical sentence in a document, a grammar checker may report to the user the presumed position of the error, obtained from a parsing algorithm with the correct-prefix property.", "labels": [], "entities": [{"text": "grammar checking", "start_pos": 53, "end_pos": 69, "type": "TASK", "confidence": 0.7713571190834045}]}, {"text": "For context-free and regular languages, the correct-prefix property can be satisfied without additional costs of space or time.", "labels": [], "entities": []}, {"text": "Surprisingly, it has been claimed by that this property is problematic for the mildly contextsensitive languages represented by tree-adjoining grammars (TAGs): the best practical parsing algorithms for TAGs have time complexity Cg(n 6) (Vijay-Shankar and Joshi; see Satta and Rajasekaran and Yooseph for lower theoretical upper bounds), whereas the only published algorithm with the correct-prefix property--that by--has complexity O(n9).", "labels": [], "entities": []}, {"text": "In this paper we present an algorithm that satisfies the correct-prefix property and operates in Cq(n 6) time.", "labels": [], "entities": []}, {"text": "This algorithm merely recognizes input, but it can be extended I is the set of initial trees, and A is the set of auxiliary trees.", "labels": [], "entities": []}, {"text": "We refer to the trees in I U A as elementary trees.", "labels": [], "entities": []}, {"text": "The set NT, the set of nonterminals, does not play any role in this paper.", "labels": [], "entities": []}, {"text": "We refer to the root of an elementary tree t as Rt.", "labels": [], "entities": []}, {"text": "Each auxiliary tree has exactly one distinguished leaf, which is called the foot.", "labels": [], "entities": []}, {"text": "We refer to the foot of an auxiliary tree t as Ft.", "labels": [], "entities": [{"text": "Ft", "start_pos": 47, "end_pos": 49, "type": "DATASET", "confidence": 0.9854477047920227}]}, {"text": "We use variables N and M to range over nodes in elementary trees.", "labels": [], "entities": []}, {"text": "We assume that the sets of nodes belonging to distinct elementary trees are pairwise disjoint.", "labels": [], "entities": []}, {"text": "For each leaf N in an elementary tree, except when it is afoot, we define label(N) to be the label of the node, which is either a terminal from ~ or the empty string e.", "labels": [], "entities": []}, {"text": "For all other nodes, label is undefined.", "labels": [], "entities": []}, {"text": "For each node N that is not a leaf or that is afoot, Adj(N) is the set of auxiliary trees that can be adjoined at N, plus possibly the special element nil.", "labels": [], "entities": []}, {"text": "For all other nodes, Adj is undefined.", "labels": [], "entities": []}, {"text": "If a set Adj(N) contains nil, then this indicates that adjunction at N is not obligatory.", "labels": [], "entities": []}, {"text": "For each nonleaf node N we define children(N) as the (nonempty) list of daughter nodes.", "labels": [], "entities": []}, {"text": "For all other nodes, children is undefined.", "labels": [], "entities": []}, {"text": "An example of a TAG is given in.", "labels": [], "entities": [{"text": "TAG", "start_pos": 16, "end_pos": 19, "type": "TASK", "confidence": 0.6434517502784729}]}, {"text": "The language described by a TAG is given by the set of strings that are the yields of derived trees.", "labels": [], "entities": []}, {"text": "A derived tree is obtained from an initial tree by performing the following operation on each node N, except when it is a leaf: The tree is excised at N, and between the two halves afresh instance of an auxiliary tree, which is taken from the set Adj(N), is inserted, or the element nil is taken from Adj(N), in which case no new nodes are added to the tree.", "labels": [], "entities": []}, {"text": "Insertion of the new auxiliary tree, which from now on will be called adjunction, is done in such away that the bottom half of the excised tree is connected to the foot of the auxiliary tree.", "labels": [], "entities": []}, {"text": "The new nodes that are added to the tree as a result are recursively subjected to the same operation.", "labels": [], "entities": []}, {"text": "This process ends in a complete derived tree once all nodes have been treated.", "labels": [], "entities": []}, {"text": "An example of the derivation of a string is given in.", "labels": [], "entities": []}, {"text": "We start with initial tree al and treat Ral, for which we find Adj(Ral) = {b2, nil}.", "labels": [], "entities": []}, {"text": "We opt to select nil, so that no new nodes are added.", "labels": [], "entities": []}, {"text": "However in the figure we do split Ral in order to mark it as having been treated.", "labels": [], "entities": []}, {"text": "Next we treat Nail, and we opt to adjoin bl, taken from Adj(N~I ) = {bl, b3}.", "labels": [], "entities": []}, {"text": "After another \"nil-adjunction\" at Rbl, we adjoin b2 at N~I.", "labels": [], "entities": []}, {"text": "Note that this is an obligatory adjunction, since Adj(N~I ) does not contain nil.", "labels": [], "entities": []}, {"text": "Some more nil-adjunctions lead to a derived tree with yield acdb, which is therefore in the language described by the TAG.", "labels": [], "entities": [{"text": "TAG", "start_pos": 118, "end_pos": 121, "type": "DATASET", "confidence": 0.8010121583938599}]}, {"text": "Initial trees Adj   In order to avoid cluttering the picture with details, we have omitted the names of nodes at which (nil-)adjunction has been applied.", "labels": [], "entities": []}, {"text": "We will reintroduce these names later.", "labels": [], "entities": []}, {"text": "A further point worth mentioning is that here we treat the nodes in preorder: we traverse the tree top-down and left-to-right, and perform adjunction at each node the first time it is encountered.", "labels": [], "entities": []}, {"text": "2 Any other strategy would lead to the same set of derived trees, but we chose preorder treatment since this matches the algorithm we present below.", "labels": [], "entities": [{"text": "preorder", "start_pos": 79, "end_pos": 87, "type": "METRIC", "confidence": 0.9799030423164368}]}], "datasetContent": [], "tableCaptions": []}