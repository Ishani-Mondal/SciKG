{"title": [], "abstractContent": [{"text": "Natural-Language Generation from flat semantics is an NP-complete problem.", "labels": [], "entities": [{"text": "Natural-Language Generation from flat semantics", "start_pos": 0, "end_pos": 47, "type": "TASK", "confidence": 0.7549523711204529}]}, {"text": "This makes it necessary to develop algorithms that run with reasonable efficiency in practice despite the high worst-case complexity.", "labels": [], "entities": []}, {"text": "We show how to convert TAG generation problems into dependency parsing problems, which is useful because optimizations in recent dependency parsers based on constraint programming tackle exactly the combina-torics that make generation hard.", "labels": [], "entities": [{"text": "TAG generation", "start_pos": 23, "end_pos": 37, "type": "TASK", "confidence": 0.9576821029186249}, {"text": "dependency parsing", "start_pos": 52, "end_pos": 70, "type": "TASK", "confidence": 0.790788859128952}, {"text": "dependency parsers", "start_pos": 129, "end_pos": 147, "type": "TASK", "confidence": 0.7379049062728882}]}, {"text": "Indeed, initial experiments display promising run-times.", "labels": [], "entities": []}], "introductionContent": [{"text": "Existing algorithms for realization from a flat input semantics all have runtimes which are exponential in the worst case.", "labels": [], "entities": []}, {"text": "Several different approaches to improving the runtime in practice have been suggested in the literature -e.g. heuristics and factorizations into smaller exponential subproblems).", "labels": [], "entities": []}, {"text": "While these solutions achieve some measure of success in making realization efficient, the contrast in efficiency to parsing is striking both in theory and in practice.", "labels": [], "entities": [{"text": "parsing", "start_pos": 117, "end_pos": 124, "type": "TASK", "confidence": 0.9703975915908813}]}, {"text": "The problematic runtimes of generation algorithms are explained by the fact that realization is an NP-complete problem even using just context-free grammars, as showed in the context of shake-and-bake generation.", "labels": [], "entities": [{"text": "shake-and-bake generation", "start_pos": 186, "end_pos": 211, "type": "TASK", "confidence": 0.7860590517520905}]}, {"text": "The first contribution of our paper is a proof of a stronger NP-completeness result: If we allow semantic indices in the grammar, realization is NP-complete even if we fix a single grammar.", "labels": [], "entities": []}, {"text": "Our alternative proof shows clearly that the combinatorics in generation come from essentially the same sources as in parsing for free word order languages.", "labels": [], "entities": []}, {"text": "It has been noted in the literature that this problem, too, becomes NP-complete very easily (.", "labels": [], "entities": []}, {"text": "The main point of this paper is to show how to encode generation with a variant of tree-adjoining grammars (TAG) as a parsing problem with dependency grammars (DG).", "labels": [], "entities": []}, {"text": "The particular variant of DG we use, Topological Dependency Grammar (TDG)), was developed specifically with efficient parsing for free word order languages in mind.", "labels": [], "entities": []}, {"text": "The mere existence of this encoding proves TDG's parsing problem NP-complete as well, a result which has been conjectured but never formally shown so far.", "labels": [], "entities": [{"text": "TDG", "start_pos": 43, "end_pos": 46, "type": "DATASET", "confidence": 0.913019061088562}]}, {"text": "But it turns out that the complexities that arise in generation problems in practice seem to be precisely of the sort that the TDG parser can handle well.", "labels": [], "entities": []}, {"text": "Initial experiments with generating from the XTAG grammar) suggest that our generation system is competitive with state-of-theart chart generators, and indeed seems to run in polynomial time in practice.", "labels": [], "entities": [{"text": "XTAG grammar", "start_pos": 45, "end_pos": 57, "type": "DATASET", "confidence": 0.8438715040683746}]}, {"text": "Next to the attractive runtime behaviour, our approach to realization is interesting because it may provide us with a different angle from which to look for tractable fragments of the general realization problem.", "labels": [], "entities": []}, {"text": "As we will show, the computation that takes place in our system is very different from that in a chart generator, and maybe more efficient in some cases by taking into account global information to guide local choices.", "labels": [], "entities": []}, {"text": "We will define the problem we want to tackle in Section 2, and then show that it is NP-complete (Section 3).", "labels": [], "entities": []}, {"text": "In Section 4, we sketch the dependency grammar formalism we use.", "labels": [], "entities": []}, {"text": "Section 5 is the heart of the paper: We show how to encode TAG generation as TDG parsing, and discuss some examples and runtimes.", "labels": [], "entities": [{"text": "TAG generation", "start_pos": 59, "end_pos": 73, "type": "TASK", "confidence": 0.9340516626834869}, {"text": "TDG parsing", "start_pos": 77, "end_pos": 88, "type": "TASK", "confidence": 0.6724288761615753}]}, {"text": "We compare our approach to some others in Section 6, and conclude and discuss future research in Section 7.", "labels": [], "entities": []}], "datasetContent": [{"text": "The overall realization algorithm we propose encodes the input problem as a DG parsing problem and then runs the parser described in Section 4.2, which is freely available over the Web, as a black box.", "labels": [], "entities": [{"text": "DG parsing", "start_pos": 76, "end_pos": 86, "type": "TASK", "confidence": 0.522096112370491}]}, {"text": "Because the information lifted to the nodes by the selection constraints maybe strong enough to compute the parse tree without ever committing to unique lexical entries, the complete parse may still contain some lexical ambiguity.", "labels": [], "entities": []}, {"text": "This is no problem, however, because the absence of features guarantees that every combination of choices will be grammatical.", "labels": [], "entities": []}, {"text": "Similarly, anode can have multiple children over adjunction edges with the same label, and there maybe more than one node in the upper elementary tree to which the lower tree could be adjoined.", "labels": [], "entities": []}, {"text": "Again, all remaining combinations are guaranteed to be grammatical.", "labels": [], "entities": []}, {"text": "In order to get an idea of the performance of our realization algorithm in comparison to the state of the art, we have tried generating the following sentences, which are examples from): (1) The manager in that office interviewed anew consultant from Germany.", "labels": [], "entities": []}, {"text": "(2) Our manager organized an unusual additional weekly departmental conference.", "labels": [], "entities": [{"text": "departmental conference", "start_pos": 55, "end_pos": 78, "type": "TASK", "confidence": 0.8798980712890625}]}, {"text": "We have converted the XTAG grammar (XTAG Research) into our grammar format, automatically adding indices to the nodes of the elementary trees, removing features, simplifying adjunction constraints, and adding artificial lexical semantics that consists of the words at the lexical anchors and the indices used in the respective trees.", "labels": [], "entities": [{"text": "XTAG grammar (XTAG Research)", "start_pos": 22, "end_pos": 50, "type": "DATASET", "confidence": 0.8669360677401224}]}, {"text": "XTAG typically assigns quite a few elementary trees to one lemma, and the same lexical semantics can often be verbalized by more than hundred elementary trees in the converted grammar.", "labels": [], "entities": []}, {"text": "It turns out that the dependency parser scales very nicely to this degree of lexical ambiguity: The sentence (1) is generated in 470 milliseconds (as opposed to Carroll et al.'s 1.8 seconds), whereas we generate (2) in about 170 milliseconds (as opposed to 4.3 seconds).", "labels": [], "entities": []}, {"text": "1 Although these numbers are by no means a serious evaluation of our system's performance, they do present a first proof of concept for our approach.", "labels": [], "entities": []}, {"text": "The most encouraging aspect of these results is that despite the increased lexical ambiguity, the parser gets by without ever making any wrong choices, which means that it runs in polynomial time, on all examples we have tried.", "labels": [], "entities": []}, {"text": "This is possible because on the one hand, the selection constraint automatically compresses the many different elementary trees that XTAG assigns to one lemma into very few classes.", "labels": [], "entities": []}, {"text": "On the other hand, the propagation that rules out impossible edges is so strong that the free input order does not make the configuration problem much harder in practice.", "labels": [], "entities": []}, {"text": "Finally, our treatment of modification allows us to multiply out the possible permutations in a postprocessing step, after the parser has done the hard work.", "labels": [], "entities": []}, {"text": "A particularly striking example is (2), where the parser gives us a single solution, which multiplies out to 312 = 13 \u00b7 4!", "labels": [], "entities": []}, {"text": "(The 13 basic realizations correspond to different syntactic frames for the main verb in the XTAG grammar, e.g. for topicalized or passive constructions.)", "labels": [], "entities": []}], "tableCaptions": []}