{"title": [{"text": "Two methods to incorporate local morphosyntactic features in Hindi de- pendency parsing", "labels": [], "entities": [{"text": "Hindi de- pendency parsing", "start_pos": 61, "end_pos": 87, "type": "TASK", "confidence": 0.5949627161026001}]}], "abstractContent": [{"text": "In this paper we explore two strategies to incorporate local morphosyntactic features in Hindi dependency parsing.", "labels": [], "entities": [{"text": "Hindi dependency parsing", "start_pos": 89, "end_pos": 113, "type": "TASK", "confidence": 0.664939155181249}]}, {"text": "These features are obtained using a shallow parser.", "labels": [], "entities": []}, {"text": "We first explore which information provided by the shallow parser is most beneficial and show that local morphosyntactic features in the form of chunk type, head/non-head information, chunk boundary information, distance to the end of the chunk and suffix concatenation are very crucial in Hindi dependency parsing.", "labels": [], "entities": [{"text": "Hindi dependency parsing", "start_pos": 290, "end_pos": 314, "type": "TASK", "confidence": 0.6685893634955088}]}, {"text": "We then investigate the best way to incorporate this information during dependency parsing.", "labels": [], "entities": [{"text": "dependency parsing", "start_pos": 72, "end_pos": 90, "type": "TASK", "confidence": 0.8598801791667938}]}, {"text": "Further, we compare the results of various experiments based on various criterions and do some error analysis.", "labels": [], "entities": [{"text": "error analysis", "start_pos": 95, "end_pos": 109, "type": "METRIC", "confidence": 0.9307332932949066}]}, {"text": "All the experiments were done with two data-driven parsers, MaltParser and MSTParser, on apart of multi-layered and multi-representational Hindi Treebank which is underdevelopment.", "labels": [], "entities": [{"text": "Hindi Treebank", "start_pos": 139, "end_pos": 153, "type": "DATASET", "confidence": 0.910051167011261}]}, {"text": "This paper is also the first attempt at complete sentence level parsing for Hindi.", "labels": [], "entities": [{"text": "complete sentence level parsing", "start_pos": 40, "end_pos": 71, "type": "TASK", "confidence": 0.593024879693985}]}], "introductionContent": [{"text": "The dependency parsing community has since a few years shown considerable interest in parsing morphologically rich languages with flexible word order.", "labels": [], "entities": [{"text": "dependency parsing", "start_pos": 4, "end_pos": 22, "type": "TASK", "confidence": 0.7855035662651062}, {"text": "parsing morphologically rich languages", "start_pos": 86, "end_pos": 124, "type": "TASK", "confidence": 0.8903554379940033}]}, {"text": "This is partly due to the increasing availability of dependency treebanks for such languages, but it is also motivated by the observation that the performance obtained for these languages have not been very high).", "labels": [], "entities": []}, {"text": "Attempts at handling various non-configurational aspects in these languages have pointed towards shortcomings in traditional parsing methodologies).", "labels": [], "entities": []}, {"text": "Among other things, it has been pointed out that the use of language specific features may play a crucial role in improving the overall parsing performance.", "labels": [], "entities": []}, {"text": "Different languages tend to encode syntactically relevant information in different ways, and it has been hypothesized that the integration of morphological and syntactic information could be a key to better accuracy.", "labels": [], "entities": [{"text": "accuracy", "start_pos": 207, "end_pos": 215, "type": "METRIC", "confidence": 0.9937484264373779}]}, {"text": "However, it has also been noted that incorporating these language specific features in parsing is not always straightforward and many intuitive features do not always work in expected ways.", "labels": [], "entities": []}, {"text": "In this paper we explore various strategies to incorporate local morphosyntactic features in Hindi dependency parsing.", "labels": [], "entities": [{"text": "Hindi dependency parsing", "start_pos": 93, "end_pos": 117, "type": "TASK", "confidence": 0.6678772469361623}]}, {"text": "These features are obtained using a shallow parser.", "labels": [], "entities": []}, {"text": "We conducted experiments with two data-driven parsers, MaltParser) and MSTParser ().", "labels": [], "entities": [{"text": "MSTParser", "start_pos": 71, "end_pos": 80, "type": "DATASET", "confidence": 0.8566610813140869}]}, {"text": "We first explore which information provided by the shallow parser is most beneficial and show that local morphosyntactic features in the form of chunk type, head/non-head information, chunk boundary information, distance to the end of the chunk and suffix concatenation are very crucial in Hindi dependency parsing.", "labels": [], "entities": [{"text": "Hindi dependency parsing", "start_pos": 290, "end_pos": 314, "type": "TASK", "confidence": 0.6685893634955088}]}, {"text": "We then investigate the best way to incorporate this information during dependency parsing.", "labels": [], "entities": [{"text": "dependency parsing", "start_pos": 72, "end_pos": 90, "type": "TASK", "confidence": 0.8598801791667938}]}, {"text": "All the experiments were done on apart of multi-layered and multirepresentational Hindi Treebank () . The shallow parser performs three tasks, (a) it gives the POS tags for each lexical item, (b) provides morphological features for each lexical item, and (c) performs chunking.", "labels": [], "entities": [{"text": "Hindi Treebank", "start_pos": 82, "end_pos": 96, "type": "DATASET", "confidence": 0.8466084003448486}]}, {"text": "A chunk is a minimal (non-recursive) phrase consisting of correlated, inseparable words/entities, such that the intrachunk dependencies are not distorted ().", "labels": [], "entities": []}, {"text": "Together, a group of lexical items with some POS tag and morphological features within a chunk can be utilized to automatically compute local morphosyntactic information.", "labels": [], "entities": []}, {"text": "For example, such information can represent the postposition/case-marking in the case of noun chunks, or it may represent the tense, aspect and modality (TAM) information in the case of verb chunks.", "labels": [], "entities": []}, {"text": "In the experiments conducted for this paper such local information is automatically computed and incorporated as a feature to the head of a chunk.", "labels": [], "entities": []}, {"text": "In general, local morphosyntactic features correspond to all the parsing relevant local linguistic features that can be utilized using the notion of chunk.", "labels": [], "entities": []}, {"text": "Previously, there have been some attempts at using chunk information in dependency parsing.", "labels": [], "entities": [{"text": "dependency parsing", "start_pos": 72, "end_pos": 90, "type": "TASK", "confidence": 0.8179763853549957}]}, {"text": "used chunking information in parsing English.", "labels": [], "entities": []}, {"text": "They got an increase of 0.35% in labeled attachment accuracy and 0.47% in unlabeled attachment accuracy over the state-of-the-art dependency parser.", "labels": [], "entities": [{"text": "accuracy", "start_pos": 52, "end_pos": 60, "type": "METRIC", "confidence": 0.8076645135879517}, {"text": "accuracy", "start_pos": 95, "end_pos": 103, "type": "METRIC", "confidence": 0.8567166328430176}]}, {"text": "Among the three components (a-c, above), the parsing accuracy obtained using the POS feature is taken as baseline.", "labels": [], "entities": [{"text": "parsing", "start_pos": 45, "end_pos": 52, "type": "TASK", "confidence": 0.948884129524231}, {"text": "accuracy", "start_pos": 53, "end_pos": 61, "type": "METRIC", "confidence": 0.840142548084259}]}, {"text": "We follow this by experiments where we explore how each of morph and chunk features help in improving dependency parsing accuracy.", "labels": [], "entities": [{"text": "dependency parsing", "start_pos": 102, "end_pos": 120, "type": "TASK", "confidence": 0.8101427853107452}, {"text": "accuracy", "start_pos": 121, "end_pos": 129, "type": "METRIC", "confidence": 0.8514713644981384}]}, {"text": "In particular, we find that local morphosyntactic features are the most crucial.", "labels": [], "entities": []}, {"text": "These experiments are discussed in section 2.", "labels": [], "entities": []}, {"text": "In section 3 we will then see an alternative way to incorporate the best features obtained in section 2.", "labels": [], "entities": []}, {"text": "In all the parsing experiments discussed in section 2 and 3, at each step we explore all possible features and extract the best set of features.", "labels": [], "entities": []}, {"text": "Best features of one experiment are used when we go to the next set of experiments.", "labels": [], "entities": []}, {"text": "For example, when we explore the effect of chunk information, all the relevant morph information from previous set of experiments is taken into account.", "labels": [], "entities": []}, {"text": "This paper is also the first attempt at complete sentence level parsing for Hindi.", "labels": [], "entities": [{"text": "complete sentence level parsing", "start_pos": 40, "end_pos": 71, "type": "TASK", "confidence": 0.593024879693985}]}, {"text": "Due to the availability of dependency treebank for Hindi, there have been some previous attempts at Hindi data-driven dependency parsing (.", "labels": [], "entities": [{"text": "Hindi data-driven dependency parsing", "start_pos": 100, "end_pos": 136, "type": "TASK", "confidence": 0.5616814196109772}]}, {"text": "Recently in ICON-09 NLP Tools Contest; and the references therein), rulebased, constraint based, statistical and hybrid approaches were explored for dependency parsing.", "labels": [], "entities": [{"text": "ICON-09 NLP Tools Contest", "start_pos": 12, "end_pos": 37, "type": "DATASET", "confidence": 0.8292055726051331}, {"text": "dependency parsing", "start_pos": 149, "end_pos": 167, "type": "TASK", "confidence": 0.8739692568778992}]}, {"text": "Previously, constraint based approaches to Indian language (IL) dependency parsing have also been explored ().", "labels": [], "entities": [{"text": "Indian language (IL) dependency parsing", "start_pos": 43, "end_pos": 82, "type": "TASK", "confidence": 0.6602402882916587}]}, {"text": "All these attempts, however, were finding inter-chunk dependency relations, given goldstandard POS and chunk tags.", "labels": [], "entities": []}, {"text": "Unlike these previous parsers, the dependencies in this work are between lexical items, i.e. the dependency tree is complete.", "labels": [], "entities": []}, {"text": "The paper is arranged as follows, in section 2 and 3, we discuss the parsing experiments.", "labels": [], "entities": [{"text": "parsing", "start_pos": 69, "end_pos": 76, "type": "TASK", "confidence": 0.9754574298858643}]}, {"text": "In section 4, we describe the data and parser settings.", "labels": [], "entities": []}, {"text": "Section 5 gives the results and discusses some related issues.", "labels": [], "entities": []}, {"text": "General discussion and possible future work is mentioned in section 6.", "labels": [], "entities": []}, {"text": "We conclude the paper in section 7.", "labels": [], "entities": []}], "datasetContent": [{"text": "In this section we describe the data and the parser settings used for our experiments.", "labels": [], "entities": []}], "tableCaptions": [{"text": " Table 1: Results of all the four approaches using gold-standard shallow parser information.", "labels": [], "entities": []}, {"text": " Table 2: Results of all the four experiments using automatic shallow parser information.", "labels": [], "entities": []}]}