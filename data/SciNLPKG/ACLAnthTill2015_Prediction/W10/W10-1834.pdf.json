{"title": [], "abstractContent": [{"text": "In this paper, we argue for and demonstrate the use of Prolog as a tool to query annotated corpora.", "labels": [], "entities": [{"text": "Prolog", "start_pos": 55, "end_pos": 61, "type": "DATASET", "confidence": 0.9140585660934448}]}, {"text": "We present a case study based on the German T\u00fcBa-D/Z Treebank to show that flexible and efficient corpus querying can be started with a minimal amount of effort.", "labels": [], "entities": [{"text": "German T\u00fcBa-D/Z Treebank", "start_pos": 37, "end_pos": 61, "type": "DATASET", "confidence": 0.8007051348686218}, {"text": "corpus querying", "start_pos": 98, "end_pos": 113, "type": "TASK", "confidence": 0.6122121214866638}]}, {"text": "We end this paper with a brief discussion of performance, that suggests that the approach is both fast enough and scalable.", "labels": [], "entities": []}], "introductionContent": [{"text": "Corpus investigations that go beyond formulating queries and studying (graphical renderings of) the retrieved annotation very quickly begin to require a general purpose programming language to do things like manipulating and transforming annotation, categorizing results, performing non-trivial counting and even statistical analysis, as query tools only offer a fixed, restricted set of operations.", "labels": [], "entities": [{"text": "statistical analysis", "start_pos": 313, "end_pos": 333, "type": "TASK", "confidence": 0.8029467761516571}]}, {"text": "The use of a general purpose programming language has drawbacks, too, however: one has to deal with interfacing with a database, non-deterministic search, definition of linguistically relevant relations and properties in terms of the lower level database relations, etcetera.", "labels": [], "entities": []}, {"text": "As a solution for this dilemma of trading flexibility and power against the ease with which one can query corpora, we propose to use Prolog.", "labels": [], "entities": [{"text": "Prolog", "start_pos": 133, "end_pos": 139, "type": "DATASET", "confidence": 0.9709244966506958}]}, {"text": "Prolog is well suited to query databases.", "labels": [], "entities": [{"text": "Prolog", "start_pos": 0, "end_pos": 6, "type": "DATASET", "confidence": 0.914593517780304}]}, {"text": "Unlike in other general purpose languages, the programmer is relieved of the burden of writing functions to nondeterministically search through the corpus or database.", "labels": [], "entities": []}, {"text": "In comparison to dedicated query languages and their processors, the fact that one can always extend the Prolog predicates that constitute the query language lifts many restrictions on the kinds of queries one can pose.", "labels": [], "entities": []}, {"text": "A more specific point is that we can have fine grained control over the scope of negation and quantification in queries in Prolog, something that is sometimes lacking from dedicated languages (for discussion, see; fora prominent example,; for an exception, Kepser (2003)) formulated a number of queries to compare query languages for syntactically annotated corpora.", "labels": [], "entities": [{"text": "negation and quantification", "start_pos": 81, "end_pos": 108, "type": "TASK", "confidence": 0.7782721122105917}]}, {"text": "In this paper, we demonstrate the ease with which a flexible and fast query environment can be constructed by implementing these queries and using them as a rudimentary benchmark for performance.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": [{"text": " Table 3: Rounded up wall-clock times in seconds.", "labels": [], "entities": []}]}