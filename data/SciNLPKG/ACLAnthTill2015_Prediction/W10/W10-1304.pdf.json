{"title": [{"text": "Scanning methods and language modeling for binary switch typing", "labels": [], "entities": []}], "abstractContent": [{"text": "We present preliminary experiments of a binary-switch, static-grid typing interface making use of varying language model contributions.", "labels": [], "entities": []}, {"text": "Our motivation is to quantify the degree to which language models can make the simplest scanning interfaces-such as showing one symbol at a time rather than a scanning a grid-competitive in terms of typing speed.", "labels": [], "entities": []}, {"text": "We present a grid scanning method making use of optimal Huffman binary codes, and demonstrate the impact of higher order language models on its performance.", "labels": [], "entities": []}, {"text": "We also investigate the scanning methods of highlighting just one cell in a grid at any given time or showing one symbol at a time without a grid, and show that they yield commensurate performance when using higher order n-gram models, mainly due to lower error rate and a lower rate of missed targets.", "labels": [], "entities": [{"text": "error rate", "start_pos": 256, "end_pos": 266, "type": "METRIC", "confidence": 0.9637041091918945}]}], "introductionContent": [{"text": "Augmentative and Alternative Communication (AAC) is a well-defined subfield of assistive technology, focused on methods that assist individuals for whom conventional spoken or written communication approaches are difficult or impossible.", "labels": [], "entities": [{"text": "Augmentative and Alternative Communication (AAC)", "start_pos": 0, "end_pos": 48, "type": "TASK", "confidence": 0.7485439734799522}]}, {"text": "Those who cannot make use of standard keyboards for text entry have a number of alternative text entry methods that permit typing.", "labels": [], "entities": [{"text": "text entry", "start_pos": 52, "end_pos": 62, "type": "TASK", "confidence": 0.7683311402797699}]}, {"text": "One of the most common of these alternative text entry methods is the use of a binary switch -triggered by button-press, eye-blink or even through event related potentials (ERP) such as the P300 detected in EEG signals -that allows the individual to make a selection based on some method for scanning through alternatives (.", "labels": [], "entities": [{"text": "text entry", "start_pos": 44, "end_pos": 54, "type": "TASK", "confidence": 0.7274282872676849}]}, {"text": "Typing speed is a challenge, yet critically important for usability.", "labels": [], "entities": [{"text": "Typing", "start_pos": 0, "end_pos": 6, "type": "TASK", "confidence": 0.8419513702392578}, {"text": "speed", "start_pos": 7, "end_pos": 12, "type": "METRIC", "confidence": 0.7026242613792419}]}, {"text": "One common approach is row/column scanning on a matrix of characters, symbols or images (a 'spelling grid'), which allows the user of a binary yes/no switch to select the row and column of a target symbol, by simply indicating 'yes' (pressing a button or blinking an eye) when the row or column of the target symbol is highlighted.", "labels": [], "entities": []}, {"text": "shows the 6\u00d76 spelling grid used for the P300.", "labels": [], "entities": [{"text": "P300", "start_pos": 41, "end_pos": 45, "type": "DATASET", "confidence": 0.9722965359687805}]}, {"text": "For any given scanning method, the use of a binary switch to select from among a set of options (letter, symbols, or images) amounts to the assignment of binary codes to each symbol.", "labels": [], "entities": []}, {"text": "For example, the standard row/column scanning algorithm works by scanning each row until a selection is made, then scanning each column until a selection is made, and returning the symbol at the selected row and column.", "labels": [], "entities": [{"text": "row/column scanning", "start_pos": 26, "end_pos": 45, "type": "TASK", "confidence": 0.7215236276388168}]}, {"text": "This can be formalized as follows: where the function YESSWITCH returns true if the button is pressed (or whatever switch event counts as a 'yes' response) within the parameterized latency.", "labels": [], "entities": [{"text": "YESSWITCH", "start_pos": 54, "end_pos": 63, "type": "METRIC", "confidence": 0.995108425617218}]}, {"text": "If the function returns (0, 0) then nothing has been selected, requiring rescanning.", "labels": [], "entities": []}, {"text": "If the function returns (i, 0) for i > 0, then row i has been selected, but columns must be rescanned.", "labels": [], "entities": []}, {"text": "Under this scanning method, the binary code for the letter 'J' in the matrix in is 010001; the letter 'T' is 000101.", "labels": [], "entities": []}, {"text": "The length of the binary code fora symbol is re-.", "labels": [], "entities": []}, {"text": "lated to the time required to type it.", "labels": [], "entities": [{"text": "lated", "start_pos": 0, "end_pos": 5, "type": "METRIC", "confidence": 0.9746425151824951}]}, {"text": "In the matrix in, the space character is in the bottom right-hand corner, yielding the maximum binary code length for that grid size (12), despite that, in typical written English we would expect the space character to be used about 20% of the time.", "labels": [], "entities": []}, {"text": "A more efficient strategy would be to place the space character in the upper left-hand corner of the grid, leading to the much shorter binary code '11'.", "labels": [], "entities": []}, {"text": "Ordering symbols in a fixed grid so that frequent symbols are located in the upper left-hand corner is one method for making use of a statistical model of the language so that likely symbols receive the shortest codes.", "labels": [], "entities": []}, {"text": "Such a language model, however, does not take into account what has already been typed, but rather assigns its code identically in all contexts.", "labels": [], "entities": []}, {"text": "In this paper we examine alternative fixed-grid scanning methods that do take into account context in the language models used to establish codes, i.e., the codes in these methods vary in different contexts, so that high probability symbols receive the shortest codes and hence require the fewest keystrokes.", "labels": [], "entities": []}, {"text": "We show that n-gram language models can provide a large improvement in typing speed.", "labels": [], "entities": []}, {"text": "Before presenting our methods and experimental results, we next provide further background on alternative text entry methods, language modeling, and binary coding based on language models.", "labels": [], "entities": [{"text": "text entry", "start_pos": 106, "end_pos": 116, "type": "TASK", "confidence": 0.7002080082893372}, {"text": "language modeling", "start_pos": 126, "end_pos": 143, "type": "TASK", "confidence": 0.7318184077739716}]}], "datasetContent": [], "tableCaptions": [{"text": " Table 1: Typing results for 10 users on 5 test strings (total 31 words, 145 characters) under six conditions.", "labels": [], "entities": [{"text": "Typing", "start_pos": 10, "end_pos": 16, "type": "TASK", "confidence": 0.940559983253479}]}, {"text": " Table 2: Mean Likert scores to survey questions  (5 = strongly agree; 1 = strongly disagree)", "labels": [], "entities": [{"text": "Mean", "start_pos": 10, "end_pos": 14, "type": "METRIC", "confidence": 0.9635999798774719}]}]}