{"title": [{"text": "Referring Expressions as Formulas of Description Logic", "labels": [], "entities": [{"text": "Referring Expressions", "start_pos": 0, "end_pos": 21, "type": "TASK", "confidence": 0.9104544818401337}]}], "abstractContent": [{"text": "In this paper, we propose to reinterpret the problem of generating referring expressions (GRE) as the problem of computing a formula in a description logic that is only satisfied by the referent.", "labels": [], "entities": [{"text": "generating referring expressions (GRE)", "start_pos": 56, "end_pos": 94, "type": "TASK", "confidence": 0.6498281955718994}]}, {"text": "This view offers anew unifying perspective under which existing GRE algorithms can be compared.", "labels": [], "entities": []}, {"text": "We also show that by applying existing algorithms for computing simulation classes in description logic, we can obtain extremely efficient algorithms for rela-tional referring expressions without any danger of running into infinite regress.", "labels": [], "entities": []}], "introductionContent": [{"text": "The generation of referring expressions (GRE) is one of the most active and successful research areas in natural language generation.", "labels": [], "entities": [{"text": "generation of referring expressions (GRE)", "start_pos": 4, "end_pos": 45, "type": "TASK", "confidence": 0.8413333637373788}, {"text": "natural language generation", "start_pos": 105, "end_pos": 132, "type": "TASK", "confidence": 0.6561895410219828}]}, {"text": "Building upon Dale and Reiter's work, various researchers have added extensions such as reference to sets), more expressive logical connectives), and relational expressions.", "labels": [], "entities": []}, {"text": "Referring expressions (REs) involving relations, in particular, have received increasing attention recently; especially in the context of spatial referring expressions in situated generation (e.g.)), where it seems particularly natural to use expressions such as \"the book on the table\".", "labels": [], "entities": [{"text": "Referring expressions (REs)", "start_pos": 0, "end_pos": 27, "type": "TASK", "confidence": 0.8516541004180909}]}, {"text": "However, the classical algorithm by was recently shown to be unable to generate satisfying REs in practice).", "labels": [], "entities": []}, {"text": "Furthermore, the Dale and Haddock algorithm and most of its successors (such as)) are vulnerable to the problem of \"infinite regress\", where the algorithm jumps back and forth between generating descriptions for two related individuals infinitely, as in \"the book on the table which supports a book on the table . .", "labels": [], "entities": []}, {"text": "\". In this paper, we propose to view GRE as the problem of computing a formula of description logic (DL) that denotes exactly the set of individuals that we want to refer to.", "labels": [], "entities": [{"text": "GRE", "start_pos": 37, "end_pos": 40, "type": "TASK", "confidence": 0.9603759050369263}]}, {"text": "This very natural idea has been mentioned in passing before (; however, we take it one step further by proposing DL as an interlingua for comparing the REs produced by different approaches to GRE.", "labels": [], "entities": [{"text": "GRE", "start_pos": 192, "end_pos": 195, "type": "TASK", "confidence": 0.5993267893791199}]}, {"text": "In this way, we can organize existing GRE approaches in an expressiveness hierarchy.", "labels": [], "entities": []}, {"text": "For instance, the classical Dale and Reiter algorithms compute purely conjunctive formulas; van extends this language by adding the other propositional connectives, whereas extends it by allowing existential quantification.", "labels": [], "entities": []}, {"text": "Furthermore, the view of GRE as a problem of computing DL formulas with a given extension allows us to apply existing algorithms for the latter problem to obtain efficient algorithms for GRE.", "labels": [], "entities": [{"text": "GRE", "start_pos": 25, "end_pos": 28, "type": "TASK", "confidence": 0.920944094657898}]}, {"text": "We present algorithms that compute such formulas for the description logics EL (which allows only conjunction and existential quantification) and ALC (which also allows negation).", "labels": [], "entities": []}, {"text": "These algorithms effectively compute REs for all individuals in the domain at the same time, which allows them to systematically avoid the infinite regress problem.", "labels": [], "entities": []}, {"text": "The EL algorithm is capable of generating 67% of the relational REs in the dataset, in about 15 milliseconds.", "labels": [], "entities": []}, {"text": "The ALC algorithm is even faster; it computes relational REs for all 100 individuals in a random model in 140 milliseconds.", "labels": [], "entities": []}, {"text": "The paper is structured as follows.", "labels": [], "entities": []}, {"text": "In Section 2, we will first define description logics.", "labels": [], "entities": []}, {"text": "We will then show how to generate REs by computing DL similarity sets for ALC and EL in Section 3.", "labels": [], "entities": []}, {"text": "In Section 4, we evaluate our algorithms and discuss our results.", "labels": [], "entities": []}, {"text": "Section 5 compares our approach to related research; in particular, it shows how various prominent GRE algorithms fit into the DL framework.", "labels": [], "entities": []}, {"text": "Section 6 concludes and points to future work.", "labels": [], "entities": []}], "datasetContent": [{"text": "To compare the descriptions generated by our algorithm to those humans produce, we use a corpus of human-generated referring expressions collected and made available by Jette Viethen and Robert Dale.", "labels": [], "entities": []}, {"text": "1 They asked human subjects to describe one of 16 filing cabinet drawers.", "labels": [], "entities": []}, {"text": "The drawers had different colors and were arranged in a four-by-four grid (see).", "labels": [], "entities": []}, {"text": "The human subjects used four non-relational properties (the drawer's color, its column and row number, and whether it is in a corner) and five relational properties (above, below, next to, left of, right of).", "labels": [], "entities": []}, {"text": "Of the 118 referring expressions obtained in the experiment, only 15 use relations.", "labels": [], "entities": []}, {"text": "Viethen and Dale (2006) describe the data in more detail and present results of evaluating the Full Brevity algorithm, the Incremental Algorithm (both by), and the Relational Algorithm ( on this corpus.", "labels": [], "entities": []}, {"text": "The Incremental Algorithm is dependent on a predefined ordering in which properties are added to the description.", "labels": [], "entities": []}, {"text": "Viethen and Dale, therefore, try all possible orderings and evaluate what percentage of descriptions an algorithm can generate with any of them.", "labels": [], "entities": []}, {"text": "The Full Brevity and the Relational Algorithms choose properties based on their discriminatory power and only use the orderings as tie breakers.", "labels": [], "entities": []}, {"text": "Viethen and Dale found that the Incremental Algorithm is capable of generating 98 of the 103 non-relational descriptions.", "labels": [], "entities": []}, {"text": "However, the Relational Algorithm was unable to generate even a single one of the human-generated relational descriptions.", "labels": [], "entities": []}, {"text": "We replicated Viethen and Dale's experiment for 1 http://www.ics.mq.edu.au/\u02dcjviethen/drawers the EL algorithm presented above.", "labels": [], "entities": []}, {"text": "In the nonrelational case, our results are the same as theirs for the Incremental Algorithm: the EL algorithm generates 98 of the 103 non-relational descriptions, using four (of the possible) orderings.", "labels": [], "entities": []}, {"text": "This is because the two algorithms perform essentially the same computations if there are no relations.", "labels": [], "entities": []}, {"text": "When we add relations, our algorithm is able to generate 10 of the 15 human-produced relational descriptions correctly (in addition to the 98 nonrelational descriptions).", "labels": [], "entities": []}, {"text": "gives example outputs of the EL algorithm for three different orderings, which together achieve this coverage.", "labels": [], "entities": []}, {"text": "Of the five human-produced descriptions that the EL algorithm cannot generate, three involve references to sets (the two blues ones in horizontal sequence/the two yellow drawers), and two contain so much redundant information that our algorithm cannot reproduce them: Similarly to the Incremental Algorithm, our algorithm allows for some redundancy, but stops once it has found a distinguishing description.", "labels": [], "entities": []}, {"text": "It does, however, generate other, simpler descriptions for these referents.", "labels": [], "entities": []}, {"text": "Both the EL and the ALC algorithms took about 15 milliseconds to compute distinguishing formulas for all 16 individuals in the Viethen and Dale dataset.", "labels": [], "entities": [{"text": "EL", "start_pos": 9, "end_pos": 11, "type": "METRIC", "confidence": 0.6762434840202332}, {"text": "Dale dataset", "start_pos": 139, "end_pos": 151, "type": "DATASET", "confidence": 0.7985039949417114}]}, {"text": "In order to get a more comprehensive picture of the algorithms' efficiency, we ran them on random models with increasing numbers of individuals.", "labels": [], "entities": []}, {"text": "Each model had random interpretations for ten different propositional and four relational symbols; each individual had a 10% chance to be in the extension of each propositional symbol, and each pair of individuals had a 10% chance to be related by a relational symbol.", "labels": [], "entities": []}, {"text": "The results (averaged over 10 runs for each model size) are shown in.", "labels": [], "entities": []}, {"text": "The EL algorithm takes about 350 ms on average to generate relational REs for all individuals in the model of size 100, i.e., less than 4 ms on average for each individual.", "labels": [], "entities": []}, {"text": "The ALC algorithm is even faster, at about 140 ms for the model of size 100.", "labels": [], "entities": []}, {"text": "As far as we know, these are by far the fastest published runtimes for, annotated with the drawer id and the outputs of the EL algorithm using three different orderings.", "labels": [], "entities": []}, {"text": "Notice that four descriptions occurred twice in the corpus.", "labels": [], "entities": []}, {"text": "Descriptions that the EL algorithm cannot generate with any ordering are marked by * . Generated descriptions that match one produced by humans are in boldface.", "labels": [], "entities": []}, {"text": "any relational GRE algorithm in the literature.", "labels": [], "entities": []}], "tableCaptions": []}