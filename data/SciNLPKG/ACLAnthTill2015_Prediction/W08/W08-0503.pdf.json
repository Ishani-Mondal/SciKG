{"title": [{"text": "zymake: a computational workflow system for machine learning and natural language processing", "labels": [], "entities": []}], "abstractContent": [{"text": "Experiments in natural language processing and machine learning typically involve running a complicated network of programs to create, process, and evaluate data.", "labels": [], "entities": []}, {"text": "Researchers often write one or more UNIX shell scripts to \"glue\" together these various pieces, but such scripts are suboptimal for several reasons.", "labels": [], "entities": []}, {"text": "Without significant additional work, a script does not handle recovering from failures , it requires keeping track of complicated filenames, and it does not support running processes in parallel.", "labels": [], "entities": []}, {"text": "In this paper, we present zymake as a solution to all these problems.", "labels": [], "entities": []}, {"text": "zymake scripts look like shell scripts, but have semantics similar to makefiles.", "labels": [], "entities": []}, {"text": "Using zymake improves repeatability and scalabil-ity of running experiments, and provides a clean, simple interface for assembling components.", "labels": [], "entities": []}, {"text": "A zymake script also serves as documentation for the complete workflow.", "labels": [], "entities": []}, {"text": "We present a zymake script fora published set of NLP experiments, and demonstrate that it is superior to alternative solutions, including shell scripts and makefiles, while being far simpler to use than scientific grid computing systems.", "labels": [], "entities": []}], "introductionContent": [{"text": "Running experiments in natural language processing and machine learning typically involves a complicated network of programs.", "labels": [], "entities": []}, {"text": "One program might extract data from a raw corpus, others might preprocess it with various linguistic tools, before finally the main program being tested is run.", "labels": [], "entities": []}, {"text": "Further programs must evaluate the output, and produce graphs and tables for inclusion in papers and presentations.", "labels": [], "entities": []}, {"text": "All of these steps can be run by hand, but a more typical approach is to automate them using tools such as UNIX shell scripts.", "labels": [], "entities": []}, {"text": "We argue that any approach should satisfy a number of basic criteria.", "labels": [], "entities": []}, {"text": "Reproducibility At some future time, the original researcher or other researchers ought to be able to re-run the set of experiments and produce identical results . Such reproducibility is a cornerstone of scientific research, and ought in principle to be easier in our discipline than in afield requiring physical measurements such as physics or chemistry.", "labels": [], "entities": []}, {"text": "Simplicity We want to create a system that we and other researchers will find easy to use.", "labels": [], "entities": []}, {"text": "A system which requires significant overhead before any experiment can be run can limit a researcher's ability to quickly and easily tryout new ideas.", "labels": [], "entities": []}, {"text": "A realistic life-cycle of experiments A typical experiment evolves in structure as it goes along -the researcher may choose partway through to add new datasets, new ranges of parameters, or new sets of models to test.", "labels": [], "entities": []}, {"text": "Moreover, a computational experiment rarely works correctly the first time.", "labels": [], "entities": []}, {"text": "Components break for various reasons, a tool may not perform as expected, and so forth.", "labels": [], "entities": []}, {"text": "A usable tool must be simple to use in the face of such repeated re-execution.", "labels": [], "entities": []}, {"text": "Software engineering Whether writing shell scripts, makefiles, or Java, one is writing code, and software engineering concerns apply.", "labels": [], "entities": []}, {"text": "One key principle is modularity, that different parts of training regime classes two-way distinction A vs B+O two-way distinction B vs A+O three-way distinction A vs B vs O baseline comparison A+B vs O: Training regimes a program should be cleanly separated.", "labels": [], "entities": []}, {"text": "Another is generality, creating solutions that are re-usable in different specific cases.", "labels": [], "entities": []}, {"text": "A usable tool must encourage good software engineering.", "labels": [], "entities": []}, {"text": "Inherent support for the combinatorial nature of our experiments Experiments in natural language processing and machine learning typically compare different datasets, different models, different feature sets, different training regimes, and train and test on a number of cross-validation folds.", "labels": [], "entities": []}, {"text": "This produces a very large number of files which any system must handle in a clean way.", "labels": [], "entities": []}, {"text": "In this paper, we present zymake 2 , and argue that is superior to several alternatives for the task of automating the steps in running an experiment in natural language processing or machine learning.", "labels": [], "entities": []}], "datasetContent": [{"text": "As a running example, we present the following set of experiments (abstracted from).", "labels": [], "entities": []}, {"text": "The task is one of entity identificationwe have a large dataset in which two different types of opinion entities are tagged, type A, and type B.", "labels": [], "entities": [{"text": "entity identificationwe", "start_pos": 19, "end_pos": 42, "type": "TASK", "confidence": 0.7407123744487762}]}, {"text": "We will use a sequence-based learning algorithm to model the entities, but we want to investigate the relationship between the two types.", "labels": [], "entities": []}, {"text": "In particular, will it be preferable to learn a single model which predicts both entity type A and entity type B, or two separate models, one predicting A, and one predicting B.", "labels": [], "entities": []}, {"text": "The former case makes a three-way distinction between entities of type A, of type B, and of type O, all other words.", "labels": [], "entities": []}, {"text": "The latter two models make a distinction between type A and both other types or between type B and both other types.", "labels": [], "entities": []}, {"text": "Further-2 Any name consisting of a single letter followed by make already refers to an existing software project.", "labels": [], "entities": []}, {"text": "zymake is the first pronouncable name consisting of a two letter prefix to make, starting from the end of the alphabet.", "labels": [], "entities": []}, {"text": "I pronounce \"zy-\" as in \"zydeco.\" more, prior work to which we wish to compare does not distinguish at all between type A and type B, so we also need a model which just predicts entities to be of either type A or B, versus the background O.", "labels": [], "entities": []}, {"text": "These four training regimes are summarized in Table 1.", "labels": [], "entities": []}, {"text": "Given one of these training regimes, the model is trained and tested using 10-fold cross-validation, and the result is evaluated using precision and recall.", "labels": [], "entities": [{"text": "precision", "start_pos": 135, "end_pos": 144, "type": "METRIC", "confidence": 0.9995434880256653}, {"text": "recall", "start_pos": 149, "end_pos": 155, "type": "METRIC", "confidence": 0.9980481863021851}]}, {"text": "The evaluation is conducted separately for class A, for class B, and for predicting the union of both classes.", "labels": [], "entities": []}], "tableCaptions": []}