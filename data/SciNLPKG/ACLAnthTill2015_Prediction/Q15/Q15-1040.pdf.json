{"title": [], "abstractContent": [{"text": "We study the generalization of maximum spanning tree dependency parsing to maximum acyclic subgraphs.", "labels": [], "entities": [{"text": "maximum spanning tree dependency parsing", "start_pos": 31, "end_pos": 71, "type": "TASK", "confidence": 0.6047338008880615}]}, {"text": "Because the underlying optimization problem is intractable even under an arc-factored model, we consider the restriction to noncrossing dependency graphs.", "labels": [], "entities": []}, {"text": "Our main contribution is a cubic-time exact inference algorithm for this class.", "labels": [], "entities": []}, {"text": "We extend this algorithm into a practical parser and evaluate its performance on four linguistic data sets used in semantic dependency parsing.", "labels": [], "entities": [{"text": "semantic dependency parsing", "start_pos": 115, "end_pos": 142, "type": "TASK", "confidence": 0.6646425823370615}]}, {"text": "We also explore a generalization of our parsing framework to dependency graphs with pagenumber at most k and show that the resulting optimization problem is NP-hard fork 2.", "labels": [], "entities": []}], "introductionContent": [{"text": "Dependency parsers provide lightweight representations for the syntactic and the semantic structure of natural language.", "labels": [], "entities": [{"text": "Dependency parsers", "start_pos": 0, "end_pos": 18, "type": "TASK", "confidence": 0.7429210245609283}]}, {"text": "Syntactic dependency parsing () has been an extremely active research area for the last decade or so, resulting in accurate and efficient parsers fora wide range of languages.", "labels": [], "entities": [{"text": "Syntactic dependency parsing", "start_pos": 0, "end_pos": 28, "type": "TASK", "confidence": 0.9126183986663818}]}, {"text": "Semantic dependency parsing has only recently been addressed in the literature ().", "labels": [], "entities": [{"text": "Semantic dependency parsing", "start_pos": 0, "end_pos": 27, "type": "TASK", "confidence": 0.7869131167729696}]}, {"text": "Syntactic dependency parsing has been formalized as the search for maximum spanning trees in weighted digraphs).", "labels": [], "entities": [{"text": "Syntactic dependency parsing", "start_pos": 0, "end_pos": 28, "type": "TASK", "confidence": 0.7640630006790161}]}, {"text": "For semantic dependency parsing, where target representations are not necessarily tree-shaped, it is natural to generalize this view to maximum acyclic subgraphs, with or without the additional requirement of weak connectivity.", "labels": [], "entities": [{"text": "semantic dependency parsing", "start_pos": 4, "end_pos": 31, "type": "TASK", "confidence": 0.6881921490033468}]}, {"text": "While a maximum spanning tree of a weighted digraph can be found in polynomial time, computing a maximum acyclic subgraph is intractable, and even good approximate solutions are hard to find).", "labels": [], "entities": []}, {"text": "In this paper we therefore address maximum acyclic subgraph parsing under the restriction that the subgraph should be noncrossing, which informally means that its arcs can be drawn on the half-plane above the sentence in such away that no two arcs cross (and without changing the order of the words).", "labels": [], "entities": [{"text": "subgraph parsing", "start_pos": 51, "end_pos": 67, "type": "TASK", "confidence": 0.7548823058605194}]}, {"text": "The main contribution of this paper is an algorithm that finds a maximum noncrossing acyclic subgraph of a (vertex-ordered) weighted digraph on n vertices in time O.n 3 /.", "labels": [], "entities": []}, {"text": "After giving some background (Section 2) we introduce the noncrossing condition, compare it to other structural constraints from the literature, and study its empirical coverage (Section 3).", "labels": [], "entities": []}, {"text": "We then present our parsing algorithm (Section 4).", "labels": [], "entities": [{"text": "parsing", "start_pos": 20, "end_pos": 27, "type": "TASK", "confidence": 0.9687784314155579}]}, {"text": "To turn this algorithm into a practical parser, we combine it with an off-the-shelf feature model and online training (Section 5); the source code of our system is released with this paper.", "labels": [], "entities": []}, {"text": "We evaluate the performance of our parser on four linguistic data sets: those used in the recent SemEval task on semantic dependency parsing (, and the dependency graphs extracted from CCGbank.", "labels": [], "entities": [{"text": "SemEval task", "start_pos": 97, "end_pos": 109, "type": "TASK", "confidence": 0.8974849283695221}, {"text": "semantic dependency parsing", "start_pos": 113, "end_pos": 140, "type": "TASK", "confidence": 0.5928375919659933}, {"text": "CCGbank", "start_pos": 185, "end_pos": 192, "type": "DATASET", "confidence": 0.9550328850746155}]}, {"text": "Finally, we explore the limits of our approach by showing that finding the maximum acyclic subgraph under a natural generalization of the noncrossing condition, pagenumber at most k, is NPhard fork 2 (Section 6).", "labels": [], "entities": []}, {"text": "We conclude the paper by discussing related and future work (Section 7).", "labels": [], "entities": []}, {"text": "Figure 1: A noncrossing dependency graph.", "labels": [], "entities": []}, {"text": "Using the terminology of, the vertices the, thus, a and from are roots; of these, thus, a and from are covered by arcs.", "labels": [], "entities": []}], "datasetContent": [{"text": "We report parsing experiments on the four data sets described in Section 3.3.1 and discuss their results.", "labels": [], "entities": []}, {"text": "We use gold-standard lemmas and part-of-speech tags, train each parser for 10 epochs, and report results for the final model on the test data.", "labels": [], "entities": []}, {"text": "We use the splits recommended for the respective data sets.", "labels": [], "entities": []}, {"text": "Following, prior to training we transform each dependency graph in the training data to a closest noncrossing dependency graph.", "labels": [], "entities": []}, {"text": "Ina prestudy using the DM development data we found the best value for the tradeoff parameter C to be 0:01.", "labels": [], "entities": [{"text": "DM development data", "start_pos": 23, "end_pos": 42, "type": "DATASET", "confidence": 0.6587882240613302}]}], "tableCaptions": [{"text": " Table 1: Coverage in terms of complete graphs (G) and  individual arcs (A) under various structural restrictions.", "labels": [], "entities": [{"text": "Coverage", "start_pos": 10, "end_pos": 18, "type": "TASK", "confidence": 0.9638671278953552}]}, {"text": " Table 2: Parsing results on the SDP data (Oepen, 2014) and on CCG dependencies (Hockenmaier and Steedman,  2005). The metrics reported are precision, recall and F-score on labeled (LP, LR, LF) and unlabeled (UP, UR, UF)  dependencies. LF is the averaged LF score that was used to rank systems in the SemEval-2015 Task on Broad-Coverage  Semantic Dependency Parsing. References are to Du et al. (2015b) (Peking) and Auli and Lopez (2011).", "labels": [], "entities": [{"text": "SDP data", "start_pos": 33, "end_pos": 41, "type": "DATASET", "confidence": 0.8221251964569092}, {"text": "precision", "start_pos": 140, "end_pos": 149, "type": "METRIC", "confidence": 0.9995433688163757}, {"text": "recall", "start_pos": 151, "end_pos": 157, "type": "METRIC", "confidence": 0.9987258315086365}, {"text": "F-score", "start_pos": 162, "end_pos": 169, "type": "METRIC", "confidence": 0.9980289340019226}, {"text": "SemEval-2015 Task on Broad-Coverage  Semantic Dependency Parsing", "start_pos": 301, "end_pos": 365, "type": "TASK", "confidence": 0.7561675097261157}]}]}