{"title": [{"text": "Efficient and robust LFG parsing: SXLFG", "labels": [], "entities": [{"text": "LFG parsing", "start_pos": 21, "end_pos": 32, "type": "TASK", "confidence": 0.6076277494430542}, {"text": "SXLFG", "start_pos": 34, "end_pos": 39, "type": "TASK", "confidence": 0.4431808292865753}]}], "abstractContent": [{"text": "In this paper, we introduce anew parser, called SXLFG, based on the Lexical-Functional Grammars formalism (LFG).", "labels": [], "entities": []}, {"text": "We describe the underlying context-free parser and how functional structures are efficiently computed on top of the CFG shared forest thanks to computation sharing , lazy evaluation, and compact data representation.", "labels": [], "entities": [{"text": "CFG shared forest", "start_pos": 116, "end_pos": 133, "type": "DATASET", "confidence": 0.925362229347229}]}, {"text": "We then present various error recovery techniques we implemented in order to build a robust parser.", "labels": [], "entities": [{"text": "error recovery", "start_pos": 24, "end_pos": 38, "type": "TASK", "confidence": 0.6788474917411804}]}, {"text": "Finally, we offer concrete results when SXLFG is used with an existing grammar for French.", "labels": [], "entities": []}, {"text": "We show that our parser is both efficient and robust, although the grammar is very ambiguous.", "labels": [], "entities": []}], "introductionContent": [{"text": "In order to tackle the algorithmic difficulties of parsers when applied to real-life corpora, it is nowadays usual to apply robust and efficient methods such as Markovian techniques or finite automata.", "labels": [], "entities": []}, {"text": "These methods are perfectly suited fora large number of applications that do not rely on a complex representation of the sentence.", "labels": [], "entities": []}, {"text": "However, the descriptive expressivity of resulting analyses is far below what is needed to represent, e.g., phrases or long-distance dependencies in away that is consistent with serious linguistic definitions of these concepts.", "labels": [], "entities": []}, {"text": "For this reason, we designed a parser that is compatible with a linguistic theory, namely LFG, as well as robust and efficient despite the high variability of language production.", "labels": [], "entities": []}, {"text": "Developing anew parser for LFG (LexicalFunctional Grammars, see, e.g.,) is not in itself very original.", "labels": [], "entities": []}, {"text": "Several LFG parsers already exist, including those of or ().", "labels": [], "entities": []}, {"text": "However, the most famous LFG system is undoubtedly the Xerox Linguistics Environment (XLE) project which is the successor of the Grammars Writer's Workbench).", "labels": [], "entities": []}, {"text": "XLE is a large project which concentrates a lot of linguistic and computational technology, relies on a similar point of view on the balance between shallow and deep parsing, and has been successfully used to parse large unrestricted corpora.", "labels": [], "entities": [{"text": "parse large unrestricted corpora", "start_pos": 209, "end_pos": 241, "type": "TASK", "confidence": 0.878627359867096}]}, {"text": "Nevertheless, these parsers do not always use in the most extensive way all existing algorithmic techniques of computation sharing and compact information representation that make it possible to write an efficient LFG parser, despite the fact that the LFG formalism, as many other formalisms relying on unification, is NP-hard.", "labels": [], "entities": []}, {"text": "Of course our purpose is not to make anew XLE system but to study how robustness and efficiency can be reached in LFG parsing on raw text.", "labels": [], "entities": [{"text": "LFG parsing", "start_pos": 114, "end_pos": 125, "type": "TASK", "confidence": 0.6541413366794586}]}, {"text": "Building constituent structures (c-structures) does not raise any particular problem in theory, 1 because they are described in LFG by a context-free grammar (CFG), called (CF) backbone in this paper.", "labels": [], "entities": []}, {"text": "Indeed, general parsing algorithms for CFGs are well-known (Earley, GLR,.", "labels": [], "entities": []}, {"text": "). On the other hand, the efficient construction of functional structures (f-structures) is much more problematic.", "labels": [], "entities": []}, {"text": "The first choice that a parser designer must face is that of when f-structures are processed: either during CF parsing (interleaved method) or in a second phase (two-pass computation).", "labels": [], "entities": [{"text": "CF parsing", "start_pos": 108, "end_pos": 118, "type": "TASK", "confidence": 0.6489903330802917}]}, {"text": "The second choice is between f-structures evaluation on single individualparsestrees) or on a complete representation of all parses.", "labels": [], "entities": []}, {"text": "We choose to process all phrasal constraints by a CF parser which produces a shared forest 2 of polynomial size in polynomial time.", "labels": [], "entities": []}, {"text": "Second, this shared forest is used, as a whole, to decide which functional constraints to process.", "labels": [], "entities": []}, {"text": "For ambiguous CF backbones, this two pass computation is more efficient than interleaving phrasal and functional constraints.", "labels": [], "entities": []}, {"text": "Another advantage of this two pass vision is that the CF parser maybe easily replaced by another one.", "labels": [], "entities": []}, {"text": "It may also be replaced by a more powerful parser.", "labels": [], "entities": []}, {"text": "We choose to evaluate functional constraints directly on the shared forest since it has been proven), as one can easily expect, that techniques which evaluate functional constraints on an enumeration of the resulting phrase-structure trees area computational disaster.", "labels": [], "entities": []}, {"text": "This article explores the computation of f-structures directly (without unfolding) on shared forests.", "labels": [], "entities": []}, {"text": "We will see how, in some cases, our parser allows to deal with potential combinatorial explosion.", "labels": [], "entities": []}, {"text": "Moreover, at all levels, error recovering mechanisms turn our system into a robust parser.", "labels": [], "entities": []}, {"text": "Our parser, called SXLFG, has been evaluated with two large-coverage grammars for French, on corpora of various genres.", "labels": [], "entities": [{"text": "SXLFG", "start_pos": 19, "end_pos": 24, "type": "DATASET", "confidence": 0.7081055045127869}]}, {"text": "In the last section of this paper, we present quantitative results of SXLFG using one of these grammars on a general journalistic corpus.", "labels": [], "entities": []}], "datasetContent": [{"text": "Therefore, demonstrates the level of ambiguity of the CF backbone by showing the median number of CF parses given the number of transitions in the lattice representing the sentence.", "labels": [], "entities": [{"text": "CF backbone", "start_pos": 54, "end_pos": 65, "type": "DATASET", "confidence": 0.8303984999656677}]}, {"text": "Although the number of trees is excessively high, shows the efficiency of our CF parser (the maximum number of trees reached in our corpus is as high as 9.12 10 38 fora sentence of length 140, which is parsed in only 0.75 s).", "labels": [], "entities": []}, {"text": "Moreover, the error recovery algorithms described in section 3.1 are successful inmost cases where the CF backbone does not recognize the input sentences: out of the 3292 sentences, 364 are not recognized (11.1%), and the parser proposes a non-trivial recovery for all but 13 (96.3%).", "labels": [], "entities": [{"text": "error recovery", "start_pos": 14, "end_pos": 28, "type": "TASK", "confidence": 0.6953570693731308}]}, {"text": "We shall see later the relevance of the proposed recovered forests.", "labels": [], "entities": []}, {"text": "We should however notice that the ambiguity of forests is significantly higher in case of error recovery.", "labels": [], "entities": [{"text": "error recovery", "start_pos": 90, "end_pos": 104, "type": "TASK", "confidence": 0.6899517476558685}]}, {"text": "Although the CF backbone is massively ambiguous, results show that our f-structures evaluation system is pretty efficient.", "labels": [], "entities": [{"text": "CF backbone", "start_pos": 13, "end_pos": 24, "type": "DATASET", "confidence": 0.8580597043037415}]}, {"text": "Indeed, with a timeout of 20 seconds, it takes only 6 301 seconds to parse the whole corpus, and only 5, 7% of sentences reach the timeout before producing a parse.", "labels": [], "entities": []}, {"text": "These results can be compared to the result with the same grammar on the same corpus, but without internal disambiguation (see 2.4), which is 30 490 seconds and 41.2% of sentences reaching the timeout.", "labels": [], "entities": []}, {"text": "The coverage of the grammar on our corpus with internal disambiguation is 57.6%, the coverage being defined as the proportion of sentences for which a consistent and complete main f-structure is output by the parser.", "labels": [], "entities": []}, {"text": "This includes cases where the sentence was agrammatical w.r.t. the CF backbone, but for which the forest produced by the error recovery techniques made it possible to compute a consistent and complete main f-structure (this concerns 86 sentences, i.e., 2.6% of all sentences, and 24.5% of all agrammatical sentences w.r.t. the backbone; this shows that CF error recovery gives relevant results).", "labels": [], "entities": [{"text": "CF backbone", "start_pos": 67, "end_pos": 78, "type": "DATASET", "confidence": 0.9341309666633606}, {"text": "CF error recovery", "start_pos": 353, "end_pos": 370, "type": "TASK", "confidence": 0.584496021270752}]}, {"text": "The comparison with the results with the same grammar but without internal disambiguation is interesting (see): in this case, the high proportion of sentences that reach the timeout before being parsed leads to a coverage as low as 40.2%.", "labels": [], "entities": [{"text": "coverage", "start_pos": 213, "end_pos": 221, "type": "METRIC", "confidence": 0.985267162322998}]}, {"text": "Amid the sentences covered by such a system, 94.6% are also covered by the full-featured parser (with internal disambiguation), which means that only 72 sentences covered by the grammar are lost because of the internal disambiguation.", "labels": [], "entities": []}, {"text": "This should be compared with the 645 sentences that are not parsed because of the timeout when internal disambiguation is disabled, but that are covered by the grammar and correctly parsed if internal disambiguation is used: the risk that is taken by pruning f-structures during the parsing process is much smaller than the benefit it gives, both in terms of coverage and parsing time.", "labels": [], "entities": []}, {"text": "Since we do not want the ambiguity of the CF backbone to influence our results, plots the total parsing time, including the evaluation of features structures, against the number of trees produced by the CF parser.", "labels": [], "entities": []}], "tableCaptions": [{"text": " Table 1: Coverage results with and without internal ranking, with the same grammar and corpus.", "labels": [], "entities": [{"text": "Coverage", "start_pos": 10, "end_pos": 18, "type": "TASK", "confidence": 0.949169933795929}]}]}