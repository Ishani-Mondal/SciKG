{"title": [{"text": "Verb subcategorization kernels for automatic semantic labeling", "labels": [], "entities": [{"text": "automatic semantic labeling", "start_pos": 35, "end_pos": 62, "type": "TASK", "confidence": 0.5801339745521545}]}], "abstractContent": [{"text": "Recently, many researches in natural language learning have considered the representation of complex linguistic phenomena by means of structural kernels.", "labels": [], "entities": []}, {"text": "In particular, tree kernels have been used to represent verbal subcategorization frame (SCF) information for predicate argument classification.", "labels": [], "entities": [{"text": "predicate argument classification", "start_pos": 109, "end_pos": 142, "type": "TASK", "confidence": 0.8347646196683248}]}, {"text": "As the SCF is a relevant clue to learn the relation between syntax and semantic, the classification algorithm accuracy was remarkable enhanced.", "labels": [], "entities": [{"text": "accuracy", "start_pos": 110, "end_pos": 118, "type": "METRIC", "confidence": 0.9916086792945862}]}, {"text": "In this article, we extend such work by studying the impact of the SCF tree kernel on both PropBank and FrameNet semantic roles.", "labels": [], "entities": [{"text": "PropBank", "start_pos": 91, "end_pos": 99, "type": "DATASET", "confidence": 0.8860935568809509}]}, {"text": "The experiments with Support Vector Machines (SVMs) confirm a strong link between the SCF and the semantics of the verbal predicates as well as the benefit of using kernels in diverse and complex test conditions, e.g. classification of unseen verbs.", "labels": [], "entities": [{"text": "classification of unseen verbs", "start_pos": 218, "end_pos": 248, "type": "TASK", "confidence": 0.8410688042640686}]}], "introductionContent": [{"text": "Some theories of verb meaning are based on syntactic properties, e.g. the alternations of verb arguments.", "labels": [], "entities": []}, {"text": "In turn, Verb Subcategorization Frame (SCF) characterizes different syntactic alternations, thus, it plays a central role in the linking theory between verb semantics and their syntactic structures.", "labels": [], "entities": []}, {"text": "shows the parse tree for the sentence \"John rented a room in Boston\" along with the semantic shallow information embodied by the verbal predicate to rent and its three arguments: Arg0, Arg1 and ArgM.", "labels": [], "entities": [{"text": "Arg0", "start_pos": 179, "end_pos": 183, "type": "METRIC", "confidence": 0.9930878281593323}, {"text": "Arg1", "start_pos": 185, "end_pos": 189, "type": "METRIC", "confidence": 0.9794324636459351}, {"text": "ArgM", "start_pos": 194, "end_pos": 198, "type": "METRIC", "confidence": 0.9911495447158813}]}, {"text": "The SCF of such verb, i.e. NP-PP, provides a synthesis of the predicate argument structure.", "labels": [], "entities": []}, {"text": "Currently, the systems which aim to derive semantic shallow information from texts recognize the SCF of a target verb and represent it as a flat feature (e.g. () in the learning algorithm.", "labels": [], "entities": []}, {"text": "To achieve this goal, a lexicon which describes the SCFs for each verb, is required.", "labels": [], "entities": []}, {"text": "Such a resource is difficult to find especially for specific domains, thus, several methods to automatically extract SCF have been proposed).", "labels": [], "entities": []}, {"text": "In, an alternative to the SCF extraction was proposed, i.e. the SCF kernel (SK).", "labels": [], "entities": [{"text": "SCF extraction", "start_pos": 26, "end_pos": 40, "type": "TASK", "confidence": 0.9001791179180145}]}, {"text": "The subcategorization frame of verbs was implicitly represented by means of the syntactic subtrees which include the predicate with its arguments.", "labels": [], "entities": []}, {"text": "The similarity between such syntactic structures was evaluated by means of convolution kernels.", "labels": [], "entities": []}, {"text": "Convolution kernels are machine learning approaches which aim to describe structured data in terms of its substructures.", "labels": [], "entities": []}, {"text": "The similarity between two structures is carried out by kernel functions which determine the number of common substructures without evaluating the overall substructure space.", "labels": [], "entities": []}, {"text": "Thus, if we associate two SCFs with two subtrees, we can measure their similarity with such functions applied to the two trees.", "labels": [], "entities": []}, {"text": "This approach determines a more syntactically motivated verb partition than the traditional method based on flat SCF representations (e.g. the NP-PP of).", "labels": [], "entities": []}, {"text": "The subtrees associated with SCF group the verbs which have similar syntactic realizations, in turn, according to Levin's theories, this would suggest that they are semantically related.", "labels": [], "entities": []}, {"text": "A preliminary study on the benefit of such kernels was measured on the classification accuracy of semantic arguments in).", "labels": [], "entities": [{"text": "accuracy", "start_pos": 86, "end_pos": 94, "type": "METRIC", "confidence": 0.8858689069747925}]}, {"text": "In such work, the improvement on the PropBank arguments) classification suggests that SK adds information to the prediction of semantic structures.", "labels": [], "entities": [{"text": "PropBank arguments) classification", "start_pos": 37, "end_pos": 71, "type": "DATASET", "confidence": 0.8492659777402878}, {"text": "prediction of semantic structures", "start_pos": 113, "end_pos": 146, "type": "TASK", "confidence": 0.8138236552476883}]}, {"text": "On the contrary, the performance decrease on the FrameNet data classification shows the limit of such approach, i.e. when the syntactic structures are shared among several semantic roles SK seems to be useless.", "labels": [], "entities": [{"text": "FrameNet data classification", "start_pos": 49, "end_pos": 77, "type": "DATASET", "confidence": 0.9251345992088318}]}, {"text": "In this article, we use Support Vector Machines (SVMs) to deeply analyze the role of SK in the automatic predicate argument classification.", "labels": [], "entities": [{"text": "automatic predicate argument classification", "start_pos": 95, "end_pos": 138, "type": "TASK", "confidence": 0.6345817074179649}]}, {"text": "The major novelty of the article relates to the extensive experimentation carried out on the PropBank) and FrameNet corpora with diverse levels of task complexity, e.g. test instances of unseen predicates (typical of free-text processing).", "labels": [], "entities": [{"text": "PropBank", "start_pos": 93, "end_pos": 101, "type": "DATASET", "confidence": 0.9288290143013}]}, {"text": "The results show that: (1) once a structural representation of a linguistic object, e.g. SCF, is available we can use convolution kernels to study its connections with another linguistic phenomenon, e.g. the semantic predicate arguments.", "labels": [], "entities": []}, {"text": "(2) The tree kernels automatically derive the features (structures) which support also a sort of back-off estimation in case of unseen verbs.", "labels": [], "entities": []}, {"text": "(3) The structural features are in general robust in all testing conditions.", "labels": [], "entities": []}, {"text": "The remainder of this article is organized as follows: Section 2 defines the Predicate Argument Extraction problem and the standard solution to solve it.", "labels": [], "entities": [{"text": "Predicate Argument Extraction problem", "start_pos": 77, "end_pos": 114, "type": "TASK", "confidence": 0.7874414026737213}]}, {"text": "In Section 3 we present our kernels whereas in Section 4 we show comparative results among SVMs using standard features and the proposed kernels.", "labels": [], "entities": []}, {"text": "Finally, Section 5 summarizes the conclusions.", "labels": [], "entities": []}], "datasetContent": [{"text": "A clustering algorithm which uses SK would group together verbs that show a similar syntactic structure.", "labels": [], "entities": []}, {"text": "To study the properties of such clusters we experimented SK in combination with the traditional kernel used for the predicate argument classification.", "labels": [], "entities": [{"text": "predicate argument classification", "start_pos": 116, "end_pos": 149, "type": "TASK", "confidence": 0.7264010508855184}]}, {"text": "To normalize a kernel K( x, z) we can divide it by", "labels": [], "entities": []}], "tableCaptions": [{"text": " Table 1: Kernel accuracies on PropBank.", "labels": [], "entities": [{"text": "PropBank", "start_pos": 31, "end_pos": 39, "type": "DATASET", "confidence": 0.9059098362922668}]}, {"text": " Table 2: Kernel accuracies on 18 FrameNet semantic roles.", "labels": [], "entities": []}]}