{"title": [{"text": "A Parsing Algorithm That Extends Phrases", "labels": [], "entities": [{"text": "Parsing Algorithm That Extends Phrases", "start_pos": 2, "end_pos": 40, "type": "TASK", "confidence": 0.7200798869132996}]}], "abstractContent": [{"text": "It is desirable fora parser to be able to extend a phrase even after it has been combined into a larger syntactic unit.", "labels": [], "entities": []}, {"text": "This paper presents an algorithm that does this in two ways, one dealing with \"right extension\" and the other with \"left recursion\".", "labels": [], "entities": []}, {"text": "A brief comparison with other parsing algorithms shows it to be related to the left-corner parsing algorithm, but it is more flexible in the order that it permits phrases to be combined.", "labels": [], "entities": []}, {"text": "It has many of the properties of the sentence analyzers of Marcus and Riesbeck, but is independent of the language theories on which those programs are based.", "labels": [], "entities": []}], "introductionContent": [{"text": "To analyze a sentence of a natural language, a computer program recognizes the phrases within the sentence, builds data structures, such as conceptual representations, for each of them and combines those structures into one that corresponds to the entire sentence.", "labels": [], "entities": []}, {"text": "The algorithm which recognizes the phrases and invokes the structure-building procedures is the parsing algorithm implemented by the program.", "labels": [], "entities": []}, {"text": "The parsing algorithm is combined with a set of procedures for deciding between alternative actions and for building the datastructures.", "labels": [], "entities": [{"text": "parsing", "start_pos": 4, "end_pos": 11, "type": "TASK", "confidence": 0.9699937701225281}]}, {"text": "Since it is organized around phrases, it is primarily concerned with syntax, while the procedures it calls deal with non-syntactic parts of the analysis.", "labels": [], "entities": []}, {"text": "When the program is run, there maybe a complex interplay between the code segments that handle syntax and those that handle semantics and pragmatics, but the program organization can still be abstracted into a (syntactic) parsing algorithm and a set of procedures that are called to augment that algorithm.", "labels": [], "entities": []}, {"text": "By taking the view that the parsing algorithm recognizes the phrases in a sentence, that is, the components of its surface structure and how they can be decomposed, it suffices to specify the syntax of a natural language, at least approximately, with a context-free phrase structure grammar, the rules of which serve as phrase decomposition rules.", "labels": [], "entities": [{"text": "phrase decomposition", "start_pos": 320, "end_pos": 340, "type": "TASK", "confidence": 0.7076592147350311}]}, {"text": "Although linguists have developed more elaborate grammars for this purpose, most computer programs for sentence analysis, e.g.,, and, specify the syntax with such a grammar, or something equivalent, and then augment that grammar with procedures and data structures to handle the non-context-free components of the language.", "labels": [], "entities": [{"text": "sentence analysis", "start_pos": 103, "end_pos": 120, "type": "TASK", "confidence": 0.7312938719987869}]}, {"text": "The notion of parsing algorithm is therefore restricted in this paper to an algorithm that recognizes phrases in accordance with a context-free phrase structure grammar.", "labels": [], "entities": [{"text": "parsing algorithm", "start_pos": 14, "end_pos": 31, "type": "TASK", "confidence": 0.9008080065250397}]}, {"text": "Since the parsing algorithm of a sentence analysis program determines when data structures get combined, it seems reasonable to expect that the actions of the parser should reflect the actions on the data structures.", "labels": [], "entities": []}, {"text": "In particular, the combination of phrases into larger phrases can be expected to coincide with the combination of corresponding data structures into larger data structures.", "labels": [], "entities": []}, {"text": "This happens naturally when the computer program is such that it calls the procedures for combining data structures at the same time the parsing algorithm indicates that the corresponding phrases should be combined.", "labels": [], "entities": []}, {"text": "ous problem with this approach, if computed phrases are supposed to correspond to natural phrases in a sentence, is that the parser cannot handle leftbranching phrases.", "labels": [], "entities": [{"text": "ous", "start_pos": 0, "end_pos": 3, "type": "METRIC", "confidence": 0.9316352605819702}]}, {"text": "But such phrases occur in English, Japanese, Turkish and other natural languages).", "labels": [], "entities": []}, {"text": "The principle of bottom-up parsing is that a sequence of phrases whose types match the right-hand side of a grammar rule is reduced to a phrase of the type on the left-hand side of the rule.", "labels": [], "entities": [{"text": "bottom-up parsing", "start_pos": 17, "end_pos": 34, "type": "TASK", "confidence": 0.6224597096443176}]}, {"text": "None of the matching is done until all the phrases are present; this can be ensured by matching the phrase types in the right-to-left order shown in the grammar rule.", "labels": [], "entities": []}, {"text": "The difficulty with this approach is that the analysis of the first part of a sentence has no influence on the analysis of latter parts until the results of the analyses are finally combined.", "labels": [], "entities": []}, {"text": "Efforts to overcome this difficulty lead naturally to the third approach, left-corner parsing.", "labels": [], "entities": [{"text": "left-corner parsing", "start_pos": 74, "end_pos": 93, "type": "TASK", "confidence": 0.6606202125549316}]}, {"text": "Left-corner parsing, like bottom-up parsing, reduces phrases whose types match the right-hand side of a grammar rule to a phrase of the type on the -~ left-hand side of the rule; the difference is that the '< ~,types listed in the right-hand side of the rule are /j0\"x~matched from left to right for left-corner parsing ~.", "labels": [], "entities": [{"text": "Left-corner parsing", "start_pos": 0, "end_pos": 19, "type": "TASK", "confidence": 0.7242418825626373}]}, {"text": "~ instead of from right to left.", "labels": [], "entities": []}, {"text": "This technique gets its ~ name from the fact that the first phrase found cor-~ responds to the left-most symbol of the right-hand b'~side of the grammar rule, and this symbol has been called the left corner of the rule.", "labels": [], "entities": []}, {"text": "(When a grammar rule is drawn graphically with its left-hand side as the parent node and the symbols of the right-hand side as the daughters, forming a triangle, the leftmost symbol is the left corner of the triangle.)", "labels": [], "entities": []}, {"text": "Once the left-corner phrase has been found, the grammar rule can be used to predict what kind of phrase will come next.", "labels": [], "entities": []}, {"text": "This is how the analysis of the first part of a sentence can influence the analysis of later parts.", "labels": [], "entities": []}, {"text": "Most programs based on augmented transition networks employ a top-down parser to which registers and structure building routines have been added, e.g., and.", "labels": [], "entities": []}, {"text": "It is important to note, however, that the concept of augmented transition networks is a particular way to represent linguistic knowledge; it does not require that the program using the networks operate in top-down fashion.", "labels": [], "entities": []}, {"text": "In an early paper by, alternative algorithms that can be used with augmented transition networks are discussed, including the bottom-up and Earley algorithms.", "labels": [], "entities": []}, {"text": "The procedure-based programs of and are basically top-down parsers, too.", "labels": [], "entities": []}, {"text": "The NLP program of employs an augmented phrase structure grammar to combine phrases in a basically bottom-up fashion.", "labels": [], "entities": []}, {"text": "Likewise, PARRY, the program written by Colby, uses a kind of bottom-up method to drive a computer model of a paranoid.", "labels": [], "entities": [{"text": "PARRY", "start_pos": 10, "end_pos": 15, "type": "METRIC", "confidence": 0.6399827003479004}]}], "datasetContent": [{"text": "The algorithm has been presented herein a simple form to make its exposition easier and its operating principles clearer.", "labels": [], "entities": []}, {"text": "When it was tried out in an experimental program, several techniques were used to make it work more efficiently.", "labels": [], "entities": []}, {"text": "For example, operations 1 and 2 were combined with the other operations so that they were, in effect, applied as soon as possible.", "labels": [], "entities": []}, {"text": "Operation 3 was also applied as soon as possible.", "labels": [], "entities": []}, {"text": "The other operations cannot be given a definite order for their application; that must be determined by the non-syntactic procedures that are added to the parser.", "labels": [], "entities": []}, {"text": "Another technique increased efficiency by applying operation 4 only when the result is consistent with the grammar.", "labels": [], "entities": []}, {"text": "Suppose grammar G1 contained the rule Det --> that as well as the rule RelPro --> that.", "labels": [], "entities": []}, {"text": "When the word \"that\" in the sentence \"this is the cat that caught the rat that stole the cheese\" is processed, the element list contains the triple (,that,n) (PP,NPI,e) (RelPro VP,NP,e) atone point.", "labels": [], "entities": []}, {"text": "The grammar permits operation 4 to be applied to (,that,n) to produce either (,Det,n) or (,RelPro,n), but only the latter can lead to a successful parse because the grammar does not allow k0~]or either a PP phrase or a RelPro phrase to begin V~,~'x with a Det phrase.", "labels": [], "entities": []}, {"text": "The technique for guiding oper-.x' ff~\\ation 4 so that it produces only useful elements con~<~\\sists of computing beforehand all the phrase types \\<h~ ~that can be-gin each phrase.", "labels": [], "entities": []}, {"text": "Then-the-following \"~,,k v \"operation is used ~n p~ace ~ operation 4: 4'a.", "labels": [], "entities": []}, {"text": "If an element of the form (,X,n) is at the (right) end of the list, replace it with the pair (,X,p) (Y1 ...", "labels": [], "entities": []}, {"text": "Yn,Z,n) when there is a grammar rule of the form Z --> X Y1 ...", "labels": [], "entities": []}, {"text": "Yn in the grammar, provided the rule is not left-recursive.", "labels": [], "entities": []}, {"text": "If an element of the form (,X,n) is followed by an element of the form (U1 ... Um,V,F), replace (,X,n) with the pair (,X,p) (Y1 ...", "labels": [], "entities": []}, {"text": "Yn,Z,n) when there is a grammar rule of the form Z --> X Y1 ...", "labels": [], "entities": []}, {"text": "Yn in the grammar, provided the rule is not left-recursive, and a Z phrase can begin a U1 phrase or Z = U1.", "labels": [], "entities": []}, {"text": "It is sufficient to consider only the first element after an element of the form (,X,n) because if operation 4'b cannot be applied, either that first element can be deleted by operation 6 or the parse is going to fail anyway.", "labels": [], "entities": []}, {"text": "Thus, in our example above, operation 6 can be used to delete the element (PP,NPI,e) so that operation 4'b can be applied to (,that,n) (RelPro VP,NP,e).", "labels": [], "entities": []}, {"text": "This technique is essentially the same as the selective filter techniqueo described by for left-corner parsing ~gorithm, in their terminology).", "labels": [], "entities": [{"text": "gorithm", "start_pos": 112, "end_pos": 119, "type": "METRIC", "confidence": 0.8642882704734802}]}, {"text": "Another technique increased efficiency further by postponing the decision about which of several grammar rules to apply via operations 3 or 4' for as long as possible.", "labels": [], "entities": []}, {"text": "The grammar rules were stored in Lisp list structures so that rules having the same left-hand side and a common initial segment in their right-hand side shared a common list structure, for example, if the grammar consists of the rules X->YZU X->YZV W->YZU these rules are stored as the list structure which is stored on the property list for Y.", "labels": [], "entities": []}, {"text": "The common initial segment shared by the first two rules is represented by the same path to the atom Z in the list structure.", "labels": [], "entities": []}, {"text": "The component (X (Z (U) (V))) in this list structure means that a Y phrase can be followed by a Z phrase and then either a U phrase or a V phrase to make an X phrase.", "labels": [], "entities": []}, {"text": "When a Y phrase is found, and it is decided to try to find an X phrase, this component makes it possible to look fora Z phrase, but it postpones the decision as to whether the Z phrase should be followed by a U phrase or a V phrase until after the Z phrase has been found.", "labels": [], "entities": []}, {"text": "The left-hand sides (X and W) of the rules are listed first to facilitate operation 4'b.", "labels": [], "entities": []}, {"text": "This technique is similar to a technique used by and described by.", "labels": [], "entities": []}], "tableCaptions": [{"text": " Table 1. Trace of parsing algorithm on sentence 1.", "labels": [], "entities": [{"text": "Trace", "start_pos": 10, "end_pos": 15, "type": "METRIC", "confidence": 0.9726824760437012}]}]}