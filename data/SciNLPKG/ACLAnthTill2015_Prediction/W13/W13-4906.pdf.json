{"title": [{"text": "Exploring beam-based shift-reduce dependency parsing with DyALog: Results from the SPMRL 2013 shared task", "labels": [], "entities": [{"text": "beam-based shift-reduce dependency parsing", "start_pos": 10, "end_pos": 52, "type": "TASK", "confidence": 0.6209791228175163}, {"text": "SPMRL 2013 shared task", "start_pos": 83, "end_pos": 105, "type": "TASK", "confidence": 0.7419624030590057}]}], "abstractContent": [{"text": "The SPMRL 2013 shared task was the opportunity to develop and test, with promising results, a simple beam-based shift-reduce dependency parser on top of the tabular logic programming system DYALOG.", "labels": [], "entities": [{"text": "SPMRL 2013", "start_pos": 4, "end_pos": 14, "type": "TASK", "confidence": 0.6380738914012909}, {"text": "DYALOG", "start_pos": 190, "end_pos": 196, "type": "DATASET", "confidence": 0.8901169300079346}]}, {"text": "The parser was also extended to handle ambiguous word lattices, with almost no loss w.r.t. disam-biguated input, thanks to specific training, use of oracle segmentation, and large beams.", "labels": [], "entities": []}, {"text": "We believe that this result is an interesting new one for shift-reduce parsing.", "labels": [], "entities": []}], "introductionContent": [{"text": "DYALOG is a tabular-based logic programming environment, including a language (variant of Prolog), a bootstrapped compiler, and C-based abstract machine.", "labels": [], "entities": [{"text": "DYALOG", "start_pos": 0, "end_pos": 6, "type": "DATASET", "confidence": 0.9328435659408569}]}, {"text": "It is mostly used for chart-like parsing (de La Clergerie, 2005b), in particular fora wide coverage French Tree Adjoining Grammar ().", "labels": [], "entities": [{"text": "French Tree Adjoining Grammar", "start_pos": 100, "end_pos": 129, "type": "DATASET", "confidence": 0.9444172978401184}]}, {"text": "However, DYALOG offers all the power of a programming language a la Prolog, with some specific advantages, and it was tempting to try it on statistical parsing paradigms.", "labels": [], "entities": [{"text": "DYALOG", "start_pos": 9, "end_pos": 15, "type": "DATASET", "confidence": 0.8140767216682434}, {"text": "Prolog", "start_pos": 68, "end_pos": 74, "type": "DATASET", "confidence": 0.953872561454773}, {"text": "statistical parsing paradigms", "start_pos": 140, "end_pos": 169, "type": "TASK", "confidence": 0.7825461228688558}]}, {"text": "The SPMRL 2013 shared task () was an interesting opportunity to develop a simple (non-deterministic) beam-based shift-reduce dependency parser, called DYALOG-SR, inspired by.", "labels": [], "entities": [{"text": "SPMRL 2013 shared task", "start_pos": 4, "end_pos": 26, "type": "TASK", "confidence": 0.6315732598304749}]}, {"text": "The main advantage of logic programming is the (almost) transparent handling of non-determinism, useful for instance to handle ambiguous word lattices.", "labels": [], "entities": []}, {"text": "DYALOG allows an easy tabulation of items, and their fast retrieval (thanks to full term indexing), needed for the dynamic programming part of the algorithm.", "labels": [], "entities": [{"text": "DYALOG", "start_pos": 0, "end_pos": 6, "type": "DATASET", "confidence": 0.8221796751022339}]}, {"text": "Thanks to structure sharing and term hashing, it also reduces the costs related to the tabulation of multiple items (sharing subparts) and to term unification.", "labels": [], "entities": [{"text": "term hashing", "start_pos": 32, "end_pos": 44, "type": "TASK", "confidence": 0.693608433008194}, {"text": "term unification", "start_pos": 142, "end_pos": 158, "type": "TASK", "confidence": 0.6848798841238022}]}, {"text": "Logic programs tend to be very concise, with, in our case, around 1500 lines of DYALOG code.", "labels": [], "entities": []}, {"text": "However, one of the disadvantages of (pure) logic programming, and of DYALOG in particular, is the handling of mutable structures, which motivated the development of a companion C module (around 850 lines) to handle statistical models (loading, querying, updating, and saving).", "labels": [], "entities": []}, {"text": "We briefly present the implemented algorithm (Section 2) and list the preliminary adaptations done for the 9 languages of the shared task.", "labels": [], "entities": []}, {"text": "We analyze in Section 4 the official results for DYALOG-SR.", "labels": [], "entities": [{"text": "DYALOG-SR", "start_pos": 49, "end_pos": 58, "type": "DATASET", "confidence": 0.9022573828697205}]}, {"text": "Recent developments corrected some weaknesses of DYALOG-SR.", "labels": [], "entities": [{"text": "DYALOG-SR", "start_pos": 49, "end_pos": 58, "type": "DATASET", "confidence": 0.9096857309341431}]}, {"text": "In particular, we explain in Section 5 how we seriously improved the parsing of ambiguous lattices, an important new result for shift-reduce parsing.", "labels": [], "entities": [{"text": "parsing of ambiguous lattices", "start_pos": 69, "end_pos": 98, "type": "TASK", "confidence": 0.8519772291183472}]}, {"text": "Finally, Section 6 provides some empirical data about the efficiency and complexity of the algorithm.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": [{"text": " Table 1: Taking into account multiple roots (on gold/full)", "labels": [], "entities": []}, {"text": " Table 3: Results on dev lattices (TED accuracy  *  100)", "labels": [], "entities": [{"text": "TED accuracy  *  100", "start_pos": 35, "end_pos": 55, "type": "METRIC", "confidence": 0.8177169412374496}]}]}