{"title": [{"text": "Finite State Methods and Description Logics", "labels": [], "entities": [{"text": "Finite State Methods and Description Logics", "start_pos": 0, "end_pos": 43, "type": "TASK", "confidence": 0.5792446285486221}]}], "abstractContent": [{"text": "The accepting runs of a finite automaton are represented as concepts in a Description Logic, for various systems of roles computed by finite-state transducers.", "labels": [], "entities": []}, {"text": "The representation refines the perspective on regular languages provided by Monadic Second-Order Logic (MSO), under the B\u00fcchi-Elgot-Trakhtenbrot theorem.", "labels": [], "entities": [{"text": "Monadic Second-Order Logic (MSO)", "start_pos": 76, "end_pos": 108, "type": "TASK", "confidence": 0.6314435799916586}]}, {"text": "String symbols are structured as sets to succinctly express MSO-sentences, with auxiliary symbols conceived as variables bound by quantifiers.", "labels": [], "entities": []}], "introductionContent": [{"text": "As declarative specifications of sets of strings accepted by finite automata (i.e. regular languages), regular expressions are far and away more popular than the formulas of Monadic Second-Order Logic (MSO), which, by a fundamental theorem due to B\u00fcchi, Elgot and Trakhtenbrot, pick out the regular languages (e.g.).", "labels": [], "entities": [{"text": "Monadic Second-Order Logic (MSO)", "start_pos": 174, "end_pos": 206, "type": "TASK", "confidence": 0.6995447178681692}]}, {"text": "Computational semantics, however, can hardly ignore MSO's model-theoretic perspective on strings with its computable notions of entailment.", "labels": [], "entities": []}, {"text": "Furthermore, regular expressions lack the succinctness that MSO's Boolean connectives support.", "labels": [], "entities": [{"text": "MSO's Boolean connectives", "start_pos": 60, "end_pos": 85, "type": "DATASET", "confidence": 0.8226891607046127}]}, {"text": "Both negation and conjunction blowup the size of regular expressions by an exponential or two.", "labels": [], "entities": []}, {"text": "A symptom of the problem is the exponential cost of mapping a finite automaton A to a regular expression denoting the language L(A) accepted by A (.", "labels": [], "entities": []}, {"text": "A more economical declarative representation of L(A) is afforded by pairing a string a 1 a 2 \u00b7 \u00b7 \u00b7 an in L(A) with a string q 1 q 2 \u00b7 \u00b7 \u00b7 q n of A's (internal) states q i in the course of a run (by A) accepting a 1 a 2 \u00b7 \u00b7 \u00b7 an . This representation involves expanding the alphabet of the strings, and subsequently contracting the alphabet.", "labels": [], "entities": []}, {"text": "A simple way to carry this out is by forming strings \u03b1 1 \u03b1 2 \u00b7 \u00b7 \u00b7 \u03b1 n of sets \u03b1 i that we can, for instance, intersect with a fixed set B, defining a string homomorphism \u03c1 B for componentwise intersection with B \u03c1 B (\u03b1 1 \u00b7 \u00b7 \u00b7 \u03b1 n ) := (\u03b1 1 \u2229 B) \u00b7 \u00b7 \u00b7 (\u03b1 n \u2229 B).", "labels": [], "entities": []}, {"text": "For example, assuming no state q i belongs to the alphabet \u03a3 of L(A), \u03c1 \u03a3 ( a 1 , q 1 \u00b7 \u00b7 \u00b7 an , q n ) = a 1 \u00b7 \u00b7 \u00b7 an where we draw boxes instead of curly braces for sets used as string symbols.", "labels": [], "entities": []}, {"text": "The homomorphisms \u03c1 B are linked below to the treatment of variables in MSO.", "labels": [], "entities": [{"text": "MSO", "start_pos": 72, "end_pos": 75, "type": "DATASET", "confidence": 0.9332948327064514}]}, {"text": "Given a finite alphabet A, MSO A -sentences are formed from a binary relation symbol S (encoding successor) and a unary relation symbol U a , for each a \u2208 A.", "labels": [], "entities": []}, {"text": "We then interpret an MSO A -sentence against a string over the alphabet 2 A of subsets of A, deviating ever so slightly from the custom of interpreting against strings in A + . Expanding the alphabet from A to 2 A accommodates a form of underspecification that, among other things, facilitates the interpretation of MSO A -formulas relative to variable assignments.", "labels": [], "entities": []}, {"text": "As for the homomorphisms \u03c1 B , the idea is that B picks out a subset of A, leaving each a \u2208 A that is not in B as an \"auxiliary marker symbol\" -a staple of finite-state language processing.", "labels": [], "entities": []}, {"text": "By focusing on the accepting runs of a finite automaton, the present paper strives to be relevant to finite-state language processing in general.", "labels": [], "entities": [{"text": "finite-state language processing", "start_pos": 101, "end_pos": 133, "type": "TASK", "confidence": 0.6377757986386617}]}, {"text": "But to understand its difference with say), a few words about the language applications motivating it might be helpful.", "labels": [], "entities": []}, {"text": "These applications concern not morphology, phonology, speech or even syntax but semantics -in particular, temporal semantics.", "labels": [], "entities": []}, {"text": "The convenience of equating succession in a string with temporal succession is yet another 63 reason to step from A up to 2 A (reading a boxed subset of A as a snapshot).", "labels": [], "entities": []}, {"text": "It is a trivial enough matter to build a finite-state transducer between (2 A ) * and (A \u222a {[, ]}) * unwinding say, the string a, a a of length 2 over the alphabet 2 {a,a } to the string[a ] of length 7 over the alphabet {a, a , [, ]} and if we are to apply \u03c1 B , it is natural to choose the alphabet 2 A over A \u222a {}.", "labels": [], "entities": []}, {"text": "There are, in any case, many more regular relations apart from \u03c1 B to consider for temporal semantics, including those that change string length and the notion of temporal succession, i.e. granularity.", "labels": [], "entities": []}, {"text": "A simple but powerful way of building a regular language from a regular relation R is by forming the inverse image of a regular language L under R, which we write RL, following dynamic logic (e.g..", "labels": [], "entities": []}, {"text": "The basic thrust of the present paper is to extend regular expressions by adding connectives for negation, conjunction and inverse images under certain regular relations.", "labels": [], "entities": []}, {"text": "This extension is dressed up below in Description Logic (DLs;, with the languages L(A) accepted by automata A as DLconcepts (unary relations), and various regular relations including \u03c1 B (for different sets B) as DLroles (binary relations).", "labels": [], "entities": []}, {"text": "As in the attributive language with complement ALC, DL-concepts C are closed under conjunction C \u2227 C , negation \u00acC, and inverse images under DL-roles R, the usual DL notation for which, (\u2203R)C, we replace by RC from dynamic logic, with Since DL-concepts and DL-roles in the present context, have clear intended interpretations, we will often drop the semantic brackets], conflating an expression with its meaning.", "labels": [], "entities": []}, {"text": "MSO is linked to DL by a mapping of MSOsentences \u03d5 to DL-concepts C \u03d5 that reduces MSO-entailments |= MSO to concept inclusion Let us take care not to read (1) as stating MSO is interpretable in DL in the sense of; no formal DL theory is mentioned in (1), only a particular (intended) interpretation over strings.", "labels": [], "entities": []}, {"text": "What we vary is not the interpretation] but the mapping \u03d5 \u2192 C \u03d5 establishing (1).", "labels": [], "entities": []}, {"text": "Many different definitions of C \u03d5 will do, and the main aim of the present work is to explore these possibilities, expressed as particular DL concepts and roles.", "labels": [], "entities": []}, {"text": "In its account of regular languages, the B\u00fcchi-Elgot-Trakhtenbrot theorem says nothing about finite-state transducers, which are nonetheless instrumental in establishing the theorem.", "labels": [], "entities": []}, {"text": "Behind the move to Description Logics is the view that the role of finite-state transducers in constructing regular languages merits scrutiny.", "labels": [], "entities": [{"text": "Description Logics", "start_pos": 19, "end_pos": 37, "type": "TASK", "confidence": 0.8652920126914978}]}, {"text": "To dispel possible confusion, it is perhaps worth remarking that a relation computable by a finitestate transducer may have a transitive closure that no finite-state transducer can compute.", "labels": [], "entities": []}, {"text": "There should be no mistaking the interpretations of concepts and roles below for models of ALC reg . Most every role considered below (from \u03c1 B on) is, however, transitive and indeed can be viewed as some notion of \"part of.\"", "labels": [], "entities": [{"text": "ALC reg", "start_pos": 91, "end_pos": 98, "type": "TASK", "confidence": 0.8058781027793884}]}, {"text": "The remainder of this paper is organized as follows.", "labels": [], "entities": []}, {"text": "The accepting runs of a finite automaton are expressed as a DL-concept in section 2.", "labels": [], "entities": []}, {"text": "This is then used to present MSO's semantic set-up in section 3.", "labels": [], "entities": [{"text": "MSO", "start_pos": 29, "end_pos": 32, "type": "DATASET", "confidence": 0.6188679337501526}]}, {"text": "A feature of that set-up is the expansion of MSO A -models from A + to (2 A ) + , opening up possibilities of underspecification which section 4 explores alongside non-deterministic DLroles (in addition to the inverse of \u03c1 B ).", "labels": [], "entities": []}, {"text": "Section 64 5 looks at more DL-roles that, unlike \u03c1 B , change length, and section 6 concludes, returning to auxiliary symbols, which are subject not only to \u03c1 B but the various regular relations formulated above as DL-roles.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": []}