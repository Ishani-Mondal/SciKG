{"title": [{"text": "A Convexity-based Generalization of Viterbi for Non-Deterministic Weighted Automata", "labels": [], "entities": []}], "abstractContent": [{"text": "We propose a novel approach for the max-string problem in acyclic nondeterminis-tic weighted FSA's, which is based on a convexity-related notion of domination among intermediary results, and which can be seen as a generalization of the usual dynamic programming technique for finding the max-path (a.k.a. Viterbi approximation) in such automata.", "labels": [], "entities": []}], "introductionContent": [{"text": "Let Abe an acyclic weighted finite-state automaton (WFSA) on a vocabulary V with weights in the (extended) set of non-negative reals R \u221e + = [0, \u221e], which we assume to be combined multiplicatively.", "labels": [], "entities": []}, {"text": "We can consider two problems.", "labels": [], "entities": []}, {"text": "The first one, max-path, is to find the path \u03c0 of maximum weight in the automaton, that is, the path that maximizes the product of the weights associated with its transitions; the second one, max-string, is to find the string x in V * that maximizes the sum of the weights of all the paths that yield x.", "labels": [], "entities": [{"text": "max-path", "start_pos": 15, "end_pos": 23, "type": "METRIC", "confidence": 0.9502793550491333}]}, {"text": "While the max-string problem is often the most important in principle, it is much more difficult to solve than the max-path problem; in fact (Casacuberta and de la show that the problem is NPhard: they describe a class of acyclic weighted automata that encode the Satisfiability problem (SAT) in such away that identifying the maxstring in such automata in polynomial time would imply a polynomial solution to SAT.", "labels": [], "entities": []}, {"text": "In practice, one tends to use the max-path solution as a proxy to the max-string solution; this approximation employs the Viterbi algorithm, and is widely used in speech recognition, machine translation and other NLP tasks.", "labels": [], "entities": [{"text": "speech recognition", "start_pos": 163, "end_pos": 181, "type": "TASK", "confidence": 0.7728881239891052}, {"text": "machine translation", "start_pos": 183, "end_pos": 202, "type": "TASK", "confidence": 0.8021632730960846}]}, {"text": "The contribution of this paper is to propose a novel approach for the max-string problem over the \"sum-times\" semiring K s \u2261 (R \u221e + , +, \u00b7, 0, 1), involving a generalization of the Viterbi procedure.", "labels": [], "entities": []}, {"text": "A naive approach to the max-string problem would consist in enumerating all the paths, summing the weights of paths corresponding to the same string, and outputting the maximum string.", "labels": [], "entities": []}, {"text": "Another, more appealing, approach consists in noting that in the case of a deterministic weighted automaton A , the max-string and maxpath problems coincide, and therefore in trying to determinize A, and then apply the standard Viterbi algorithm.", "labels": [], "entities": []}, {"text": "However, while existing techniques for determinizing a weighted automaton) work reasonably well in some practical cases over the \"max-times\" semiring (R \u221e + , max, \u00b7, 0, 1), 1 they often -rather counter-intuitively -lead to combinatorial explosion when working in the sum-times semiring, even in cases where the automaton is acyclic and where the classical (unweighted) determinization of A does not explode ().", "labels": [], "entities": []}, {"text": "While the applications of determinization cited in to such domains as speech recognition tend to focus on the max-times semiring, we are aware of one application where determinization is based on the sum-times semiring, but in a slightly different formal situation ().", "labels": [], "entities": [{"text": "speech recognition", "start_pos": 70, "end_pos": 88, "type": "TASK", "confidence": 0.7858063876628876}]}, {"text": "In this paper, the authors generalize the determinization technique of) from string to tree automata, and then address the question of determinizing a weighted tree automaton generating a set of trees, where each tree represents a possible translation of a fixed source sentence, in the context of a syntax-based SMT system (they also present an application to data-oriented parsing).", "labels": [], "entities": [{"text": "SMT", "start_pos": 313, "end_pos": 316, "type": "TASK", "confidence": 0.9108726382255554}]}, {"text": "In this way they are often able, at least for short sentences, to find the translation tree of maximum total weight in reasonable time.", "labels": [], "entities": []}, {"text": "A similar technique, directly based on, but using the sum-times semiring over a string automaton, could presumably be tempted for the weighted lattices produced by a phrase-based translation system such as Moses (), but we are not aware of any such attempt.", "labels": [], "entities": []}, {"text": "The novelty of our approach to the max-string problem is that it bypasses the need fora preliminary determinization of the automaton before applying Viterbi, but instead proposes to apply a generalization of Viterbi directly to the original nondeterministic automaton.", "labels": [], "entities": []}, {"text": "Let us now describe this approach.", "labels": [], "entities": []}, {"text": "Elements of V are called symbols, elements of V * strings.", "labels": [], "entities": []}, {"text": "It will be convenient to assume that the automaton A has a special form: (i) it has exactly one initial state q 0 and one final state q f , (ii) there is a special \"end-of-string\" symbol $ in V , (iii) $ only appears on transitions to q f , and no other symbol can appear on such a transition, (iv) transitions labeled with $ have weight 1 or 0.", "labels": [], "entities": []}, {"text": "Ina nutshell and informally, the main idea is then the following.", "labels": [], "entities": []}, {"text": "Consider a string x = a 1 a 2 . .", "labels": [], "entities": []}, {"text": "a k relative to the original automaton is equal to that of the string a1a2 . .", "labels": [], "entities": []}, {"text": "a k $ relative to the transformed automaton.", "labels": [], "entities": []}, {"text": "Using this observation, we only need to explicitely store the set S of dominating prefix strings; whatever the suffix used to go to the final state, at least one of these dominating prefixes will lead to a better result with this suffix than using a dominated prefix x with the same suffix.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": []}