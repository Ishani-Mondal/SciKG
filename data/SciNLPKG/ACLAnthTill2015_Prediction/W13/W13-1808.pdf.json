{"title": [{"text": "Optimizing Rule-Based Morphosyntactic Analysis of Richly Inflected Languages -a Polish Example", "labels": [], "entities": [{"text": "Optimizing Rule-Based Morphosyntactic Analysis of Richly Inflected Languages", "start_pos": 0, "end_pos": 76, "type": "TASK", "confidence": 0.7368026673793793}]}], "abstractContent": [{"text": "We consider finite-state optimization of morphosyntactic analysis of richly and ambiguously annotated corpora.", "labels": [], "entities": []}, {"text": "We propose a general algorithm which, despite being surprisingly simple, proved to be effective in several applications for rulesets which do not match frequently.", "labels": [], "entities": []}], "introductionContent": [{"text": "Morphosyntactic analysis of natural language texts is commonly performed as an iterative process of applying pre-defined syntactical rules to a previously tokenised and morphologically annotated input).", "labels": [], "entities": [{"text": "Morphosyntactic analysis of natural language texts", "start_pos": 0, "end_pos": 50, "type": "TASK", "confidence": 0.9082615574200948}]}, {"text": "We consider two of its sub-tasks: shallow parsing and disambiguation.", "labels": [], "entities": [{"text": "shallow parsing", "start_pos": 34, "end_pos": 49, "type": "TASK", "confidence": 0.6332377791404724}]}, {"text": "As stated in, such tasks can often be efficiently realized with finite-state transducers (FST), which allow time savings by the classical operations of determinization, minimization and composition.", "labels": [], "entities": []}, {"text": "However, the applicability of the FST model may depend on the richness of annotation and on the expressive power of the rules.", "labels": [], "entities": [{"text": "FST", "start_pos": 34, "end_pos": 37, "type": "TASK", "confidence": 0.8284112811088562}]}, {"text": "These both tend to complicate in richly inflected languages, including Baltic and most of Slavic.", "labels": [], "entities": []}, {"text": "Motivated by the needs which arose during the development of the National Corpus of Polish (NCP, (), we aim at a high-efficiency rule-based morphosyntactic analysis framework suitable for such languages.", "labels": [], "entities": [{"text": "National Corpus of Polish (NCP", "start_pos": 65, "end_pos": 95, "type": "DATASET", "confidence": 0.9447598656018575}]}, {"text": "Despite the existence of many formal methods and tools for this task, we are not aware of any previous result meeting all our needs, listed in Section 2.", "labels": [], "entities": []}, {"text": "We discuss the state of the art in Section 3.", "labels": [], "entities": []}, {"text": "Our solution to the problem, though surprisingly single, performs well under the assumption that the rules match rarely, i.e. the average number of matches per rule per sentence is significantly below 1.", "labels": [], "entities": []}, {"text": "In the case of rules designed for analyzing the Polish corpora, this was about 0.05-0.1, depending on the particular corpus and ruleset.", "labels": [], "entities": []}], "datasetContent": [{"text": "Our approach has been applied to optimize Spejd, a syntactic parser of broad functionality which has been used for corpus development, valence extraction, and also sentiment analysis presents the overall efficiency of the system.", "labels": [], "entities": [{"text": "corpus development", "start_pos": 115, "end_pos": 133, "type": "TASK", "confidence": 0.7901465892791748}, {"text": "valence extraction", "start_pos": 135, "end_pos": 153, "type": "TASK", "confidence": 0.7874782085418701}, {"text": "sentiment analysis", "start_pos": 164, "end_pos": 182, "type": "TASK", "confidence": 0.9319649040699005}]}, {"text": "In the tests, performed on a computer with 3.1 GHz AMD FX processor, 467 handwritten rules of were applied to a 15 million token sample from the IPI Corpus.", "labels": [], "entities": [{"text": "IPI Corpus", "start_pos": 145, "end_pos": 155, "type": "DATASET", "confidence": 0.9691529870033264}]}, {"text": "Notably, the use of lazy construction increased the achievable width from about 3-4 to about 30. 9", "labels": [], "entities": [{"text": "achievable width", "start_pos": 52, "end_pos": 68, "type": "METRIC", "confidence": 0.8026498556137085}]}], "tableCaptions": [{"text": " Table 1: The speed and memory usage of Spejd in  terms of the composition width.", "labels": [], "entities": [{"text": "speed", "start_pos": 14, "end_pos": 19, "type": "METRIC", "confidence": 0.9769048690795898}, {"text": "Spejd", "start_pos": 40, "end_pos": 45, "type": "DATASET", "confidence": 0.7783768773078918}]}]}