{"title": [{"text": "Magic for Filter Optimization in Dynamic Bottom-up Processing", "labels": [], "entities": [{"text": "Filter Optimization", "start_pos": 10, "end_pos": 29, "type": "TASK", "confidence": 0.835504949092865}]}], "abstractContent": [], "introductionContent": [{"text": "In natural language processing filtering is used to weed out those search paths that are redundant, i.e., are not going to be used in the proof tree corresponding to the natural language expression to be generated or parsed.", "labels": [], "entities": [{"text": "natural language processing filtering", "start_pos": 3, "end_pos": 40, "type": "TASK", "confidence": 0.7247590124607086}]}, {"text": "Filter optimization often comprises an extension of a specific processing strategy such that it exploits specific knowledge about grammars and/or the computational task(s) that one is using them for.", "labels": [], "entities": [{"text": "Filter optimization", "start_pos": 0, "end_pos": 19, "type": "TASK", "confidence": 0.9406836330890656}]}, {"text": "At the same time it often remains unclear how these optimizations relate to each other and what they actually mean.", "labels": [], "entities": []}, {"text": "In this paper I show how starting from a definite clause characterization of filtering derived automatically from a logic grammar using Magic compilation, filter optimizations can be performed in a processor independent and logically clean fashion.", "labels": [], "entities": []}, {"text": "Magic (templates) is a general compilation technique for efficient bottom-up evaluation of logic programs developed in the deductive database community (.", "labels": [], "entities": []}, {"text": "Given a logic program, Magic produces anew program in which the filtering as normally resulting from top-down evaluation is explicitly characterized through, so-called, *url: http://www.sfs.nphil.uni-tuebingen/'minnen magic predicates, which produce variable bindings for filtering when evaluated bottom-up.", "labels": [], "entities": []}, {"text": "The original rules of the program are extended such that these bindings can be made effective.", "labels": [], "entities": []}, {"text": "As a result of the definite clause characterization of filtering, Magic brings filtering into the logic underlying the grammar.", "labels": [], "entities": []}, {"text": "I discuss two filter optimizations.", "labels": [], "entities": []}, {"text": "These optimizations are direction independent in the sense that they are useful for both generation and parsing.", "labels": [], "entities": [{"text": "parsing", "start_pos": 104, "end_pos": 111, "type": "TASK", "confidence": 0.8248807191848755}]}, {"text": "For expository reasons, though, they are presented merely on the basis of examples of generation.", "labels": [], "entities": []}, {"text": "Magic compilation does not limit the information that can be used for filtering.", "labels": [], "entities": [{"text": "Magic compilation", "start_pos": 0, "end_pos": 17, "type": "TASK", "confidence": 0.6942484378814697}]}, {"text": "This can lead to nontermination as the tree fragments enumerated in bottom-up evaluation of magic compiled grammars are connected.", "labels": [], "entities": []}, {"text": "More specifically, 'magic generation' falls prey to non-termination in the face of head recursion, i.e., the generation analog of left recursion in parsing.", "labels": [], "entities": []}, {"text": "This necessitates a dynamic processing strategy, i.e., memoization, extended with an abstraction function like, e.g., restriction, to weaken filtering and a subsumption check to discard redundant results.", "labels": [], "entities": []}, {"text": "It is shown that fora large class of grammars the subsumption check which often influences processing efficiency rather dramatically can be eliminated through fine-tuning of the magic predicates derived fora particular grammar after applying an abstraction function in an off-line fashion.", "labels": [], "entities": []}, {"text": "Unfolding can be used to eliminate superfluous filtering steps.", "labels": [], "entities": []}, {"text": "Given an off-line optimization of the order in which the right-hand side categories in the rules of a logic grammar are processed) the resulting processing behavior can be considered a generalization of the head corner generation approach (: Without the need to rely on notions such as semantic head and chain rule, ahead corner behavior can be mimicked in a strict bottom-up fashion.", "labels": [], "entities": [{"text": "head corner generation", "start_pos": 207, "end_pos": 229, "type": "TASK", "confidence": 0.6223161518573761}]}], "datasetContent": [], "tableCaptions": []}