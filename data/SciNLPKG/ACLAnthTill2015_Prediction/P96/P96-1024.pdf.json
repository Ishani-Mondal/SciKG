{"title": [], "abstractContent": [{"text": "Many different metrics exist for evaluating parsing results, including Viterbi, Crossing Brackets Rate, Zero Crossing Brackets Rate, and several others.", "labels": [], "entities": [{"text": "parsing", "start_pos": 44, "end_pos": 51, "type": "TASK", "confidence": 0.95464688539505}, {"text": "Viterbi", "start_pos": 71, "end_pos": 78, "type": "METRIC", "confidence": 0.9987320303916931}, {"text": "Crossing Brackets Rate", "start_pos": 80, "end_pos": 102, "type": "METRIC", "confidence": 0.6763765811920166}, {"text": "Zero Crossing Brackets Rate", "start_pos": 104, "end_pos": 131, "type": "METRIC", "confidence": 0.5750028491020203}]}, {"text": "However, most parsing algorithms, including the Viterbi algorithm, attempt to optimize the same metric, namely the probability of getting the correct labelled tree.", "labels": [], "entities": []}, {"text": "By choosing a parsing algorithm appropriate for the evaluation metric, better performance can be achieved.", "labels": [], "entities": [{"text": "parsing", "start_pos": 14, "end_pos": 21, "type": "TASK", "confidence": 0.962816596031189}]}, {"text": "We present two new algorithms: the \"Labelled Recall Algorithm,\" which maximizes the expected Labelled Recall Rate, and the \"Bracketed Recall Algorithm,\" which maximizes the Bracketed Recall Rate.", "labels": [], "entities": [{"text": "Bracketed Recall Rate", "start_pos": 173, "end_pos": 194, "type": "METRIC", "confidence": 0.866975724697113}]}, {"text": "Experimental results are given, showing that the two new algorithms have improved performance over the Viterbi algorithm on many criteria, especially the ones that they optimize.", "labels": [], "entities": []}], "introductionContent": [{"text": "In corpus-based approaches to parsing, one is given a treebank (a collection of text annotated with the \"correct\" parse tree) and attempts to find algorithms that, given unlabelled text from the treebank, produce as similar a parse as possible to the one in the treebank.", "labels": [], "entities": [{"text": "parsing", "start_pos": 30, "end_pos": 37, "type": "TASK", "confidence": 0.9758398532867432}]}, {"text": "Various methods can be used for finding these parses.", "labels": [], "entities": []}, {"text": "Some of the most common involve inducing Probabilistic Context-Free Grammars (PCFGs), and then parsing with an algorithm such as the Labelled Tree (Viterbi) Algorithm, which maximizes the probability that the output of the parser (the \"guessed\" tree) is the one that the PCFG produced.", "labels": [], "entities": []}, {"text": "This implicitly assumes that the induced PCFG does a good job modeling the corpus.", "labels": [], "entities": []}, {"text": "There are many different ways to evaluate these parses.", "labels": [], "entities": []}, {"text": "We propose that by creating algorithms that optimize the evaluation criterion, rather than some related criterion, improved performance can be achieved.", "labels": [], "entities": []}, {"text": "In Section 2, we define most of the evaluation metrics used in this paper and discuss previous approaches.", "labels": [], "entities": []}, {"text": "Then, in Section 3, we discuss the Labelled Recall Algorithm, anew algorithm that maximizes performance on the Labelled Recall Rate.", "labels": [], "entities": []}, {"text": "In Section 4, we discuss another new algorithm, the Bracketed Recall Algorithm, that maximizes performance on the Bracketed Recall Rate (closely related to the Consistent Brackets Recall Rate).", "labels": [], "entities": []}, {"text": "Finally, we give experimental results in Section 5 using these two algorithms inappropriate domains, and compare them to the Labelled Tree (Viterbi) Algorithm, showing that each algorithm generally works best when evaluated on the criterion that it optimizes.", "labels": [], "entities": []}], "datasetContent": [{"text": "There are various levels of strictness for determining whether a constituent (element of Ta) is \"correct.\" need not be in Tc--it must simply not be ruled out by any (q, r, Y) e To.", "labels": [], "entities": []}, {"text": "A particular triple (q, r, Y) rules out (s,t, X) if there is noway that (s,t,X) and (q, r, Y) could both be in the same parse tree.", "labels": [], "entities": []}, {"text": "In particular, if the interval (s, t) crosses the interval (q, r), then (s, t, X) is ruled out and counted as an error.", "labels": [], "entities": []}, {"text": "Formally, we say that (s, t) crosses (q, r) if and only ifs<q<t <rorq<s<r<t.", "labels": [], "entities": []}, {"text": "If Tc is binary branching, then Consistent Brackets and Bracketed Match are identical.", "labels": [], "entities": [{"text": "Brackets", "start_pos": 43, "end_pos": 51, "type": "METRIC", "confidence": 0.5208202600479126}, {"text": "Bracketed Match", "start_pos": 56, "end_pos": 71, "type": "METRIC", "confidence": 0.8842378258705139}]}, {"text": "The following symbols denote the number of constituents that match according to each of these criteria.", "labels": [], "entities": []}, {"text": "We describe two experiments for testing these algorithms.", "labels": [], "entities": []}, {"text": "The first uses a grammar without meaningful nonterminal symbols, and compares the Bracketed Recall Algorithm to the traditional Labelled Tree (Viterbi) Algorithm.", "labels": [], "entities": [{"text": "Labelled Tree (Viterbi) Algorithm", "start_pos": 128, "end_pos": 161, "type": "DATASET", "confidence": 0.7255550523598989}]}, {"text": "The second uses a grammar with meaningful nonterminal symbols and performs a three-way comparison between the Labelled Recall, Bracketed Recall, and Labelled Tree Algorithms.", "labels": [], "entities": []}, {"text": "These experiments show that use of an algorithm matched appropriately to the evaluation criterion can lead to as much as a 10% reduction in error rate.", "labels": [], "entities": [{"text": "error rate", "start_pos": 140, "end_pos": 150, "type": "METRIC", "confidence": 0.9753357172012329}]}, {"text": "In both experiments the grammars could not parse some sentences, 0.5% and 9%, respectively.", "labels": [], "entities": []}, {"text": "The unparsable data were assigned aright branching structure with their rightmost element attached high.", "labels": [], "entities": []}, {"text": "Since all three algorithms fail on the same sentences, all algorithms were affected equally.", "labels": [], "entities": []}, {"text": "The experiment of Pereira and Schabes (1992) was duplicated.", "labels": [], "entities": []}, {"text": "In that experiment, a grammar was trained from a bracketed form of the TI section of the ATIS corpus 1 using a modified form of the InsideOutside Algorithm.", "labels": [], "entities": [{"text": "TI section of the ATIS corpus 1", "start_pos": 71, "end_pos": 102, "type": "DATASET", "confidence": 0.7488914855888912}]}, {"text": "Pereira and Schabes then used the Labelled Tree Algorithm to select the best parse for sentences in held out test data.", "labels": [], "entities": []}, {"text": "The experiment was repeated here, except that both the Labelled Tree and Labelled Recall Algorithm were run for each sentence.", "labels": [], "entities": [{"text": "Labelled Tree", "start_pos": 55, "end_pos": 68, "type": "DATASET", "confidence": 0.6705711185932159}]}, {"text": "In contrast to previous research, we repeated the experiment ten times, with different training set, test set, and initial conditions each time.", "labels": [], "entities": []}, {"text": "shows the results of running this experiment, giving the minimum, maximum, mean, and standard deviation for three criteria, Consistent Brackets Recall, Consistent Brackets Tree, and 1For our experiments the corpus was slightly cleaned up.", "labels": [], "entities": [{"text": "Consistent Brackets Recall", "start_pos": 124, "end_pos": 150, "type": "METRIC", "confidence": 0.8016771276791891}]}, {"text": "A diff file for \"ed\" between the original ATIS data and the cleaned-up version is available from ftp://ftp.das.harvard.edu/pub/goodman/atised/ ti_tb.par-ed and ti_tb.pos-ed.", "labels": [], "entities": [{"text": "ATIS data", "start_pos": 42, "end_pos": 51, "type": "DATASET", "confidence": 0.9713546335697174}]}, {"text": "The number of changes made was small, less than 0.2% In addition, the performance of the Bracketed Recall Algorithm was also qualitatively more appealing.", "labels": [], "entities": [{"text": "Bracketed Recall Algorithm", "start_pos": 89, "end_pos": 115, "type": "DATASET", "confidence": 0.5487118164698283}]}, {"text": "Notice that the Bracketed Recall Algorithm's Consistent Brackets Rate (versus iteration) is smoother and more nearly monotonic than the Labelled Tree Algorithm's.", "labels": [], "entities": [{"text": "Consistent Brackets Rate", "start_pos": 45, "end_pos": 69, "type": "METRIC", "confidence": 0.7533480525016785}]}, {"text": "The Bracketed Recall Algorithm also gets off to a much faster start, and is generally (although not always) above the Labelled Tree level.", "labels": [], "entities": [{"text": "Bracketed Recall Algorithm", "start_pos": 4, "end_pos": 30, "type": "TASK", "confidence": 0.4981013039747874}, {"text": "Labelled Tree", "start_pos": 118, "end_pos": 131, "type": "DATASET", "confidence": 0.7239303439855576}]}, {"text": "For the Labelled Tree Rate, the two are usually very comparable.", "labels": [], "entities": [{"text": "Labelled Tree Rate", "start_pos": 8, "end_pos": 26, "type": "DATASET", "confidence": 0.7535777886708578}]}, {"text": "The replication of the Pereira and Schabes experiment was useful for testing the Bracketed Recall Algorithm.", "labels": [], "entities": [{"text": "Bracketed Recall Algorithm", "start_pos": 81, "end_pos": 107, "type": "TASK", "confidence": 0.4403843581676483}]}, {"text": "However, since that experiment induces a grammar with nonterminals not comparable to those in the training, a different experiment is needed to evaluate the Labelled Recall Algorithm, one in which the nonterminals in the induced grammar are the same as the nonterminals in the test set.", "labels": [], "entities": []}], "tableCaptions": [{"text": " Table 1: Percentages Correct for Labelled Tree ver- sus Bracketed Recall for Pereira and Schabes", "labels": [], "entities": [{"text": "Bracketed Recall", "start_pos": 57, "end_pos": 73, "type": "METRIC", "confidence": 0.7662943601608276}, {"text": "Pereira and Schabes", "start_pos": 78, "end_pos": 97, "type": "DATASET", "confidence": 0.7938089370727539}]}, {"text": " Table 3: Metrics and Corresponding Algorithms", "labels": [], "entities": []}, {"text": " Table 2: Grammar Induced by Counting: Three Algorithms Evaluated on Five Criteria", "labels": [], "entities": []}]}