{"title": [{"text": "A LOGICAL VERSION OF FUNCTIONAL GRAMMAR", "labels": [], "entities": [{"text": "LOGICAL", "start_pos": 2, "end_pos": 9, "type": "METRIC", "confidence": 0.6790655851364136}, {"text": "VERSION", "start_pos": 10, "end_pos": 17, "type": "METRIC", "confidence": 0.4970133900642395}, {"text": "FUNCTIONAL GRAMMAR", "start_pos": 21, "end_pos": 39, "type": "METRIC", "confidence": 0.7121649384498596}]}], "abstractContent": [{"text": "I Abstract Kay's functional-unification grammar notation [5] is away of expressing grammars which relies on very few primitive notions.", "labels": [], "entities": []}, {"text": "The primary syntactic structure is the feature structure, which can be visualised as a directed graph with arcs labeled by attributes of a constituent, and the primary structure-building operation is unification.", "labels": [], "entities": []}, {"text": "In this paper we propose a mathematical formulation of FUG, using logic to give a precise account of the strings and the structures defined by any grammar written in this notation.", "labels": [], "entities": [{"text": "FUG", "start_pos": 55, "end_pos": 58, "type": "DATASET", "confidence": 0.48041802644729614}]}, {"text": "2 Introduction Our basic approach to the problem of syntactic description is to use logical formulas to put conditions or constraints on ordering of constituents, ancestor and descendant relations, and feature attribute information in syntactic structures.", "labels": [], "entities": [{"text": "syntactic description", "start_pos": 52, "end_pos": 73, "type": "TASK", "confidence": 0.8798168897628784}]}, {"text": "The present version of our logic has predicates specifically designed for these purposes.", "labels": [], "entities": []}, {"text": "A grammar can be considered as just a logical formula, and the structures satisfying the formula are the syntactic structures for the sentences of the language.", "labels": [], "entities": []}, {"text": "This notion goes back to DCG's [0], but our formulation is quite different.", "labels": [], "entities": [{"text": "DCG's [0", "start_pos": 25, "end_pos": 33, "type": "DATASET", "confidence": 0.93857841193676}]}, {"text": "In particular, it builds on the logic of Kasper and Rounds [3], a logic intended specifically to describe feature structures.", "labels": [], "entities": []}, {"text": "The formulation has several new aspects.", "labels": [], "entities": []}, {"text": "First, it introduces the oriented feature structure as the primary syntactic structure.", "labels": [], "entities": []}, {"text": "One can think of these structures as parse trees superimposed on directed graphs, although the general definition allows much more flexibility.", "labels": [], "entities": []}, {"text": "In fact, our notation does away with the parse tree altogether.", "labels": [], "entities": []}, {"text": "A second aspect of the notation is its treatment of word order.", "labels": [], "entities": []}, {"text": "Our logic allows small grammars to define free-word order languages overlarge vocabularies in away not possible with standard ID/LP rules.", "labels": [], "entities": []}, {"text": "It is not clear whether or not this treatment of word order was intended by Kay, but the issue naturally arose during the process of making this model precise.", "labels": [], "entities": [{"text": "word order", "start_pos": 49, "end_pos": 59, "type": "TASK", "confidence": 0.6639952957630157}]}, {"text": "(Joshi [1] has adopted much the same conventions in tree adjunct grammar.)", "labels": [], "entities": [{"text": "tree adjunct grammar", "start_pos": 52, "end_pos": 72, "type": "TASK", "confidence": 0.6540321608384451}]}, {"text": "A third aspect of our treatment is the use of fixed-point formulas to introduce recursion into grammars.", "labels": [], "entities": []}, {"text": "This idea is implicit in DCG's, and has been made explicit in the logics CLFP and ILFP [9].", "labels": [], "entities": [{"text": "DCG", "start_pos": 25, "end_pos": 28, "type": "DATASET", "confidence": 0.886081337928772}, {"text": "CLFP", "start_pos": 73, "end_pos": 77, "type": "DATASET", "confidence": 0.8900660276412964}]}, {"text": "We give a simple way of expressing the semantics of these formulas which corresponds closely to the usual notion of grammatical derivations.", "labels": [], "entities": []}, {"text": "There is an interesting use of type ~ariables to describe syntactic categories and/or constructions.", "labels": [], "entities": []}, {"text": "We illustrate the power of the notation by sketching how the constructions of relational grammar [7] can be formulated in the logic.", "labels": [], "entities": []}, {"text": "To our knowledge, this is the first attempt to interpret the relational ideas in a fully mathematical framework.", "labels": [], "entities": []}, {"text": "Although relational networks themselves have been precisely specified, there does not seem to be a precise statement of how relational derivations take place.", "labels": [], "entities": []}, {"text": "We do not claim that our formalization is the one intended by Postal and Perlmutter, but we do claim that our notation shows clearly the relationship of relational to transformational grammars on one hand, and to lexical-functional grammars on the other.", "labels": [], "entities": []}, {"text": "Finally, we prove that the satisfiability problem for our logic is undecidable.", "labels": [], "entities": []}, {"text": "This should perhaps bean expected result, because the proof relies on simulating Turing machine computations in a grammar, and follows the standard undecidability arguments.", "labels": [], "entities": []}, {"text": "The satisfiability problem is not quite the same problem as the aniversal recognition problem, however, and with mild conditions on derivations similar to those proposed for LFG [2], the latter problem should become decidable.", "labels": [], "entities": [{"text": "aniversal recognition", "start_pos": 64, "end_pos": 85, "type": "TASK", "confidence": 0.6926137655973434}]}, {"text": "We must leave efficiency questions unexamined in this paper.", "labels": [], "entities": []}, {"text": "The notation has not been implemented.", "labels": [], "entities": []}, {"text": "We view this notation as a temporary one, and anticipate that many revisions and extensions will be necessary if it is to be implemented at all.", "labels": [], "entities": []}, {"text": "Of course, FUG itself could be considered as an implementation, but we have added the word order relations to our logic, which are not explicit in FUG.", "labels": [], "entities": [{"text": "FUG", "start_pos": 11, "end_pos": 14, "type": "DATASET", "confidence": 0.8977253437042236}, {"text": "FUG", "start_pos": 147, "end_pos": 150, "type": "DATASET", "confidence": 0.9526415467262268}]}, {"text": "In this paper, which is not full because of space limitations , we will give definitions and examples in Section 3; then will sketch the relational application in Section 4, and will conclude with the undecidability result and some final remarks.", "labels": [], "entities": []}], "introductionContent": [{"text": "Our basic approach to the problem of syntactic description is to use logical formulas to put conditions or constraints on ordering of constituents, ancestor and descendant relations, and feature attribute information in syntactic structures.", "labels": [], "entities": [{"text": "syntactic description", "start_pos": 37, "end_pos": 58, "type": "TASK", "confidence": 0.8781037330627441}]}, {"text": "The present version of our logic has predicates specifically designed for these purposes.", "labels": [], "entities": []}, {"text": "A grammar can be considered as just a logical formula, and the structures satisfying the formula are the syntactic structures for the sentences of the language.", "labels": [], "entities": []}, {"text": "This notion goes back to DCG's, but our formulation is quite different.", "labels": [], "entities": [{"text": "DCG", "start_pos": 25, "end_pos": 28, "type": "DATASET", "confidence": 0.9355244040489197}]}, {"text": "In particular, it builds on the logic of Kasper and Rounds, a logic intended specifically to describe feature structures.", "labels": [], "entities": []}, {"text": "The formulation has several new aspects.", "labels": [], "entities": []}, {"text": "First, it introduces the oriented feature structure as the primary syntactic structure.", "labels": [], "entities": []}, {"text": "One can think of these structures as parse trees superimposed on directed graphs, although the general definition allows much more flexibility.", "labels": [], "entities": []}, {"text": "In fact, our notation does away with the parse tree altogether.", "labels": [], "entities": []}, {"text": "A second aspect of the notation is its treatment of word order.", "labels": [], "entities": []}, {"text": "Our logic allows small grammars to define free-word order languages overlarge vocabularies in away not possible with standard ID/LP rules.", "labels": [], "entities": []}, {"text": "It is not clear whether or not this treatment of word order was intended by Kay, but the issue naturally arose during the process of making this model precise.", "labels": [], "entities": [{"text": "word order", "start_pos": 49, "end_pos": 59, "type": "TASK", "confidence": 0.6639952957630157}]}, {"text": "(Joshi has adopted much the same conventions in tree adjunct grammar.)", "labels": [], "entities": [{"text": "tree adjunct grammar", "start_pos": 48, "end_pos": 68, "type": "TASK", "confidence": 0.6543690264225006}]}, {"text": "A third aspect of our treatment is the use of fixedpoint formulas to introduce recursion into grammars.", "labels": [], "entities": []}, {"text": "This idea is implicit in DCG's, and has been made explicit in the logics CLFP and ILFP.", "labels": [], "entities": [{"text": "DCG", "start_pos": 25, "end_pos": 28, "type": "DATASET", "confidence": 0.8820319175720215}, {"text": "CLFP", "start_pos": 73, "end_pos": 77, "type": "DATASET", "confidence": 0.8867824077606201}, {"text": "ILFP", "start_pos": 82, "end_pos": 86, "type": "DATASET", "confidence": 0.8770027756690979}]}, {"text": "We give a simple way of expressing the semantics of these formulas which corresponds closely to the usual notion of grammatical derivations.", "labels": [], "entities": []}, {"text": "There is an interesting use of type ~ariables to describe syntactic categories and/or constructions.", "labels": [], "entities": []}, {"text": "We illustrate the power of the notation by sketching how the constructions of relational grammar can be formulated in the logic.", "labels": [], "entities": []}, {"text": "To our knowledge, this is the first attempt to interpret the relational ideas in a fully mathematical framework.", "labels": [], "entities": []}, {"text": "Although relational networks themselves have been precisely specified, there does not seem to be a precise statement of how relational derivations take place.", "labels": [], "entities": []}, {"text": "We do not claim that our formalization is the one intended by Postal and Perlmutter, but we do claim that our notation shows clearly the relationship of relational to transformational grammars on one hand, and to lexical-functional grammars on the other.", "labels": [], "entities": []}, {"text": "Finally, we prove that the satisfiability problem for our logic is undecidable.", "labels": [], "entities": []}, {"text": "This should perhaps bean expected result, because the proof relies on simulating Turing machine computations in a grammar, and follows the standard undecidability arguments.", "labels": [], "entities": []}, {"text": "The satisfiability problem is not quite the same problem as the aniversal recognition problem, however, and with mild conditions on derivations similar to those proposed for LFG, the latter problem should become decidable.", "labels": [], "entities": [{"text": "aniversal recognition", "start_pos": 64, "end_pos": 85, "type": "TASK", "confidence": 0.6897714287042618}]}, {"text": "We must leave efficiency questions unexamined in this paper.", "labels": [], "entities": []}, {"text": "The notation has not been implemented.", "labels": [], "entities": []}, {"text": "We view this notation as a temporary one, and anticipate that many revisions and extensions will be necessary if it is to be implemented at all.", "labels": [], "entities": []}, {"text": "Of course, FUG itself could be considered as an implementation, but we have added the word order relations to our logic, which are not explicit in FUG.", "labels": [], "entities": [{"text": "FUG", "start_pos": 11, "end_pos": 14, "type": "DATASET", "confidence": 0.8977253437042236}, {"text": "FUG", "start_pos": 147, "end_pos": 150, "type": "DATASET", "confidence": 0.9526415467262268}]}, {"text": "In this paper, which is not full because of space limitations, we will give definitions and examples in Section 3; then will sketch the relational application in Section 4, and will conclude with the undecidability result and some final remarks.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": []}