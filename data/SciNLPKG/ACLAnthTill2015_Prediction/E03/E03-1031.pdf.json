{"title": [{"text": "Describing Syntax with Star-Free Regular Expressions", "labels": [], "entities": []}], "abstractContent": [{"text": "Syntactic constraints in Koskenniemi's Finite-State Intersection Grammar (FSIG) are logically less complex than their formalism (Koskenniemi et al., 1992) would suggest: It turns out that although the constraints in Voutilainen's (1994) FSIG description of English make use of several extensions to regular expressions, the description as a whole reduces to a finite combination of union, complement and concatenation.", "labels": [], "entities": [{"text": "Finite-State Intersection Grammar (FSIG)", "start_pos": 39, "end_pos": 79, "type": "TASK", "confidence": 0.7277093728383383}]}, {"text": "This is an essential improvement to the descriptive complexity of ENGFSIG.", "labels": [], "entities": [{"text": "ENGFSIG", "start_pos": 66, "end_pos": 73, "type": "DATASET", "confidence": 0.8821749687194824}]}, {"text": "The result opens a door for further analysis of logical properties and possible optimizations in the FSIG descriptions.", "labels": [], "entities": [{"text": "FSIG descriptions", "start_pos": 101, "end_pos": 118, "type": "DATASET", "confidence": 0.8133900463581085}]}, {"text": "The proof contains anew formula for compiling Koskenniemi's restriction operation without any marker symbols.", "labels": [], "entities": [{"text": "Koskenniemi's restriction operation", "start_pos": 46, "end_pos": 81, "type": "TASK", "confidence": 0.6286590546369553}]}], "introductionContent": [{"text": "For many years, various finite-state models of language) have been used in surface-syntactic parsing.", "labels": [], "entities": [{"text": "surface-syntactic parsing", "start_pos": 75, "end_pos": 100, "type": "TASK", "confidence": 0.7512914538383484}]}, {"text": "These models can process local syntactic ambiguity efficiently.", "labels": [], "entities": []}, {"text": "However, because the formalism of FiniteState Intersection Grammar) allows full regular expressions, its parsing is sometimes inefficient; many FSIG constraint automata can reduce ambiguity only after they have scanned the whole sentence.", "labels": [], "entities": []}, {"text": "Regular expressions in FSIG can be viewed as a grammar-writing tool that should be as flexible as possible.", "labels": [], "entities": []}, {"text": "This viewpoint has led to introduction of new features into the formalism (.", "labels": [], "entities": []}, {"text": "It is, however, very difficult to make any a priori generalizations of the structural properties of automata as long as we allow unrestricted use of regular expressions.", "labels": [], "entities": []}, {"text": "A complementary view is to analyze the properties of languages described by FSIG regular expressions.", "labels": [], "entities": [{"text": "FSIG regular expressions", "start_pos": 76, "end_pos": 100, "type": "DATASET", "confidence": 0.7292872865994772}]}, {"text": "We can carryout the analysis by checking whether the languages can be described with a restricted class of regular expressions.", "labels": [], "entities": []}, {"text": "For many such classes of expressions, there also exists a group-theoretic characterization.", "labels": [], "entities": []}, {"text": "Moreover, if the analyzed regular language has favorable properties, some problems, e.g. the string membership problem, can be solved faster by means of specialized algorithms.", "labels": [], "entities": [{"text": "string membership problem", "start_pos": 93, "end_pos": 118, "type": "TASK", "confidence": 0.7827111780643463}]}, {"text": "A language can be described with a star-free regular expression if it can be constructed from alphabet symbols by application of union (A U B), complementation (A) and finite concatenation (AB), that is, without the Kleene closure (A*).", "labels": [], "entities": [{"text": "AB", "start_pos": 190, "end_pos": 192, "type": "METRIC", "confidence": 0.7530423402786255}]}, {"text": "The theoretical importance of this class of languages is supported by its characterization in terms of finite aperiodic syntactic monoids and by its definability in first-order logic over strings).", "labels": [], "entities": []}, {"text": "The class has also a lot of practical importance, because many languages in it admit extremely simple implementations (ibid.).", "labels": [], "entities": []}, {"text": "The question of the star-freeness restriction on FSIG constraints has not been studied before, possibly because of the following observations: (i) An acyclic automaton representing readings of the sentence has a central role in FSIG parsing.", "labels": [], "entities": [{"text": "FSIG constraints", "start_pos": 49, "end_pos": 65, "type": "TASK", "confidence": 0.5895593166351318}, {"text": "FSIG parsing", "start_pos": 228, "end_pos": 240, "type": "TASK", "confidence": 0.9189318120479584}]}, {"text": "Star-freeness of the constraints is a minor restriction when compared to the finiteness of this language.", "labels": [], "entities": []}, {"text": "(ii) If automata states are encoded as \"traces\" into strings, any regular language can be represented as a homomorphic image of a (local) star-free language.", "labels": [], "entities": []}, {"text": "Such an encoding is possible in a two-level view of the FSIG framework, where the morphological reading of the sentence is a homomorphic image of a level representing syntactically annotated readings.", "labels": [], "entities": [{"text": "FSIG framework", "start_pos": 56, "end_pos": 70, "type": "DATASET", "confidence": 0.8778725266456604}]}, {"text": "(iii) Given a finite automaton or a regular expression, checking star-freeness of the described language is an intractable (see 2.2) problem.", "labels": [], "entities": []}, {"text": "(iv) Automatical methods to derive star-free regular expressions from another representations procuce long and unintuitive expressions (.", "labels": [], "entities": []}, {"text": "From my point of view, these observations miss some important perspectives: Firstly (i), it is important to understand that a finite-state intersection grammar is also a description of a language with a structure of its own, independent of the acyclic sentence automaton.", "labels": [], "entities": []}, {"text": "Secondly (ii), a realistic FSIG description is linguistically motivated and leaves little room for encoding of traces that could technically make the grammar star-free.", "labels": [], "entities": [{"text": "FSIG description", "start_pos": 27, "end_pos": 43, "type": "TASK", "confidence": 0.8348225057125092}]}, {"text": "Thirdly (iii), heuristic methods can be used to solve many large star-freeness problems in practice.", "labels": [], "entities": []}, {"text": "Fourthly (iv), it is often possible to find star-free regular expressions that are short and illustrative, as it turns out in this paper.", "labels": [], "entities": []}, {"text": "Any automaton recognizing a non-star-free language has a factor that induces a nontrivial permutation of the state space.", "labels": [], "entities": []}, {"text": "For example, the parity language 0* (10*10*)* contains strings with an even number of occurrences of the factor \"1\".", "labels": [], "entities": []}, {"text": "Intuitively, it seems improbable that similar counting constraints occur in natural language grammars However, many regular expressions in involve the Kleene star.", "labels": [], "entities": []}, {"text": "If we can explain why this does not affect the starfreeness of the language, we probably know more about the grammar itself.", "labels": [], "entities": []}, {"text": "A significant contribution of this paper is the human-readable construction that rephrases ENG-FSIG constraints without the Kleene star.", "labels": [], "entities": []}, {"text": "To make the construction more systematic I first outline the framework of FSIG and define its star-freeness problem.", "labels": [], "entities": [{"text": "FSIG", "start_pos": 74, "end_pos": 78, "type": "DATASET", "confidence": 0.7296819090843201}]}, {"text": "After this I explore stars in the ENGFSIG description and reduce regular expressions in the description into their star-free equivalents.", "labels": [], "entities": [{"text": "ENGFSIG description", "start_pos": 34, "end_pos": 53, "type": "DATASET", "confidence": 0.8899094462394714}]}, {"text": "This approach extends to a closure property of the star-free regular languages under the restriction operator (of FSIG).", "labels": [], "entities": [{"text": "FSIG", "start_pos": 114, "end_pos": 118, "type": "DATASET", "confidence": 0.7950593829154968}]}], "datasetContent": [{"text": "I initially extracted the starry subexpressions from the ENGFSIG grammar and classified them using a Perl script.", "labels": [], "entities": [{"text": "ENGFSIG grammar", "start_pos": 57, "end_pos": 72, "type": "DATASET", "confidence": 0.856218695640564}]}, {"text": "At a later stage, I developed a regular expression preprocessor that automated many tasks.", "labels": [], "entities": []}, {"text": "The results were compared across different formulas in order to find possible differences.", "labels": [], "entities": []}, {"text": "The preprocessor could output a script where operands for each restriction operator were defined (and compiled into automata) before the operator was applied.", "labels": [], "entities": []}, {"text": "Every bunch of operand definitions was followed by a formula that implemented the restriction operator with a required number of contexts.", "labels": [], "entities": []}, {"text": "In order to reduce the number of contexts, I gathered unilateral contexts with the preprocessor.", "labels": [], "entities": []}, {"text": "I developed and tested the presented equivalences using the Xerox Finite-State Tool (v.7.4.0).", "labels": [], "entities": [{"text": "Xerox Finite-State Tool", "start_pos": 60, "end_pos": 83, "type": "DATASET", "confidence": 0.8529090086619059}]}, {"text": "My new formula for the restriction operator produced automata that were equivalent to the output of Tapanainen's rule compiler (, which was actually used during the development of ENGFSIG.", "labels": [], "entities": [{"text": "ENGFSIG", "start_pos": 180, "end_pos": 187, "type": "DATASET", "confidence": 0.8528037071228027}]}, {"text": "I also compared these automata to the ones that would result from using method and some variants of it.", "labels": [], "entities": []}, {"text": "Some differences in the results suggest that they use another interpretation for the (compound) restriction operator.", "labels": [], "entities": []}, {"text": "According to that interpretation, overlapping centers are not restricted conjunctively, sometimes resulting in a bigger language.", "labels": [], "entities": []}, {"text": "Simple optimizations in the formula for an ncontext restriction made a notable difference in compilation time.", "labels": [], "entities": []}, {"text": "When I compiled a 7-context restriction (this was a striking exception in ENG-FSIG), an unoptimized version of my formula was very slow (9 min.) compared to a transducer-based method (34.8 sec.), while an optimized version was roughly as efficient (35.5 sec.).", "labels": [], "entities": []}, {"text": "In this example, the number of (outer) conjuncts in my formula was quite high (2 7 ).", "labels": [], "entities": []}, {"text": "The new formula is at its best in the typical case when the number of contexts is smaller than seven.", "labels": [], "entities": []}, {"text": "I did not make experiments with starry subexpressions because they are relatively small and fast to compile anyway.", "labels": [], "entities": []}], "tableCaptions": []}