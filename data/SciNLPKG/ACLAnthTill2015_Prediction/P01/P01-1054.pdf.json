{"title": [{"text": "Tractability and Structural Closures in Attribute Logic Type Signatures", "labels": [], "entities": []}], "abstractContent": [{"text": "This paper considers three assumptions conventionally made about signatures in typed feature logic that are in potential disagreement with current practice among grammar developers and linguists working within feature-based frameworks such as HPSG: meet-semi-latticehood, unique feature introduction , and the absence of subtype covering.", "labels": [], "entities": []}, {"text": "It also discusses the conditions under which each of these can be tractably restored in realistic grammar signatures where they do not already exist.", "labels": [], "entities": []}], "introductionContent": [{"text": "The logic of typed feature structures and, in particular, its implementation in the Attribute Logic Engine, have been widely used as a means of formalising and developing grammars of natural languages that support computationally efficient parsing and SLD resolution, notably grammars within the framework of Headdriven Phrase Structure Grammar.", "labels": [], "entities": [{"text": "SLD resolution", "start_pos": 252, "end_pos": 266, "type": "TASK", "confidence": 0.9727384150028229}, {"text": "Headdriven Phrase Structure Grammar", "start_pos": 309, "end_pos": 344, "type": "TASK", "confidence": 0.6528697162866592}]}, {"text": "These grammars are formulated using a vocabulary provided by a finite partially ordered set of types and a set of features that must be specified for each grammar, and feature structures in these grammars must respect certain constraints that are also specified.", "labels": [], "entities": []}, {"text": "These include appropriateness conditions, which specify, for each type, all and only the features that take values in feature structures of that type, and with which types of values (value restrictions).", "labels": [], "entities": []}, {"text": "There are also more general implicational constraints of the form \u00a2 \u00a1 \u00a3 , where is a type, and \u00a3 is an expression from LTFS's description language.", "labels": [], "entities": []}, {"text": "In LTFS and ALE, these four components, a partial order of types, a set of features, appropriateness declarations and type-antecedent constraints can betaken as the signature of a grammar, relative to which descriptions can be interpreted.", "labels": [], "entities": []}, {"text": "LTFS and ALE also make several assumptions about the structure and interpretation of this partial order of types and about appropriateness, some for the sake of generality, others for the sake of efficiency or simplicity.", "labels": [], "entities": [{"text": "LTFS", "start_pos": 0, "end_pos": 4, "type": "DATASET", "confidence": 0.8674560785293579}]}, {"text": "Appropriateness is generally accepted as a good thing, from the standpoints of both efficiency and representational accuracy, and while many have advocated the need for implicational constraints that are even more general, type-antecedent constraints at the very least are also accepted as being necessary and convenient.", "labels": [], "entities": [{"text": "Appropriateness", "start_pos": 0, "end_pos": 15, "type": "METRIC", "confidence": 0.9617612957954407}, {"text": "accuracy", "start_pos": 116, "end_pos": 124, "type": "METRIC", "confidence": 0.9705125689506531}]}, {"text": "Not all of the other assumptions are universally observed by formal linguists or grammar developers, however.", "labels": [], "entities": []}, {"text": "This paper addresses the three most contentious assumptions that LTFS and ALE make, and how to deal with their absence in a tractable manner.", "labels": [], "entities": []}, {"text": "Meet-semi-latticehood: every partial order of types must be a meet semi-lattice.", "labels": [], "entities": []}, {"text": "This implies that every consistent pair of types has a least upper bound.", "labels": [], "entities": []}, {"text": "2. Unique feature introduction: for every feature, F, there is a unique most general type to which F is appropriate.", "labels": [], "entities": []}, {"text": "3. No subtype covering: there can be feature structures of a non-maximally-specific type that are not typable as any of its maximally specific subtypes.", "labels": [], "entities": []}, {"text": "When subtype covering is not assumed, feature structures themselves can be partially ordered and taken to represent partial information states about some set of objects.", "labels": [], "entities": []}, {"text": "When subtype covering is assumed, feature structures are discretely ordered and totally informative, and can betaken to represent objects in the (linguistic) world themselves.", "labels": [], "entities": [{"text": "subtype covering", "start_pos": 5, "end_pos": 21, "type": "TASK", "confidence": 0.7100221365690231}]}, {"text": "The latter interpretation is subscribed to by, for example.", "labels": [], "entities": []}, {"text": "All three of these conditions have been claimed elsewhere to be either intractable or impossible to restore in grammar signatures where they do not already exist.", "labels": [], "entities": []}, {"text": "It will be argued here that: (1) restoring meet-semi-latticehood is theoretically intractable, for which the worst case bears a disquieting resemblance to actual practice in current large-scale grammar signatures, but nevertheless can be efficiently compilable in practice due to the sparseness of consistent types; (2) unique feature introduction can always be restored to a signature in low-degree polynomial time, and (3) while type inferencing when subtype covering is assumed is intractable in the worst case, a very elegant constraint logic programming solution combined with a special compilation method exists that can restore tractability in many practical contexts.", "labels": [], "entities": [{"text": "type inferencing", "start_pos": 431, "end_pos": 447, "type": "TASK", "confidence": 0.816394031047821}]}, {"text": "Some simple completion algorithms and a corrected NPcompleteness proof for non-disjunctive type inferencing with subtype covering are also provided.", "labels": [], "entities": []}], "datasetContent": [], "tableCaptions": []}