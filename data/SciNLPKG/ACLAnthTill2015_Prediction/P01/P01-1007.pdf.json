{"title": [{"text": "Guided Parsing of Range Concatenation Languages", "labels": [], "entities": []}], "abstractContent": [{"text": "The theoretical study of the range concatenation grammar [RCG] formalism has revealed many attractive properties which maybe used in NLP.", "labels": [], "entities": []}, {"text": "In particular, range concatenation languages [RCL] can be parsed in polynomial time and many classical grammatical formalisms can be translated into equivalent RCGs without increasing their worst-case parsing time complexity.", "labels": [], "entities": [{"text": "range concatenation languages [RCL", "start_pos": 15, "end_pos": 49, "type": "TASK", "confidence": 0.6570550084114075}]}, {"text": "For example, after translation into an equivalent RCG, any tree adjoining grammar can be parsed in \u00a2 \u00a4 \u00a3 \u00a6 \u00a5 \u00a8 \u00a7 \u00a9 time.", "labels": [], "entities": [{"text": "\u00a9 time", "start_pos": 113, "end_pos": 119, "type": "METRIC", "confidence": 0.9137600362300873}]}, {"text": "In this paper, we study a parsing technique whose purpose is to improve the practical efficiency of RCL parsers.", "labels": [], "entities": [{"text": "parsing", "start_pos": 26, "end_pos": 33, "type": "TASK", "confidence": 0.9849233627319336}, {"text": "RCL parsers", "start_pos": 100, "end_pos": 111, "type": "TASK", "confidence": 0.8018246591091156}]}, {"text": "The non-deterministic parsing choices of the main parser fora language are directed by a guide which uses the shared derivation forest output by a prior RCL parser fora suitable su-perset of.", "labels": [], "entities": []}, {"text": "The results of a practical evaluation of this method on a wide coverage English grammar are given.", "labels": [], "entities": []}], "introductionContent": [{"text": "Usually, during a nondeterministic process, when a nondeterministic choice occurs, one explores all possible ways, either in parallel or one after the other, using a backtracking mechanism.", "labels": [], "entities": []}, {"text": "In both cases, the nondeterministic process maybe assisted by another process to which it asks its way.", "labels": [], "entities": []}, {"text": "This assistant maybe either a guide or an oracle.", "labels": [], "entities": []}, {"text": "An oracle always indicates all the good ways that will eventually lead to success, and those good ways only, while a guide will indicate all the good ways but may also indicate some wrong ways.", "labels": [], "entities": []}, {"text": "In other words, an oracle is a perfect guide, and the worst guide indicates all possible ways.", "labels": [], "entities": []}, {"text": "Given two problems and and their respective solutions and , if they are such that \" ! # \u00a8 , any algorithm which solves is a candidate guide for nondeterministic algorithms solving . Obviously, supplementary conditions have to be fulfilled for $ to be a guide.", "labels": [], "entities": []}, {"text": "The first one deals with relative efficiency: it assumes that problem $ can be solved more efficiently than problem . Of course, parsers are privileged candidates to be guided.", "labels": [], "entities": []}, {"text": "In this paper we apply this technique to the parsing of a subset of RCLs that are the languages defined by RCGs.", "labels": [], "entities": [{"text": "parsing of a subset of RCLs", "start_pos": 45, "end_pos": 72, "type": "TASK", "confidence": 0.7170529266198477}]}, {"text": "The syntactic formalism of RCGs is powerful while staying computationally tractable.", "labels": [], "entities": []}, {"text": "Indeed, the positive version of RCGs defines positive RCLs that exactly cover the class PTIME of languages recognizable in deterministic polynomial time.", "labels": [], "entities": []}, {"text": "For example, any mildly context-sensitive language is a PRCL.", "labels": [], "entities": []}, {"text": "In Section 2, we present the definitions of PRCGs and PRCLs.", "labels": [], "entities": []}, {"text": "Then, in Section 3, we These definitions extend naturally from clause to set of clauses (i.e., grammar).", "labels": [], "entities": []}, {"text": "In this paper we will not consider negative RCGs, since the guide construction algorithm presented is Section 3 is not valid for this class.", "labels": [], "entities": []}, {"text": "Thus, in the sequel, we shall assume that RCGs are PRCGs.", "labels": [], "entities": []}], "datasetContent": [{"text": "In order to compare a (normal) RCL parser and its guided versions, we looked for an existing widecoverage grammar.", "labels": [], "entities": []}, {"text": "We chose the grammar for English designed for the XTAG system, because it both is freely available and seems rather mature.", "labels": [], "entities": []}, {"text": "Of course, that grammar uses the TAG formalism.", "labels": [], "entities": []}, {"text": "1 Thus, we first had to transform that English TAG into an equivalent RCG.", "labels": [], "entities": []}, {"text": "To perform this task, we implemented the algorithm described in) (see also), which allows to transform any TAG into an equivalent simple PRCG.", "labels": [], "entities": [{"text": "PRCG", "start_pos": 137, "end_pos": 141, "type": "DATASET", "confidence": 0.81983882188797}]}, {"text": "However, Boullier's algorithm was designed for pure TAGs, while the structures used in the XTAG system are not trees, but rather tree schemata, grouped into linguistically pertinent tree families, which have to be instantiated by inflected forms for each given input sentence.", "labels": [], "entities": []}, {"text": "That important difference stems from the radical difference in approaches between \"classical\" TAG parsing and \"usual\" RCL parsing.", "labels": [], "entities": [{"text": "TAG parsing", "start_pos": 94, "end_pos": 105, "type": "TASK", "confidence": 0.8005311191082001}, {"text": "RCL parsing", "start_pos": 118, "end_pos": 129, "type": "TASK", "confidence": 0.7566817402839661}]}, {"text": "In the former, through lexicalization, the input sentence allows the selection of tree schemata which are then instantiated on the corresponding inflected forms, thus the TAG is not really part of the parser.", "labels": [], "entities": []}, {"text": "While in the latter, the (non-lexicalized) grammar is precompiled into an optimized automaton.", "labels": [], "entities": []}, {"text": "Since the instantiation of all tree schemata by the complete dictionary is impracticable, we designed a two-step process.", "labels": [], "entities": []}, {"text": "For example, from the sentence \"George loved himself .\", a lexer first produces the sequence \"George is an optional occurrence index.", "labels": [], "entities": []}, {"text": "Thus, the association George \" \u0099 n-n nxn-n nn-n \" means that the inflected form \"George\" is a noun (suffix -n) that can occur in all trees of the \"n\", \"nxn\" or \"nn\" families (everywhere a terminal leaf of category noun occurs).", "labels": [], "entities": []}, {"text": "Since, in this two-step process, the inputs are not sequences of terminal symbols but instead simple DAG structures, as the one depicted in, we have accordingly implemented in our RCG system the ability to handle inputs that are simple DAGs of tokens.", "labels": [], "entities": []}, {"text": "In Section 3, we have seen that the language is a CFL (see).", "labels": [], "entities": []}, {"text": "In other words, in the case of TAGs, our transformation algorithm approximates the initial tree-adjoining language by a CFL, and the steps of CF parsing performed by the guiding parser can well be understood in terms of TAG parsing.", "labels": [], "entities": [{"text": "CF parsing", "start_pos": 142, "end_pos": 152, "type": "TASK", "confidence": 0.6700204312801361}, {"text": "TAG parsing", "start_pos": 220, "end_pos": 231, "type": "TASK", "confidence": 0.8233775496482849}]}, {"text": "The original algorithm in performs a one-to-one mapping between elementary trees and clauses, initial trees generate simple unary clauses while auxiliary trees generate simple binary clauses.", "labels": [], "entities": []}, {"text": "Our transformation algorithm leaves unary clauses unchanged (simple unary clauses are in fact CF productions).", "labels": [], "entities": []}, {"text": "For binary V -clauses, our algorithm generates two clauses, For our experiments, we first transformed the English XTAG into an equivalent simple PRCG: the initial grammar compiled with gcc without any optimization flag.", "labels": [], "entities": []}, {"text": "We have first compared the total time taken to produce the guiding structures, both by the \u00a5 \u00bb -guiding parser and by the guiding parser (see    The sizes of these RCL parsers (load modules) are in while their parse times are in Table 4.", "labels": [], "entities": []}, {"text": "We have also noted in the last line, for reference, the times of the latest XTAG parser, 8 on our sample set and on the 35-word sentence.", "labels": [], "entities": []}], "tableCaptions": [{"text": " Table 2: Guiding parsers times (sec)", "labels": [], "entities": [{"text": "Guiding parsers", "start_pos": 10, "end_pos": 25, "type": "TASK", "confidence": 0.7180537283420563}]}, {"text": " Table 3: RCL parser sizes (MB)", "labels": [], "entities": [{"text": "RCL parser", "start_pos": 10, "end_pos": 20, "type": "TASK", "confidence": 0.729855477809906}]}, {"text": " Table 4: Parse times (sec)", "labels": [], "entities": [{"text": "Parse", "start_pos": 10, "end_pos": 15, "type": "METRIC", "confidence": 0.9294690489768982}]}]}